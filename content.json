{"pages":[{"title":"时光里的他和她","text":"","link":"/about/index.html"},{"title":"关于我","text":"","link":"/%E5%85%B3%E4%BA%8E%E6%88%91/index.html"}],"posts":[{"title":"生成随机数组","text":"好久没有写代码，最近这几天把Blog迁移完成啦！！也从Windows切换到了Manjaro 今后几天打算重温一下以前的算法，自从上次程序设计大赛后。感觉自己也没认真学习过多的算法啦。今天就开个头吧，在不温习一下C++,就忘的差不多了！！！ 生成指定范围的随机数在有些编译器中，需要加入头文件ctime就可以调用time()函数, Note: 需要注意rangeL，和rangeR的范围123456789int* generateRandomArray(int rangeL,int rangeR,int n){ int *arr = new int[n]; srand(time(NULL)); for(int i = 0; i &lt; n; i++){ arr[i] = rand() % (rangeR - rangeL ) + rangeL; } return arr;} 采用模板函数进行打印1234567template&lt;typename T&gt;void printArray(T arr[], int n){ for(int i = 0; i &lt; n; i++){ cout &lt;&lt; arr[i]&lt;&lt;\" \"; } cout &lt;&lt; endl;} 随机数的生成，主要是用于排序过程中生成模拟数据。","link":"/2020/07/09/%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%BB%84/"},{"title":"测试排序性能","text":"今天尝试了VScode中Code Runner插件，尽然可以多文件运行。 以前我都一直觉得需要cmake才行，只不过Code Runner这个需要main.cpp文件中点击运行才行，如果是在头文件点击运行，会把头文件直接进行编译😿。于是，我就把整个排序辅助相关函数，写到了不同的文件中，采用不同的命名空间。 判断是否有序代码是从小到打排序 12345678template &lt;typename T&gt; bool isSorted(T arr[], int n) { for (int i = 0; i &lt; n - 1; i++) if (arr[i] &gt; arr[i + 1]) return false; return true; } 性能测试获取系统时钟，计算排序的耗时长短，单位为秒。采用啦assert函数，进行中断，有些编译器需要包含头文件。P不过，编写的时候也没有包含，不过编译提示我啦。Linux 好评👍 123456789101112template &lt;typename T&gt;void testSort(string sortName, void (*sort)(T[], int), T arr[], int n){ clock_t startTime = clock(); sort(arr, n); clock_t endTime = clock(); assert(isSorted(arr, n)); cout &lt;&lt; sortName &lt;&lt; \":\" &lt;&lt; double(endTime - startTime) / CLOCKS_PER_SEC &lt;&lt; \" S\" &lt;&lt; endl; return;} 排序辅助空间在头文件中实现，并创建啦SortTestHelper命名空间。在main函数中变可以直接调用。对于过多的实现，不推荐把实现代码写在头文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#ifndef SORTTESTHELPER_H#define SORTTESTHELPER_H#include &lt;iostream&gt;#include &lt;cassert&gt;using namespace std;namespace SortTestHelper{ int *generateRandomArray(int rangeL, int rangeR, int n) { int *arr = new int[n]; srand(time(NULL)); for (int i = 0; i &lt; n; i++) { arr[i] = rand() % (rangeR - rangeL) + rangeL; } return arr; } template &lt;typename T&gt; void printArray(T arr[], int n) { for (int i = 0; i &lt; n; i++) { cout &lt;&lt; arr[i] &lt;&lt; \" \"; } cout &lt;&lt; endl; } template &lt;typename T&gt; bool isSorted(T arr[], int n) { for (int i = 0; i &lt; n - 1; i++) if (arr[i] &gt; arr[i + 1]) return false; return true; } template &lt;typename T&gt; void testSort(string sortName, void (*sort)(T[], int), T arr[], int n) { clock_t startTime = clock(); sort(arr, n); clock_t endTime = clock(); assert(isSorted(arr, n)); cout &lt;&lt; sortName &lt;&lt; \":\" &lt;&lt; double(endTime - startTime) / CLOCKS_PER_SEC &lt;&lt; \" S\" &lt;&lt; endl; return; }} // namespace SortTestHelper#endif 排序空间也写在啦头文件中 😄,采用的是Sort这个命名空间。后期所有的排序算法都写在这个命名空间下面。 👍（自我安慰一下 🍮）第一算法是选择排序，时间复杂度是O(n^2)整个排序思维比较简单，我就不多说了 🦎 🦎 123456789101112131415161718192021#ifndef SORT_H#define SORT_H#include &lt;iostream&gt;#include &lt;cassert&gt;using namespace std;namespace Sort{ void selectionSort(int arr[], int n) { for (int i = 0; i &lt; n; i++) { int minIndex = i; for (int j = i + 1; j &lt; n; j++) if (arr[j] &lt; arr[minIndex]) minIndex = j; swap(arr[i], arr[minIndex]); } }} // namespace Sort#endif 调用🤽‍♀ 到啦这里是不是amazing丫调用就是如此简单，不太推荐使用using namespace std;(我还是这么写啦 😄)这种方式声明命名空间，会污染命名空间 12345678910111213#include &lt;iostream&gt;#include \"SortTestHelper.h\"#include \"Sort.h\"using namespace std;int main(){ int n = 100; int *arr = SortTestHelper::generateRandomArray(1,n,n); SortTestHelper::testSort(\"Selection sort\",Sort::selectionSort,arr,n); SortTestHelper::printArray(arr,n); return 0;}","link":"/2020/07/10/%E6%8E%92%E5%BA%8F%E8%BE%85%E5%8A%A9/"},{"title":"初次遇见，Howdy","text":"自从上次双11，剁手买来Lenovo 小新 Pro 13 电脑后，我就天天想着安装Arch Linux系统 😄，可以是刚好临近毕业。毕业文档要用word写，我也很无奈，毕竟Linux 中对word支持不是很好 👎。 就在前不久，我入手啦Arch的儿子。就是Manjaro(基于arch开发)，我终于体会到啦，安装系统过程的简便性。(好评 👍 👍)。但是我的Windows Hello功能就废了。 初识Howdy不久就我逛Github的时候就发现这个仓库，这就令我非常Amazing呀。对于Arch 派，一条命令就能安装。 1yay -S howdy arch派就是这么简单，欢迎加入 🇯🇴不过重点不在这里，因为国内网络的问题(我也不想多说，懂的自然懂 ☕️)下载一个包特别慢，我就尝试啦proxychains。结果yay不支持 😢 YAY 重造查了老半天发现，需要重新编译yay才行。下面直接开干吧！ 👷 安装gcc-go需要使用gcc-go 重新编译 1yay -S gcc-go 克隆yay源码并编译这里就使用git 123git clone https://aur.archlinux.org/yay.gitcd yaymakepkg -si 克隆proxychains-ng 并编译最后一条命令可以不执行，懂得都懂 😏 123456git clone https://github.com/rofl0r/proxychains-ng.gitcd proxychains-ng./configuremake &amp;&amp; make installcp ./src/proxychains.conf /etc/proxychains.confcd .. &amp;&amp; rm -rf proxychains-ng 配置proxychains路径为/etc/proxychains.conf使用vim修改配置文件 1vim /etc/proxychains.conf 将 1socks4 127.0.0.1 9095 改为 1socks5 127.0.0.1 1080 端口有可能有差异，与代理软件设定的端口一致就可以。到这里yay就重新编译完成啦。 Howdy安装在需要使用代理的命令上加上 proxychains4 1proxychains4 yay -S howdy 到这里就结束啦，howdy的具体配置在Arch wiki都有。而且非常的详细，我就不多说啦！！！","link":"/2020/07/11/%E5%88%9D%E6%AC%A1%E9%81%87%E8%A7%81%EF%BC%8CHowdy/"},{"title":"Shell之变量","text":"这是Shell脚本的第一遍博客，为啥要写呢？？ ❓当然，我最近在学shell脚本啦，那为啥要学呢？正所谓，学习是一种人生的追求……（装不下去啦 😼） 其实学习Shell脚本，是为了简化一些需要大量重复的工作。 🙆‍♂ 闲言少叙。Let’s go！！！！ 什么是Shell脚本Shell脚本（英语：Shell script），又称Shell命令稿、程序化脚本，是一种电脑程序使用的文本文件，内容由一连串的shell命令组成，经由Unix Shell直译其内容后运作。被当成是一种脚本语言来设计，其运作方式与解释型语言相当，由Unix shell扮演命令行解释器的角色，在读取shell脚本之后，依序运行其中的shell命令，之后输出结果。利用shell脚本可以进行系统管理，文件操作等。（WIkipedia 就是这么解释的 😄） Shell脚本基本内容第一行，#!开头就是自定解释器，这里使用/usr/bin/sh 做解释器。其他的后面会说 💁‍♂ 12345#!/usr/bin/shcd ~/Desktopfor ((i=0; i&lt;100; i++)); do mkdir 换回windows吧_$idone 查看解释器该命令可以查看系统，已经安装了那些脚本解释器。 1$ cat /etc/shells 变量变量这个东西，是非常基础的。基础到我不想多说 :smile: 定义变量显式直接赋值12i=0str=\"Hello J\" 间接赋值通过另一个输出，输入到变量中 12345678910111213for file in `ls /etec` # ls /etc 输出的结果，输入到变量 file中``` ##### Note: 变量名和等号之间不能有空格,单个#开头是注释### 使用变量这就很简单啦 😸在变量面前加一个美元符号就可以。果然只要给钱啥都简单～～～```Bashecho $file # echo 输出语句echo ${file} # 等价上面，花括号可选 Note: 花括号是为了标定变量边界重定义变量这就有点，不符合我以往的编程经验啦～已定义的变量，可以被重新定义 12345i=0echo &amp;ii=12echo &amp;i 字符串这个东西经常用到 😼，可以使用单引号或双引号 单引号1string='i am j' 单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的 单引号字串中不能出现单引号（对单引号使用转义符后也不行） 双引号12j=1string=&quot;I am Janking \\&quot;$j&quot;! \\n&quot; 双引号里可以有变量 双引号里可以出现转义字符 获取长度12string=\"abcdef\"echo ${#string} #输出 6 提取子串12string=\"linux is a great OS\"echo ${string:0:4} #输出：linux 今天就到这里吧，finger crossed!!","link":"/2020/07/14/Shell%E8%84%9A%E6%9C%AC%E4%B9%8B%E5%8F%98%E9%87%8F/"},{"title":"Shell之语句","text":"昨天我….陪小朋友👦打球🏀去啦，就没有写🤣。不过，有个人告诉我，TA看了我的博客(开心😃)今天就直接开始吧 if语句格式1234if [ expression ]then Statement(s) to be executed if expression is truefi Note: expression和方括号([ ])之间必须有空格，否则会有语法错误。形式有三种形式 123if ... fi 语句if ... else ... fi 语句if ... elif ... else ... fi 语句 示例12345678910111213#!/us/bin/sha=10b=10c=12if [ $a == $b ]then trans -sp \"a等于b\"elif [ $a == $c ]then trans -sp \"a等于c\"else trans -sp \"用会Windows吧\"fi 示例很简单，就不多罗嗦啦🤫 case语句M为需要匹配的东西，*) 其他没有匹配则执行 格式12345case $var in M) Statement；; M) Statement;; *) Statement;;esac Note 取值后面必须为关键字 in. 每一模式必须以右括号结束。 取值可以为变量或常数。 匹配发现取值符合某一模式后，其间所有命令开始执行直至 ;;。;; 与其他语言中的 break 类似，意思是跳到整个 case 语句的最后。 示例1234567#!/us/bin/sha=10case $a in 10) trans -sp \"a等于b\";; 12) trans -sp \"a等于c\";; *) trans -sp \"用会Windows吧\";;esac for语句格式1234567for var in rangedo Statement1 Statement2 ... StatementNdone range 为循环范围，如果学过Python的话，这里和python很类似。🙈 示例12345#!/us/bin/shfor value in 5 4 3 2 1 do trans -sp \"用会Windows吧${value}\"done while语句格式1234while [ expression ]do Statement(s) to be executed if expression is truedone 示例1234567#!/us/bin/shc=0;a=0;while [ $a == $c ]do echo $cdone 会一直在终端输出0,小心哦🙃 until 语句until 循环执行一系列命令直至条件为 true 时停止。until 循环与 while 循环在处理方式上刚好相反。一般while循环优于until使用。 格式1234until [ expression ]do Statement(s) to be executed if expression is falsedone 示例1234567#!/us/bin/shc=0;a=1;until [ $a == $c ]do echo $cdone 这个东西和wile好相似哦。这个脚本也会一直在终端输出。 跳出循环break,continue 和c语言使用类似 breakbreak 命令跳出最外层循环。🤹🏼‍♂️ 示例1234567891011#!/us/bin/shc=0;a=0;b=0;while [ $c == $a ]do if [ $b == $a ] then break fidone 在嵌套循环中，break 命令后面还可以跟一个整数，表示跳出第几层循环 1break n continuecontinue 终止该次循环，继续下一次。👷 示例123456789#!/us/bin/shfor a in 1 2 3 4 5do if [ $a == 2 ] then continue fi echo $adone 不会输出2 ～～～～～～～～～～～～The End ~ 哈哈哈哈，如果我是一只企鹅🐧，我就会非常努力学习游泳，游到北极去和北极熊🐨玩耍！！！","link":"/2020/07/16/Shell%E8%84%9A%E6%9C%AC%E4%B9%8B%E8%AF%AD%E5%8F%A5/"},{"title":"Shell之函数","text":"我已经有几天没有写博客啦，因为这几天成绩出来了。🤹🏼‍♂️这我又看出来了，公布成绩的耍猴过程。其实这几天，我也没有看shell脚本的知识。我最近迷上啦，看纸质的书;在阅读奥古斯丁《忏悔录》 这本书真的很有意思👋，我就不多说啦！这就开始吧！！！！！ 函数定义Shell也支持函数，Shell函数必须定义在使用前面。函数调用只需要给出函数名，不需要加入括号。函数返回值，可以显式增加return语句；如果不加，会将最后一条命令运行结果作为返回值。Shell 函数返回值只能是整数 格式1234function function_name () { list of commands [ return value ]} function 为可选关键字 示例123hello(){ echo 'hello';} 运行结果很显然，我就不多说啦🤣 返回字符串如果一定要让函数返回字符串，那么可以先定义一个变量，用来接收函数的计算结果。脚本在需要的时候访问这个变量来获得函数返回值。 示例12345function hello(){ return 'hello';}str=helloecho $str 这样就可以返回字符串啦🤔🤔🤔 函数参数Shell 调用函数时可以向其传递参数，在函数内部，通过$n的形式获取参数 示例12345678910111213#!/bin/bashfunction sum(){ case $# in 0) echo \"no param\";; 1) echo \"1 param\";; 2) echo \"2 param\";; 3) echo \"3 param\";; *) echo \"$# params!!\";; esac}sum 1 2 3 4 变量说明 特殊变量 说明 $# 传递给函数的参数个数 $* 显示所有传递给函数的参数 $@ 与$*相同，但是略有区别，请查看Shell特殊变量 $? 函数的返回值 获取函数返回值1234567#!/bin/bashfunction sum(){ echo 1}echo $(sum) 这就可以获取到函数的返回值啦，是不是非常Amagzing🧖🏻 shell脚本结合Linux一些命名，在使用过程中是非常便捷的。如果需要批连创建文件，或者进行软件的编译安装。都可以通过shell脚本进行操作。","link":"/2020/07/20/Shell%E4%B9%8B%E5%87%BD%E6%95%B0/"},{"title":"Linux使用QQ与微信","text":"对于一般Linux用户，QQ，微信。是经常需要使用的东西。🙃不过对于我这种，神一般的Linux用户而言。QQ啥的就不是很需要啦。🤣“有事给我发电子邮件”，这是我常说的。 QQ的确用的很少，但还是要记录一下QQ、微信安装和配置的！！ QQ for Linux这是首选Linux 下面的QQ解决方案。这个东西，在愚人节过后更新啦，我也是很佩服。但是依旧是秦始皇年代的界面风格🤪这个QQ毕竟可以流畅的使用，虽然有时崩溃。### 安装安装方式都是很简单，官方都有。如果Arch ,Manjaro 就使用下面这条命令 1sudo pacman -S qq-linux https://im.qq.com/linuxqq/index.html Deepin-QQ与Deepin-Wechat需要完整的QQ、Wechat体验，可以安装Deepin应用，在Manjaro中，由于有AUR源、Archlinuxcn源的加持，安装过程是非常方便的。安装微信，只需在AUR中找到并安装deepin-wine-wechat；安装QQ，只需在AUR中找到并安装deepin-wine-tim或者deepin-wine-qq即可。安装软件包后，打开软件，按照提示完成进一步的安装配置之后就可使用。 安装TIM1yay -S deepin-wine-tim QQ1yay -S deepin-wine-qq wechat1yay -S deepin-wine-wechat DPI安装完成后，会发现字体比较小，使用 12WINEPREFIX=~/.deepinwine/Deepin-QQ deepin-wine winecfg #修改QQ的DPIWINEPREFIX=~/.deepinwine/Deepin-TIM deepin-wine winecfg #修改TIM的DPI 则可以调整DPI了对于微信，可以使用网页版，也可以去Github下载高手封装好了的网页版微信，就不用打开浏览器登入微信啦 无法显示图片聊天图片与头像无法显示，或者始终处于加载中，是因为QQ的图片解析与ipv6不兼容，需要关闭ipv6。在终端使用 123sudo sysctl -w net.ipv6.conf.all.disable_ipv6=1sudo sysctl -w net.ipv6.conf.default.disable_ipv6=1sudo sysctl -w net.ipv6.conf.lo.disable_ipv6=1 Note：以上命令在深度Deepin Linux系统下有效，其他Linux发行版可参考。我也没测试。我的安装好就能用🤣","link":"/2020/07/21/%E4%BD%BF%E7%94%A8QQ%E4%B8%8E%E5%BE%AE%E4%BF%A1/"},{"title":"Python之基本数据类型","text":"我回来啦！！ 回到我的家乡🎊今天拿到啦毕业证书，没想到里面还有一张优秀毕业设计证书🤣可是好简陋，我一脸嫌弃😏 闲言少叙，下面就开写进入Python的世界吧～～～🐍 字符串字符串英文 string ，是 python 中随处可见的数据类型。 字符串的识别也非常的简单，就是用「引号」括起来的引号包括单引号 ‘ ‘ ，双引号 “ “ 和 三引号 ‘’’ ‘’’ ，比如 ‘abc’ ，”123” 等等。 Note: 为啥有这么多引号呢？ 一个不行吗？🤔原因其实很简单 单引号： 引用的字符串中不能有单引号「·用双引号」 双引号： 引用的字符串中不能有双引号「·用三引号」 其实这里可以直接转义字符比如单引号，你可以使用 \\‘ 来表示，双引号可以使用 \\“ 来表示。 示例123print('Hello Python')print(\"Hllo 'Python'\")print('''Hello \"Python\"''') 运行结果 123Hello PythonHllo 'Python'Hello \"Python\" 整数整数英文为 integer 。这里不多说,和C非常相似。我们直接看代码🤪 示例123456789int1 = 1int2 = 100int3 = -100int4 = 1 / 2print(int1)print(int2)print(int3)print(int4) 运行结果： 12341100-1000.5 Note： 1／２ 会得到０.5 int4会自动提升为float类型。 １//2 才会得到０Python运算符＋ 、- 、* 我就不列举啦，太简单和日常一样 运算符 表示 说明 ／ 除 １／２ 输出结果０.５ ％ 取模 5%2 输出结果１ ** 幂 2**3 为２的３次方 // 取整 11//2 输出结果 ５ 浮点数浮点数的英文名是 float ，是指带小数的数字。对浮点数的表达本身是不精确的。保存在计算机中的是二进制数，二进制对有些数字不能准确表达，只能非常接近这个数。 示例123print(0.55+0.41)print(0.55+0.4)print(0.55+0.411) 运行结果: 1230.960.95000000000000010.9610000000000001 #####Note: 浮点数不能准确表达，对浮点数做运算和比较大小的时候要小心。 布尔值一个布尔值只有True、False两种值「注意大写开头」🤫布尔值可以用and、or、not运算。 and 运算是与运算，只有所有都为 True，and 运算结果才是 True。 or 运算是或运算，只要其中有一个为 True，or 运算结果就是 True。 not 运算是非运算，它是一个单目运算符，把 True 变成 False，False 变成 True。 这里很多语言都是一致的🤫,其实就是布尔代数🙃 空值Python 使用Node「开头大写」来表示 编码问题 我们都知道计算机只能处理数字，如果要处理文本，就必须先把文本转换为数字才能处理。最早的计算机在设计时采用8个比特（bit）作为一个字节（byte），所以，一个字节能表示的最大的整数就是255（二进制11111111=十进制255），0 - 255被用来表示大小写英文字母、数字和一些符号，这个编码表被称为ASCII编码，比如大写字母 A 的编码是 65，小写字母 z 的编码是 122。 如果要表示中文，显然一个字节是不够的，至少需要两个字节，而且还不能和 ASCII 编码冲突，所以，中国制定了 GB2312 编码，用来把中文编进去。类似的，日文和韩文等其他语言也有这个问题。为了统一所有文字的编码，Unicode 应运而生。 Unicode 把所有语言都统一到一套编码里，这样就不会再有乱码问题了。Unicode 通常用两个字节表示一个字符，原有的英文编码从单字节变成双字节，只需要把高字节全部填为 0 就可以。 因为 Python 的诞生比 Unicode 标准发布的时间还要早，所以最早的Python 只支持 ASCII 编码，普通的字符串 ‘ABC’ 在 Python 内部都是 ASCII 编码的。&gt;Python 在后来添加了对 Unicode 的支持，以 Unicode 表示的字符串用u’…’表示。不过在最新的 Python 3 版本中，字符串是以 Unicode 编码的，也就是说，Python 的字符串支持多语言。就像上面的例子一样，我的代码中没有加u’…’，也能正常显示。 不过由于 Python 源代码也是一个文本文件，所以，当你的源代码中包含中文的时候，在保存源代码时，就需要务必指定保存为 UTF-8 编码。当Python 解释器读取源代码时，为了让它按 UTF-8 编码读取，我们通常在文件开头写上这两行： 12#!/usr/bin/env python3 # -*- coding: utf-8 -*- 第一行注释是为了告诉 Linux/OS X 系统，这是一个 Python 可执行程序，Windows 系统会忽略这个注释；第二行注释是为了告诉 Python 解释器，按照 UTF-8 编码读取源代码，否则，你在源代码中写的中文输出可能会有乱码。 申明了 UTF-8 编码并不意味着你的 .py 文件就是 UTF-8 编码的，必须并且要确保文本编辑器正在使用 UTF-8 without BOM 编码 今天就先到这里吧～～ 加油，加油🧑‍🔬","link":"/2020/07/27/Python%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"title":"备考过程及我的方法","text":"考试也结束啦，结果还不错🤪。下面我就记录分享一下，我以往的学习方式及备考过程。 我的自学观点我是一个方法论者面对一切东西都有其方式与方式，无论是与人打交道，还是学习一个新的工具，或者是谈恋爱都有方法。相比于努力，我更喜欢高效率。当然，我也不是那种非常勤奋的人🙈。在我面对一个新的事物，并学习它的时候。我通常是先去了解大体的框架，然后基于这个框架逐步去细化，直至每一个需要学习的知识点都掌握。这是我以往的学习方法，看上去是非常像软件工程中逐步求精的过程。 他人建议的参考在自学过程中，常常身边会有一群学习的伙伴，或者是老师。他们往往会提供一些建议与学习的资料。 如何对待这些人的建议的呢？对于给我建议的人，我必然是表示感谢。但是这并不意味着需要完全接受他们的建议，而摒弃原有自己的学习方式与计划。 比如： 有个同学推荐你去做一套英语试卷，他说他就是写完这套试卷就把英语成绩提升去。他就推荐你去做这套试卷。然后你很都不能写出来。而且最后英语成绩也没有提高。反而是浪费啦自己的时间。原因就是两个对英语的掌握情况不一致导致的。一个人英语刚刚入门，另一词汇量足够，语法不太好。使用同一个学习方式，同一个学习进度。必然是得不到两人都能把英语成绩提高的目标 自学阶段的定位要在实际中回答上一个问题，在自学过程中自我定位是必然的。当自己知道了，自己目前自学所在的阶段。才能搞清楚哪些内容是需要自己目前学的，哪些是后阶段要学的，哪些是习题是目前需要做的。 如何定位想要确定自己处于哪一个自学阶段，就需要对整个自学过程的框架有大体的认识(这就是我为什么先会去了解大体的框架)。 大体框架知道啦，处于哪一个学习阶段就很简单啦。后续就可对该阶段进行学习，其学习方法可以当做学一个新的东西，继续套用上述方式。 比如：我现在的目标是学习英语。我发现英语就是由词汇和语法组成。且需要一定词汇才能学习语法。基于以上这个框架。我就可以得出，我的第一个学习阶段是记忆单词，提升自己的词汇量。而对于记忆单词，又有记忆单词的方法(比如谐音，词根词缀，记忆单词时候阅读一些英语文章，起到复习着用这写都是记忆单词的方法)。单有了一定的基础后，我就可以渐渐学习语法的基础知识了。但我们学习了语法，对于语法这个子集有可以进一步展开学习。即语法就由时态、语态、句型等等组成。 在整个过程，会发现我基于英文就是由词汇和语法组法的框架会逐步细化，渐渐变成英语就是由词汇和语法(时态语态、句型、从句等)的框架。当我们逐步去学习这个框架的子集，就等价于学习了具体每个知识点。 Note:以上是我的学习方法，不仅仅用于考试。我日常学习新的编译语言也是使用这个方法。 备考过程以前不久的专生本考试为例。一共考3个科目(大学英语、高等数学、C语言)虽然这个才考了213分，专业排名第3名。 备考决策对于考试科目，肯定有自己善长，有自己薄弱的。我的备考策略分为 发考纲前在这个阶段，可以学习基础知识，先把基础夯实。 英语可以先记忆单词，学习语法 数学先从理解的角度记忆公式，巩固基本概念的理解 专业也要从基础学起，我的C语言，我是把一些基本概念复习了一遍 Note: 这个阶段，可以看一些视频教程。如果看资料难以写理解的话。 发考纲后考纲一般是在考前两个月发(湖南省是这样，一般学校老师会说)在这个阶段就要系统的刷题了。无论是自己善长的还是薄弱的都要去系统的刷一些题目。刷题就是看病，检查有病就要治疗。不要盲目的刷题，当检查错题时分析自己写错的原因。考前1个月了有些科目还是没有入门，那就减少该科的学习时间。我就在考前2两个星期基本上看英语的时间很少(尽管有人跟我说英语很拉分，当我并没有花大量时间)，重点都在数学和专业知识点的梳理上啦。考前一个月，就是做一些基本题目。和看以前写过的习题。然后，总结自己不清晰的知识点。 考纲分析学校发布考纲后，一定要认证阅读考纲。可以重考纲中，去分析哪些知识是自己不会的。重点看考纲的 “识记”、“了解”、“掌握”、“应用”这写关键字。还有整体知识点的占比。比重大的必然考的多，基础的也考得多。 Note: 考纲结合复习资料，在目录标志自己没有掌握的知识点 难题分析在练习过程，往往会有一些题目困住自己。这个时候，我们需要分析自己是由于什么样的原因，而不能解答。 知识遗漏对于这类题目，需要去查阅知识点才能解答。那么需要把这个知识，自己去识记下来。我是拿了一个小本子记录📑。 粗心大意这类题目，往往是自己马虎，对于题目的知识点都掌握啦。或者题目在玩文字游戏。这个类问题，往往和人有关。有些人重小就仔细。我就是一个马虎的人，我是在写题目的时候，保持注意力集中和环境安静(把电子设备都关了)。做题目的时候，不去想别的事情 思维困难这种题目，就是咋都想不到，解题的方法。我有一次，在计算极限的时候，就没有想到需要对(1 - a^3) 进行展开，再化简。这个问题，我也会记录在小本子上📑。下次做题的时候，就会试着向这个方向思考。对于思维困难，必须要多做题目才行。 最后的话备考一定明确，考试范围。 备考要制定自己的计划，复习的整体计划。每日计划也可以制定(我没有制定，我一般只有整体计划) 考前，要梳理知识点。不要在意别人过多的决定和眼光(备考心态也要注意) 有了目标、计划就去完成。大家加油🤞🤞 要搞清楚自己人生的剧本——不是你父母的续集，不是你子女的前传，更不是你朋友的外篇。 –尼采","link":"/2020/07/28/%E5%A4%87%E8%80%83%E8%BF%87%E7%A8%8B%E5%8F%8A%E6%88%91%E7%9A%84%E6%96%B9%E6%B3%95/"},{"title":"Manjaro连接隐藏WIFI","text":"今天远行，但是高铁晚点啦几分钟。我又很饿🤗。我就非常的不开心。现在我已经到达了，目的地。于是乎我开启了我的电脑，想要上上网～～～ 可是wifi是隐藏的，也就是说没有广播SSID。这对于我来说，是一个大问题。因为我以前就遇到啦这个问题，但是我利用啦曲线救国。我就直接改了路由器的设置，开启啦SSID广播。不过，这个我懒得捣腾啦。🤣 我决定好好，看看官方的Wiki了。巧了官方还针给出啦，连接隐藏wifi的方案！！！不过，填写SSID的时候需要加入单引号，才能连接成功，不然会提示SSID找不到 https://wiki.archlinux.org/index.php/NetworkManager_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87) 官方wiki都很详细，我就不多说啦。我只记录官方没有说明的一些细节部分。🤪今天就到这里吧！！","link":"/2020/07/30/Manjaro%E8%BF%9E%E6%8E%A5%E9%9A%90%E8%97%8FWIFI/"},{"title":"List和Tuple","text":"之前写了，学习了基本数据类型。今天就该学习List了 List（列表）List是Python 内置的一种数据类型。他是一种有序的集合，可以随时添加和删除其中的元素 创建列表1name = ['Linux','arch','kernel','manjaro'] 列表元素不一定是相同的元素。 使用print可以直接打印。 访问元素 通过索引来访问1print(name[2]) 通过方括号的形式来截取列表中的元素1print(name[0:2]) #左闭右开 左索引缺省为01print(name[:2]) 右索引缺省为列表最后一个1print(name[1:]) 更新元素对索引直接赋值，就可以 1name[2]='archkernel' 添加元素使用append()方法来添加 1name.append('ubuntu') #元素添加到列表末尾 删除元素使用del语句来删除列表的元素 1del name[2] #删除位置的以后索引的元素自动先前填充 List运算符 Python 表达式 结果 描述 len([1, 2, 3]) 3 计算元素个数 [1, 2, 3] + [4, 5, 6] [1, 2, 3, 4, 5, 6] 组合 [‘Hi!’] * 4 [‘Hi!’, ‘Hi!’, ‘Hi!’, ‘Hi!’] 复制 3 in [1, 2, 3] True 元素是否存在于列表中 for x in [1, 2, 3]: print x, 1 2 3 迭代 List函数 函数 描述 max(list) 返回列表元素最大值 min(list) 返回列表元素最小值 list(seq) 将元组转换为列表 list.append(obj) 在列表末尾添加新的对象 list.count(obj) 统计某个元素在列表中出现的次数 list.extend(seq) 在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表） list.index(obj) 从列表中找出某个值第一个匹配项的索引位置” list.insert(index, obj) 将对象插入列表 list.pop(obj=list[-1]) 移除列表中的一个元素（默认最后一个元素），并且返回该元素的值 list.remove(obj) 移除列表中的一个元素（参数是列表中元素），并且不返回任何值} list.reverse() 反向列表中元素 list.sort([func]) 对原列表进行排序 Tuple (元组)tuple一旦初始化就不能修改。 创建元组1tuple=('Linux','arch','kernel','manjaro') 创建空元组 1tuple=() Note: 创建元组中只包含一个元素时，需要在元素后面添加逗号。避免产生歧义。 访问元组访问方式和List一样👋 修改元组可以对元组进行连接组合，而打到修改元组内容的🤗。 123456list1=[123,456]tuple1=('两点水','twowater','liangdianshui',list1)print(tuple1)list1[0]=789list1[1]=100print(tuple1) 这样就可通过修改List，而达到修改Tuple的目的。 Note: Tuple一开始指向list，修改list的内容，并没有改变别指向。 删除元组与List一致，使用del语句。但是不能单独删除单个元素，因为不可变。 1del tuple 元组运算符元组之间可以使用 + 号和 * 号进行运算。这就意味着他们可以组合和复制，运算后会生成一个新的元组。 Python表达式 结果 描述 len((1, 2, 3)) 3 计算元素个数 (1, 2, 3) + (4, 5, 6) (1, 2, 3, 4, 5, 6) 连接 (‘Hi!’,) * 4 (‘Hi!’, ‘Hi!’, ‘Hi!’, ‘Hi!’) 复制 3 in (1, 2, 3) True 元素是否存在 for x in (1, 2, 3): print(x) 1 2 3 迭代 元组内置函数 方法 描述 len(tuple) 计算元组元素个数 max(tuple) 返回元组中元素最大值 min(tuple) 返回元组中元素最小值 tuple(seq) 将列表转换为元组","link":"/2020/08/02/List%E5%92%8CTuple/"},{"title":"Shell之处理命名参数","text":"今天练习了一下shell脚本，之前简单的学习啦shell脚本的语法。😅刷了HackerRank的题目以后，发现还是不能很好的驾驭shell这把神剑。 于是，我决定闭关修炼😝修炼过程中，我发现啦很多武林绝学🌻。令我感到非常的Amazing。下面就来看看吧！！！ 示例12345678910111213deploy=falseuglify=falsewhile(( $# &gt; 1 ));do case $1 in --deploy) deploy=\"$2\";; --uglify) uglify=\"$2\";; *) break; esac; shift 2done$deploy &amp;&amp; echo \"will deploy... deploy = $deploy\"$uglify &amp;&amp; echo \"will uglify... uglify = $uglify\" Note: 最后两行，与&amp;&amp;的运算方式有关 $# 参数个数运行方式1bash script.sh --deploy true --uglify false true 和fasle 为输入值特殊变量 变量 含义 $0 当前脚本的文件名 $n 传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例 $# 传递给脚本或函数的参数个数。 $* 传递给脚本或函数的所有参数。 $@ 传递给脚本或函数的所有参数。被双引号(“ “)包含时，与 $* 稍有不同 $? 上个命令的退出状态，或函数的返回值。 $$ 当前Shell进程ID。对于 Shell 脚本，就是这些脚本所在的进程ID。 $@和$*的区别 不被双引号(“ “)包含时，都以”$1” “$2” … “$n” 的形式输出所有参数。 被双引号(“ “)包含时， “$*” 会将所有的参数作为一个整体，以”$1 $2 … $n”的形式输出所有参数； “$@” 会将各个参数分开，以”$1” “$2” … “$n” 的形式输出所有参数(带换行输出)。 示例1234567891011121314151617181920212223echo \"print each param from \\$*\"for var in $*do echo \"$var\"doneecho \"print each param from \\$@\"for var in $@do echo \"$var\"doneecho \"print each param from \\\"\\$*\\\"\"for var in \"$*\"do echo \"$var\"doneecho \"print each param from \\\"\\$@\\\"\"for var in \"$@\"do echo \"$var\"done 今天，就先到这里吧!!","link":"/2020/08/09/Shell%E4%B9%8B%E5%A4%84%E7%90%86%E5%91%BD%E5%90%8D%E5%8F%82%E6%95%B0/"},{"title":"qBittorrent下载加速","text":"Linux 下面如何下载Bittorrent的资源呢🤔🤔？？如果是在Windows下面,迅雷🐦一般是第一选择． 今天，我试图下载Kali Linux 镜像的时候，发现官方提供了，BitTorrent下载方式．我就打算在我的Linux 下面尝试一下．结果下载速度非常快😝 安装qBittorrentqBittorrent是一个跨平台的自由BitTorrent客户端，其图形用户界面是由Qt所写成的． 下载链接：https://www.qbittorrent.org/download.php 等待下载完成后，就可以安装啦． Arch系列如果是Arch Linux ，或者是基于Arch Linux 的系统 1sudo pacman -S qbittorrent 可以使用上述命令直接安装． 加入Tracker 服务器Tracker服务器，主要目的是为了，提升下载速度. 由于tracker对BT下载起到客户端协调和调控的重要作用，所以一旦被封锁会严重影响BT下载，如2009年12月，中华人民共和国广电总局对BTchina一系列的tracker进行打击，因此也促使新BT客户端支持DHT网络实现无中心tracker，分布式资源分享的影响需要了解更多Tracker服务器，可以自行搜索． qBittorrent 添加tracker服务器添加tracker服务器 点击Preferences 找到Bittorent选项 勾选 automatically add thes trackers to new downloads 选项 粘贴tracker服务器列表，即可点击apply Note: qBittorrent添加完成tracker服务器后需要，重新启动软件． tracker服务器列表 Best Tracker list: https://trackerslist.com/best.txt All Tracker list: https://trackerslist.com/all.txt Http(s) Tracker list: https://trackerslist.com/http.txt 这些是我日程使用的Tracker服务器列表，这个仓库列表，已有人发布到github仓库中．这里我就不给出仓库连接了，在我的收藏的仓库中可以找到😝 关于Bittorent 就分享到这里吧，DHT的中文全称是分布式哈希表(distributed has table 的缩写)，这可以避免中心tracker服务器的不能工作而导致这个系统的瘫痪．是一些天才的杰作．","link":"/2020/08/13/qBittorrent%E4%B8%8B%E8%BD%BD%E5%8A%A0%E9%80%9F/"},{"title":"Linux安装VirtualBox","text":"昨天，我下载好了kali镜像后.今天,反手就是一个条命令吧VirtualBox安装好了,结果可想而知🤣 安装的VirtualBox可以运行,但是就是不能启动里面的虚拟系统.这就很令我发愁,本来因为是BIOS没有开启虚拟化.经过排查并不是这个原因.🤔后来才知道,需要安装对应内核版本的安装包,才行 确定Linux内核版本 安装对应内核版本的安装,需要查询但前实习使用的内核. 使用uname -r 命令即可查询12$ sudo uname -r5.6.19-2-MANJARO 表示需要安装linux内核版本为5.6 安装VirtualBox需要安装VirtualBox和扩展包,以及内核模块 安装VirtualBox1$ sudo pacman -S virtualbox 安装VirtualBox扩展包1$ sudo pacman -S virtualbox-ext-oracle 安装内核模块1$ sudo pacman -S linux56-virtualbox-host-modules Note: 安装内核模块,一定要和系统内核是一致的版本.不然可能无法启动. 载入vboxdr模块 重启系统模块会自动载入. 手动使用命令载入1$ sudo modprobe vboxdrv 如果是其他衍生系统,大致安装步骤也和这个差不多.如果是初学者,注意包管理器的不同哦.🤞🤞🤞 完成这些,就可以在Linux下面愉快的玩耍啦.🎊🎊🎊","link":"/2020/08/14/Linux%E5%AE%89%E8%A3%85VirtualBox/"},{"title":"永别ActiveWindowControl","text":"当初刚刚接触Ubuntu的时候,我就很喜欢Unity桌面的全局菜单整合功能,🎊可以把窗口标题和全局菜单整合为一体.这样就可以节省一行显示标题的空间. 可是后来,Ubuntu放弃啦Unity桌面,搞了Gnome桌面.👎当初,其他衍生版搞Gnome桌面,他特立独行搞Unity现在有放弃.这是我不喜欢Ubuntu的其中原因之一. 后来,在我的老电脑上,我已经转入了Arch魔教.我是非常喜欢Arch的包管理器.这是非常Amazing.🤪 不过,现在在我的新电脑(Lenovo 小新13 Pro)已经使用Manjaro一段时间,Manjaro是基于Arch开发的,Arch的一些优势基本上都有.主要还是安装系统过程中,简便啦很多. 我使用的KDE桌面,是已经预装了全局菜单.不过还是不能实现Unity桌面的风格.后来知道active Window Control 插件,可以实现这个功能, 我个人觉得这个东西不太友好,我几次配置都出现了桌面黑黑的(我也不知道是啥情况.).而且,对于Window Title显示不太好,因为Title长度不一致,所以显示就有一些问题.有强迫症的我,就能难忍受啦.😅 直到遇到了你,由psifidotos开发的applet-window系列插件🤪另外,提一下.这个位开发者处理Github issue 的速度是很快的.由于我的无知(我对系统不熟悉),在Windos title 这个仓库中Open issue .没过多久他就回复我,而且,非常友好的给出了解决我问题的方式. 如何实现Unity桌面风格需要安装如下插件,目前这些都不在AUR仓库中,需要自己下载编译安装. applet-window-title applet-window-buttons applet-window-appmenu Note: 编译过程,系统需要有cmake 和 extra-cmake-modules 环境 . 这两个可以直接安装. 安装插件安装applet-window-title 克隆仓库 1git clone https://github.com/psifidotos/applet-window-title.git 该插件使用QML编写,可以直接装入.不需要编译 安装 12cd applet-window-titleplasmapkg2 -i . 至此,安装完成🤞 安装applet-window-buttons 克隆仓库1git clone https://github.com/psifidotos/applet-window-buttons.git 编译安装12cd applet-window-buttonssh install.sh shell 脚本需要知道完成,编译和安装工作. Note: 一定要安装cmake和 extra-cmake-modules . 不然会无法编译 至此,安装完成🤞 安装applet-windows-appmenu如果,系统已经预装了,全局菜单. 这个可以不安装.我就是使用系统预装的全局菜单的😝 如果没有就看下吧!! 克隆仓库1git clone https://github.com/psifidotos/applet-window-appmenu.git 编译安装12cd applet-window-appmenush install.sh 同样,shell会搞定一切.开发者还是蛮贴心的哈~👋 到这就全部安装完成啦. 后记安装完成,就可以愉快到需要的地方.添加插件啦.","link":"/2020/08/20/%E6%B0%B8%E5%88%ABActiveWindowControl/"},{"title":"Konsole无法启动","text":"前几天，想实现打开终端自动显示系统相关信息。于是我就在修改了 Konsole Profile 的 Command 加入了一个命令。结果，konsole都打不开啦。 这就非常尴尬啦，需要改回Profile 需要先打开konsole 才行呀😝。可是，现在就是打不开。 纵然寻他千百度 打开百度已掉进黑灯瞎火处。这就是我不喜欢用百度的原因，啥都查不到。(啥都没有也敢叫百度呀！！) “一切皆文件”,这条Linux哲学。在我脑海中呈现🤔。我顿悟，我找到Konsole的配置文件，不久可以改回来啦吗？根本就不需要图形界面的Profile呀！！ Konsole profile 配置文件 所在路径 ~/.locla/share/konsole/*.profile 修改Command 项里面参数(记得保存哦) 点击Konsole图标，就可以启动成功这就ok啦 Note: 到这里Konsole 不能启动的问题就修复，下面完成我未尽的事业🤪 未尽事业🤣新建一个文件 最后是.开头的隐藏文件 这个文件用来存放，终端启动需要自动执行的命令1$ touch .neofetchShow 写入命令 把需要自动执行的命令，写入到文件中1$ echo 'neofetch' &gt;&gt; .neofetchShow neofetch 命令需要自己安装 修改shell配置文件 默认shell 的配置文件为～/.bashrc zsh配置文件为~/.zshrc 将文件路径写入配置文件1source ~/.neofetchShow 保存配置文件 Note: 以上上操作都在home目录下完成，如果配置失败了，请核对路径和需要启动的命令时候可以执行","link":"/2020/08/30/Konsole%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8/"}],"tags":[{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"排序","link":"/tags/%E6%8E%92%E5%BA%8F/"},{"name":"Arch","slug":"Arch","link":"/tags/Arch/"},{"name":"Manjaro","slug":"Manjaro","link":"/tags/Manjaro/"},{"name":"代理","slug":"代理","link":"/tags/%E4%BB%A3%E7%90%86/"},{"name":"人脸识别","slug":"人脸识别","link":"/tags/%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/"},{"name":"Shell","slug":"Shell","link":"/tags/Shell/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"编程语言","slug":"编程语言","link":"/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"脚本","slug":"脚本","link":"/tags/%E8%84%9A%E6%9C%AC/"},{"name":"学习方法","slug":"学习方法","link":"/tags/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"},{"name":"备考方法","slug":"备考方法","link":"/tags/%E5%A4%87%E8%80%83%E6%96%B9%E6%B3%95/"},{"name":"自学方法","slug":"自学方法","link":"/tags/%E8%87%AA%E5%AD%A6%E6%96%B9%E6%B3%95/"}],"categories":[{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"脚本","slug":"脚本","link":"/categories/%E8%84%9A%E6%9C%AC/"},{"name":"Linux之路","slug":"Linux之路","link":"/categories/Linux%E4%B9%8B%E8%B7%AF/"},{"name":"Python","slug":"Python","link":"/categories/Python/"},{"name":"日常","slug":"日常","link":"/categories/%E6%97%A5%E5%B8%B8/"}]}