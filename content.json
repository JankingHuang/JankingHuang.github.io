{"pages":[],"posts":[{"title":"生成随机数组","text":"好久没有写代码，最近这几天把Blog迁移完成啦！！也从Windows切换到了Manjaro 今后几天打算重温一下以前的算法，自从上次程序设计大赛后。感觉自己也没认真学习过多的算法啦。今天就开个头吧，在不温习一下C++,就忘的差不多了！！！ 生成指定范围的随机数在有些编译器中，需要加入头文件ctime就可以调用time()函数, Note: 需要注意rangeL，和rangeR的范围123456789int* generateRandomArray(int rangeL,int rangeR,int n){ int *arr = new int[n]; srand(time(NULL)); for(int i = 0; i &lt; n; i++){ arr[i] = rand() % (rangeR - rangeL ) + rangeL; } return arr;} 采用模板函数进行打印1234567template&lt;typename T&gt;void printArray(T arr[], int n){ for(int i = 0; i &lt; n; i++){ cout &lt;&lt; arr[i]&lt;&lt;\" \"; } cout &lt;&lt; endl;} 随机数的生成，主要是用于排序过程中生成模拟数据。","link":"/2020/07/09/%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%BB%84/"},{"title":"测试排序性能","text":"今天尝试了VScode中Code Runner插件，尽然可以多文件运行。 以前我都一直觉得需要cmake才行，只不过Code Runner这个需要main.cpp文件中点击运行才行，如果是在头文件点击运行，会把头文件直接进行编译😿。于是，我就把整个排序辅助相关函数，写到了不同的文件中，采用不同的命名空间。 判断是否有序代码是从小到打排序 12345678template &lt;typename T&gt; bool isSorted(T arr[], int n) { for (int i = 0; i &lt; n - 1; i++) if (arr[i] &gt; arr[i + 1]) return false; return true; } 性能测试获取系统时钟，计算排序的耗时长短，单位为秒。采用啦assert函数，进行中断，有些编译器需要包含头文件。P不过，编写的时候也没有包含，不过编译提示我啦。Linux 好评👍 123456789101112template &lt;typename T&gt;void testSort(string sortName, void (*sort)(T[], int), T arr[], int n){ clock_t startTime = clock(); sort(arr, n); clock_t endTime = clock(); assert(isSorted(arr, n)); cout &lt;&lt; sortName &lt;&lt; \":\" &lt;&lt; double(endTime - startTime) / CLOCKS_PER_SEC &lt;&lt; \" S\" &lt;&lt; endl; return;} 排序辅助空间在头文件中实现，并创建啦SortTestHelper命名空间。在main函数中变可以直接调用。对于过多的实现，不推荐把实现代码写在头文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#ifndef SORTTESTHELPER_H#define SORTTESTHELPER_H#include &lt;iostream&gt;#include &lt;cassert&gt;using namespace std;namespace SortTestHelper{ int *generateRandomArray(int rangeL, int rangeR, int n) { int *arr = new int[n]; srand(time(NULL)); for (int i = 0; i &lt; n; i++) { arr[i] = rand() % (rangeR - rangeL) + rangeL; } return arr; } template &lt;typename T&gt; void printArray(T arr[], int n) { for (int i = 0; i &lt; n; i++) { cout &lt;&lt; arr[i] &lt;&lt; \" \"; } cout &lt;&lt; endl; } template &lt;typename T&gt; bool isSorted(T arr[], int n) { for (int i = 0; i &lt; n - 1; i++) if (arr[i] &gt; arr[i + 1]) return false; return true; } template &lt;typename T&gt; void testSort(string sortName, void (*sort)(T[], int), T arr[], int n) { clock_t startTime = clock(); sort(arr, n); clock_t endTime = clock(); assert(isSorted(arr, n)); cout &lt;&lt; sortName &lt;&lt; \":\" &lt;&lt; double(endTime - startTime) / CLOCKS_PER_SEC &lt;&lt; \" S\" &lt;&lt; endl; return; }} // namespace SortTestHelper#endif 排序空间也写在啦头文件中 😄,采用的是Sort这个命名空间。后期所有的排序算法都写在这个命名空间下面。 👍（自我安慰一下 🍮）第一算法是选择排序，时间复杂度是O(n^2)整个排序思维比较简单，我就不多说了 🦎 🦎 123456789101112131415161718192021#ifndef SORT_H#define SORT_H#include &lt;iostream&gt;#include &lt;cassert&gt;using namespace std;namespace Sort{ void selectionSort(int arr[], int n) { for (int i = 0; i &lt; n; i++) { int minIndex = i; for (int j = i + 1; j &lt; n; j++) if (arr[j] &lt; arr[minIndex]) minIndex = j; swap(arr[i], arr[minIndex]); } }} // namespace Sort#endif 调用🤽‍♀ 到啦这里是不是amazing丫调用就是如此简单，不太推荐使用using namespace std;(我还是这么写啦 😄)这种方式声明命名空间，会污染命名空间 12345678910111213#include &lt;iostream&gt;#include \"SortTestHelper.h\"#include \"Sort.h\"using namespace std;int main(){ int n = 100; int *arr = SortTestHelper::generateRandomArray(1,n,n); SortTestHelper::testSort(\"Selection sort\",Sort::selectionSort,arr,n); SortTestHelper::printArray(arr,n); return 0;}","link":"/2020/07/10/%E6%8E%92%E5%BA%8F%E8%BE%85%E5%8A%A9/"}],"tags":[{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"排序","link":"/tags/%E6%8E%92%E5%BA%8F/"}],"categories":[{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"}]}