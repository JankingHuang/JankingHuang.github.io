{"pages":[{"title":"about","text":"","link":"/about/index.html"}],"posts":[{"title":"生成随机数组","text":"好久没有写代码，最近这几天把Blog迁移完成啦！！也从Windows切换到了Manjaro 今后几天打算重温一下以前的算法，自从上次程序设计大赛后。感觉自己也没认真学习过多的算法啦。今天就开个头吧，在不温习一下C++,就忘的差不多了！！！ 生成指定范围的随机数在有些编译器中，需要加入头文件ctime就可以调用time()函数, Note: 需要注意rangeL，和rangeR的范围123456789int* generateRandomArray(int rangeL,int rangeR,int n){ int *arr = new int[n]; srand(time(NULL)); for(int i = 0; i &lt; n; i++){ arr[i] = rand() % (rangeR - rangeL ) + rangeL; } return arr;} 采用模板函数进行打印1234567template&lt;typename T&gt;void printArray(T arr[], int n){ for(int i = 0; i &lt; n; i++){ cout &lt;&lt; arr[i]&lt;&lt;\" \"; } cout &lt;&lt; endl;} 随机数的生成，主要是用于排序过程中生成模拟数据。","link":"/2020/07/09/%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%BB%84/"},{"title":"测试排序性能","text":"今天尝试了VScode中Code Runner插件，尽然可以多文件运行。 以前我都一直觉得需要cmake才行，只不过Code Runner这个需要main.cpp文件中点击运行才行，如果是在头文件点击运行，会把头文件直接进行编译😿。于是，我就把整个排序辅助相关函数，写到了不同的文件中，采用不同的命名空间。 判断是否有序代码是从小到打排序 12345678template &lt;typename T&gt; bool isSorted(T arr[], int n) { for (int i = 0; i &lt; n - 1; i++) if (arr[i] &gt; arr[i + 1]) return false; return true; } 性能测试获取系统时钟，计算排序的耗时长短，单位为秒。采用啦assert函数，进行中断，有些编译器需要包含头文件。P不过，编写的时候也没有包含，不过编译提示我啦。Linux 好评👍 123456789101112template &lt;typename T&gt;void testSort(string sortName, void (*sort)(T[], int), T arr[], int n){ clock_t startTime = clock(); sort(arr, n); clock_t endTime = clock(); assert(isSorted(arr, n)); cout &lt;&lt; sortName &lt;&lt; \":\" &lt;&lt; double(endTime - startTime) / CLOCKS_PER_SEC &lt;&lt; \" S\" &lt;&lt; endl; return;} 排序辅助空间在头文件中实现，并创建啦SortTestHelper命名空间。在main函数中变可以直接调用。对于过多的实现，不推荐把实现代码写在头文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#ifndef SORTTESTHELPER_H#define SORTTESTHELPER_H#include &lt;iostream&gt;#include &lt;cassert&gt;using namespace std;namespace SortTestHelper{ int *generateRandomArray(int rangeL, int rangeR, int n) { int *arr = new int[n]; srand(time(NULL)); for (int i = 0; i &lt; n; i++) { arr[i] = rand() % (rangeR - rangeL) + rangeL; } return arr; } template &lt;typename T&gt; void printArray(T arr[], int n) { for (int i = 0; i &lt; n; i++) { cout &lt;&lt; arr[i] &lt;&lt; \" \"; } cout &lt;&lt; endl; } template &lt;typename T&gt; bool isSorted(T arr[], int n) { for (int i = 0; i &lt; n - 1; i++) if (arr[i] &gt; arr[i + 1]) return false; return true; } template &lt;typename T&gt; void testSort(string sortName, void (*sort)(T[], int), T arr[], int n) { clock_t startTime = clock(); sort(arr, n); clock_t endTime = clock(); assert(isSorted(arr, n)); cout &lt;&lt; sortName &lt;&lt; \":\" &lt;&lt; double(endTime - startTime) / CLOCKS_PER_SEC &lt;&lt; \" S\" &lt;&lt; endl; return; }} // namespace SortTestHelper#endif 排序空间也写在啦头文件中 😄,采用的是Sort这个命名空间。后期所有的排序算法都写在这个命名空间下面。 👍（自我安慰一下 🍮）第一算法是选择排序，时间复杂度是O(n^2)整个排序思维比较简单，我就不多说了 🦎 🦎 123456789101112131415161718192021#ifndef SORT_H#define SORT_H#include &lt;iostream&gt;#include &lt;cassert&gt;using namespace std;namespace Sort{ void selectionSort(int arr[], int n) { for (int i = 0; i &lt; n; i++) { int minIndex = i; for (int j = i + 1; j &lt; n; j++) if (arr[j] &lt; arr[minIndex]) minIndex = j; swap(arr[i], arr[minIndex]); } }} // namespace Sort#endif 调用🤽‍♀ 到啦这里是不是amazing丫调用就是如此简单，不太推荐使用using namespace std;(我还是这么写啦 😄)这种方式声明命名空间，会污染命名空间 12345678910111213#include &lt;iostream&gt;#include \"SortTestHelper.h\"#include \"Sort.h\"using namespace std;int main(){ int n = 100; int *arr = SortTestHelper::generateRandomArray(1,n,n); SortTestHelper::testSort(\"Selection sort\",Sort::selectionSort,arr,n); SortTestHelper::printArray(arr,n); return 0;}","link":"/2020/07/10/%E6%8E%92%E5%BA%8F%E8%BE%85%E5%8A%A9/"},{"title":"初次遇见，Howdy","text":"自从上次双11，剁手买来Lenovo 小新 Pro 13 电脑后，我就天天想着安装Arch Linux系统 😄，可以是刚好临近毕业。毕业文档要用word写，我也很无奈，毕竟Linux 中对word支持不是很好 👎。 就在前不久，我入手啦Arch的儿子。就是Manjaro(基于arch开发)，我终于体会到啦，安装系统过程的简便性。(好评 👍 👍)。但是我的Windows Hello功能就废了。 初识Howdy不久就我逛Github的时候就发现这个仓库，这就令我非常Amazing呀。对于Arch 派，一条命令就能安装。 1yay -S howdy arch派就是这么简单，欢迎加入 🇯🇴不过重点不在这里，因为国内网络的问题(我也不想多说，懂的自然懂 ☕️)下载一个包特别慢，我就尝试啦proxychains。结果yay不支持 😢 YAY 重造查了老半天发现，需要重新编译yay才行。下面直接开干吧！ 👷 安装gcc-go需要使用gcc-go 重新编译 1yay -S gcc-go 克隆yay源码并编译这里就使用git 123git clone https://aur.archlinux.org/yay.gitcd yaymakepkg -si 克隆proxychains-ng 并编译最后一条命令可以不执行，懂得都懂 😏 123456git clone https://github.com/rofl0r/proxychains-ng.gitcd proxychains-ng./configuremake &amp;&amp; make installcp ./src/proxychains.conf /etc/proxychains.confcd .. &amp;&amp; rm -rf proxychains-ng 配置proxychains路径为/etc/proxychains.conf使用vim修改配置文件 1vim /etc/proxychains.conf 将 1socks4 127.0.0.1 9095 改为 1socks5 127.0.0.1 1080 端口有可能有差异，与代理软件设定的端口一致就可以。到这里yay就重新编译完成啦。 Howdy安装在需要使用代理的命令上加上 proxychains4 1proxychains4 yay -S howdy 到这里就结束啦，howdy的具体配置在Arch wiki都有。而且非常的详细，我就不多说啦！！！","link":"/2020/07/11/%E5%88%9D%E6%AC%A1%E9%81%87%E8%A7%81%EF%BC%8CHowdy/"},{"title":"Shell之路","text":"这是Shell脚本的第一遍博客，为啥要写呢？？ ❓当然，我最近在学shell脚本啦，那为啥要学呢？正所谓，学习是一种人生的追求……（装不下去啦 😼） 其实学习Shell脚本，是为了简化一些需要大量重复的工作。 🙆‍♂ 闲言少叙。Let’s go！！！！ 什么是Shell脚本Shell脚本（英语：Shell script），又称Shell命令稿、程序化脚本，是一种电脑程序使用的文本文件，内容由一连串的shell命令组成，经由Unix Shell直译其内容后运作。被当成是一种脚本语言来设计，其运作方式与解释型语言相当，由Unix shell扮演命令行解释器的角色，在读取shell脚本之后，依序运行其中的shell命令，之后输出结果。利用shell脚本可以进行系统管理，文件操作等。（WIkipedia 就是这么解释的 😄） Shell脚本基本内容第一行，#!开头就是自定解释器，这里使用/usr/bin/sh 做解释器。其他的后面会说 💁‍♂ 12345#!/usr/bin/shcd ~/Desktopfor ((i=0; i&lt;100; i++)); do mkdir 换回windows吧_$idone 查看解释器该命令可以查看系统，已经安装了那些脚本解释器。 1$ cat /etc/shells 变量变量这个东西，是非常基础的。基础到我不想多说 :smile: 定义变量显式直接赋值12i=0str=\"Hello J\" 间接赋值通过另一个输出，输入到变量中 1234567891011for file in `ls /etec` # ls /etc 输出的结果，输入到变量 file中``` ##### Note: 变量名和等号之间不能有空格,单个#开头是注释### 使用变量这就很简单啦 😸在变量面前加一个美元符号就可以。果然只要给钱啥都简单～～～```Bashecho $file # echo 输出语句echo ${file} # 等价上面，花括号可选 Note: 花括号是为了标定变量边界重定义变量这就有点，不符合我以往的编程经验啦～已定义的变量，可以被重新定义 12345i=0echo &amp;ii=12echo &amp;i 字符串这个东西经常用到 😼，可以使用单引号或双引号 单引号1string='i am j' 单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的 单引号字串中不能出现单引号（对单引号使用转义符后也不行） 双引号12j=1string=&quot;I am Janking \\&quot;$j&quot;! \\n&quot; 双引号里可以有变量 双引号里可以出现转义字符 获取长度12string=\"abcdef\"echo ${#string} #输出 6 提取子串12string=\"linux is a great OS\"echo ${string:0:4} #输出：linux 今天就到这里吧，finger crossed!!","link":"/2020/07/14/Shell%E8%84%9A%E6%9C%AC%E4%B9%8B%E5%8F%98%E9%87%8F/"}],"tags":[{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"排序","link":"/tags/%E6%8E%92%E5%BA%8F/"},{"name":"Arch","slug":"Arch","link":"/tags/Arch/"},{"name":"Manjaro","slug":"Manjaro","link":"/tags/Manjaro/"},{"name":"代理","slug":"代理","link":"/tags/%E4%BB%A3%E7%90%86/"},{"name":"人脸识别","slug":"人脸识别","link":"/tags/%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/"},{"name":"Shell","slug":"Shell","link":"/tags/Shell/"}],"categories":[{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"Manjaro &amp; Arch","slug":"Manjaro-Arch","link":"/categories/Manjaro-Arch/"},{"name":"脚本","slug":"脚本","link":"/categories/%E8%84%9A%E6%9C%AC/"}]}