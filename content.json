{"pages":[{"title":"缩影","text":"Emulator与主机软件Socket通信 YesPlayMusic 网易云第三方播放器","link":"/about/index.html"}],"posts":[{"title":"1207.独一无二的出现次数","text":"今天，把个人博客的主题换了一个。没有以前那么好看了。但是访问速度提升了不少。以后，有时间的话。我还是打算美化一下，但是毕竟我不是搞前端的，个人博客对我而言就是拿来发发个人感想，记录个人生活的。废话到这里🧑‍🔬，看题目吧～～～ 描述给你一个整数数组 arr，请你帮忙统计数组中每个数的出现次数。 如果每个数的出现次数都是独一无二的，就返回 true；否则返回 false。 示例 输入：arr = [1,2,2,1,1,3] 输出：true 解释：在该数组中，1 出现了 3 次，2 出现了 2 次，3 只出现了 1 次。没有两个数的出现次数相同。 解题思路 我看到这个题目，就想到了前一天，类似于桶排序的思路。后面看到给出的数据范围，-1000&lt;= arr[i] &lt;= 1000，我就意识到了直接使用桶排序的思维是解决不了的(数组下标不能为负数)。😅 思考一会后，我想到了STL里面的Map（键值对的方式存储数据）。这里的键是一个泛型(这就可以解决直接使用数组，下标不能为负数的情况)，接着在使用桶排序的思想，对map里面的值进行统计。再判断统计数据的值是否大于1,如果大于一这出现了重复次数的数字。🎊🎊🎊🎊🎊(撒花，掌声) 时间复杂度约为O(3n),其实一般成为O(n);空间复杂度约为O(2n),也可以称作O(n)。 代码如下： 12345678910111213141516171819202122232425262728class Solution{public: bool uniqueOccurrences(vector&lt;int&gt; &amp;arr) { map&lt;int, int&gt; m; for (int i : arr) { m[i]++; } int aux[1000] = {0}; for (auto i : m) { aux[i.second]++; } for (int i = 0; i &lt; arr.size(); i++) { if (aux[i] &gt; 1) { return false; } } return true; }}; 更优解法无独有偶，在题目的评论区也有一个很有意思的解法。👋👋作者是使用了STL库中的Map 和 Set。(当初我也有这想法，只是我对STL库不是用了解，看来需要好好学习STL库呀) 代码如下： 1234567891011121314class Solution {public: bool uniqueOccurrences(vector&lt;int&gt;&amp; arr) { unordered_map&lt;int,int&gt;m; for(int i=0;i&lt;arr.size();++i) { m[arr[i]]++; } set&lt;int&gt;times; for(auto p:m) times.insert(p.second); return times.size()==m.size(); }}; 这段代码的帅气程度快要赶上我了（不要脸）🤞🤞🤞🎊🎊🎊","link":"/2020/10/28/1207-%E7%8B%AC%E4%B8%80%E6%97%A0%E4%BA%8C%E7%9A%84%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0/"},{"title":"381.O(1)插入删除和获取随机元","text":"我用了半天的时间，与上帝交换，只为换回你💝！我午睡醒来，打开我的电脑。发现一块黑屏，只有一个鼠标，和左边的dock栏上的白色。该来的总会来，这件事情还是发生！！ 我的系统桌面KDE，终于不能用了。我花时间，把KDE换成了DDE(Deepin Desktop Environment)。我也不知道什么原因，竟然不是很好用。有几个应用打不开，主要还是不适应DDE的风格。我就又换回了KDE，安装过程倒是有些崎岖 。不过路边的风景也很美。 描述设计一个支持在平均 时间复杂度 O(1) 下， 执行以下操作的数据结构。 注意: 允许出现重复元素。 insert(val)：向集合中插入元素 val。remove(val)：当 val 存在时，从集合中移除一个 val。getRandom：从现有集合中随机获取一个元素。每个元素被返回的概率应该与其在集合中的数量呈线性相关。 示例 // 初始化一个空的集合。 RandomizedCollection collection = new &gt; &gt; &gt; &gt; RandomizedCollection(); // 向集合中插入 1 。返回 true 表示集合不包含 1 。 collection.insert(1); // 向集合中插入另一个 1 。返回 false 表示集合包含 1 。集合现在包含 [1,1] 。collection.insert(1); // 向集合中插入 2 ，返回 true 。集合现在包含 [1,1,2] 。 collection.insert(2); // getRandom 应当有 2/3 的概率返回 1 ，1/3 的概率返回 2 。 collection.getRandom(); // 从集合中删除 1 ，返回 true 。集合现在包含 [1,2] 。 collection.remove(1); // getRandom 应有相同概率返回 1 和 2 。 collection.getRandom(); 解题思路 我的第一思路，还是用桶排序的方法，把需要插入的元素，插入到数组中。即array[val]++; （val为插入的元素）。遮掩插入和取出的时间复杂度都是O(1)，但是题目没有给出val的取值范围。如果动态变化数组，当val值大于array.size()时，需要移动数组，时间复杂度为O(n)。这显然有违背题目。😅 当我查看官方解法时，我发现我在STL上的盲区(昨天说学，可是没学)。 官方解法的思路是哈希表(C++中没有，需要自己实现。使用Map 和 Set就可以实现)。 代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041class RandomizedCollection {public: unordered_map&lt;int, unordered_set&lt;int&gt;&gt; idx; vector&lt;int&gt; nums; /** Initialize your data structure here. */ RandomizedCollection() { } /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */ bool insert(int val) { nums.push_back(val); idx[val].insert(nums.size() - 1); return idx[val].size() == 1; } /** Removes a value from the collection. Returns true if the collection contained the specified element. */ bool remove(int val) { if (idx.find(val) == idx.end()) { return false; } int i = *(idx[val].begin()); nums[i] = nums.back(); idx[val].erase(i); idx[nums[i]].erase(nums.size() - 1); if (i &lt; nums.size() - 1) { idx[nums[i]].insert(i); } if (idx[val].size() == 0) { idx.erase(val); } nums.pop_back(); return true; } /** Get a random element from the collection. */ int getRandom() { return nums[rand() % nums.size()]; }}; 更优解法 这里涉及到我知识盲区😭😭😭，我就不写最优解法了。后期补上！！ 万圣节快乐，这是令人难忘的一天。","link":"/2020/10/31/381-%E6%8F%92%E5%85%A5%E5%88%A0%E9%99%A4%E5%92%8C%E8%8E%B7%E5%8F%96%E9%9A%8F%E6%9C%BA%E5%85%83/"},{"title":"1365.有多少小于当前数字的数字","text":"有几个月没有写博客，这段时间都是在刷leetcode去啦。今天刷完，才想起来我还有博客。🙃开启每日一题吧！ 加油🦤🦤🦤 描述给你一个数组 nums，对于其中每个元素 nums[i]，请你统计数组中比它小的所有数字的数目。换而言之，对于每个 nums[i] 你必须计算出有效的 j 的数量，其中 j 满足 j != i 且 nums[j] &lt; nums[i] 。以数组形式返回答案。 示例 输入：nums = [8,1,2,2,3] 输出：[4,0,1,1,3] 解释： 对于 nums[0]=8 存在四个比它小的数字：（1，2，2 和 3）。 对于 nums[1]=1 不存在比它小的数字。 对于 nums[2]=2 存在一个比它小的数字：（1）。 对于 nums[3]=2 存在一个比它小的数字：（1）。 对于 nums[4]=3 存在三个比它小的数字：（1，2 和 2）。 解题思路 第一想法，是对整个nums数组进行排序.nums[i]的元素就会有i个比它小的元素(包含重复的，不符合题意要求，去要出去重复的)。但是，后来仔细一看题目。发现，这样会打破输入数组的序列。 第二想法，是通过两个索引遍历整个数组。即每个元素和其他元素做比较，如果nums[i] &gt; nums[j]，则计数加一。比较完成后再存入结果数组中。 时间复杂度是O(n^2),空间复杂度为O(n); 代码如下：12345678910111213141516171819202122class Solution{public: vector&lt;int&gt; smallerNumbersThanCurrent(vector&lt;int&gt; &amp;nums) { vector&lt;int&gt; res; for (int i = 0; i &lt; nums.size(); ++i) { int num = 0; for (int j = 0; j &lt; nums.size(); ++j) { if (nums.at(i) &gt; nums.at(j)) { num++; } } res.push_back(num); } return res; }}; 更优解法当我提交完代后，我看了一下评论区。可谓是藏龙卧虎呀！！ 整个代码设计的非常巧妙,采用类似于桶排序的思路 先生成最大数组的大小的长度(题目给出了测试数据集的范围) 然后，对整个nums数组进行计数 在计算第i个元素，前i个的数量(arr 数组元素越靠后，对应nums里的元素越大) 在通过nums数组，获取与nums对应的元素值，存入vector。 代码如下：123456789101112131415161718192021222324class Solution {public: vector&lt;int&gt; smallerNumbersThanCurrent(vector&lt;int&gt;&amp; nums) { int arr[101]; memset(arr, 0, sizeof(arr)); // 初始化计数桶 for (auto i : nums) { arr[i] ++; } // 累加处理计数桶，使得 arr[i] 表示比 i 小的数字的个数 int cnt = 0; for (int i = 0; i &lt;= 100; i ++) { int temp = arr[i]; arr[i] = cnt; cnt += temp; } vector&lt;int&gt; ret; // 遍历 nums，取出对应桶 arr[i] 里的结果即可 for (int i : nums) { ret.push_back(arr[i]); } return ret; }}; 可以基于这个代码进行下一步的优化，但是时间复杂度大致还是O(n)级别。方法是提前结束循环。😝 今天的每日一题就到这里吧🎊","link":"/2020/10/26/1365-%E6%9C%89%E5%A4%9A%E5%B0%91%E5%B0%8F%E4%BA%8E%E5%BD%93%E5%89%8D%E6%95%B0%E5%AD%97%E7%9A%84%E6%95%B0%E5%AD%97/"},{"title":"349.两个数组的交集","text":"今天的每日一题就很简单啦。🎊今天就不废话了，直接上题目吧。 描述给定两个数组，编写一个函数来计算它们的交集。 示例 输入：nums1 = [1,2,2,1], nums2 = [2,2]输出：[2] 解题思路 最简单的方法，采用逐个比较。及nums1中的每个元素都与nums2中的每个元素进行比较，如果相等，这加入到容器中，再对容器进行去重就可以了。 代码如下123456789101112131415161718192021222324class Solution{public: vector&lt;int&gt; intersection(vector&lt;int&gt; &amp;nums1, vector&lt;int&gt; &amp;nums2) { vector&lt;int&gt; res; for (int i = 0; i &lt; nums1.size(); ++i) { for (int j = 0; j &lt; nums2.size(); ++j) { if (nums1[i] == nums2[j]) { res.push_back(nums1[i]); } } } sort(res.begin(), res.end()); vector&lt;int&gt;::iterator ite = unique(res.begin(), res.end()); res.erase(ite, res.end()); return res; }}; 更优解法 官方解法 如果两个数组是有序的，则可以使用双指针的方法得到两个数组的交集。 首先对两个数组进行排序，然后使用两个指针遍历两个数组。可以预见的是加入答案的数组的元素一定是递增的，为了保证加入元素的唯一性，我们需要额外记录变量 pre 表示上一次加入答案数组的元素。 初始时，两个指针分别指向两个数组的头部。每次比较两个指针指向的两个数组中的数字，如果两个数字不相等，则将指向较小数字的指针右移一位，如果两个数字相等，且该数字不等于 pre ，将该数字添加到答案并更新 pre 变量，同时将两个指针都右移一位。当至少有一个指针超出数组范围时，遍历结束。 今天题目就到这里吧！！ 这是我遇到比较简单的每日一题。🤪🤪🤪","link":"/2020/11/02/349-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/"},{"title":"C++资源管理(堆、栈、RAII)","text":"","link":"/2021/02/03/C-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86-%E5%A0%86%E3%80%81%E6%A0%88%E3%80%81RAII/"},{"title":"C++Lambda表达式","text":"今天的每日一题，也是比较简单的！🎊但我，查看官方题解时，我惊呆了。 我看到了如下代码： 1234567891011sort(arr.begin(), arr.end(), [&amp;](int x, int y) { if (bit[x] &lt; bit[y]) { return true; } if (bit[x] &gt; bit[y]) { return false; } return x &lt; y;}); 我看了半天，没反应过来🤣，看完评论才知道是C++11 的新特性 Lambda表达式。 Lambda表达式形式 [外部变量访问说明符](参数列表)-&gt;返回值类型{ 语句块 } 外部访问方式： =表示允许修改外部变量，&amp;不允许修改外部变量 参数列表：和普通函数一样 示例 代码：int a[4] = {11, 2, 33, 4}; sort(a, a+4, [=](int x, int y) -&gt; bool { return x%10 &lt; y%10; } ); for_each(a, a+4, [=](int x) { cout &lt;&lt; x &lt;&lt; \" \"; } ); 结果： 11 2 33 4 外部变量 “外部变量访问方式说明符”还可以有更加复杂和灵活的用法。 [=, &amp;x, &amp;y]表示外部变量 x、y 的值可以被修改，其余外部变量不能被修改； [&amp;, x, y]表示除 x、y 以外的外部变量，值都可以被修改。 Lambda表达式作用 使用 STL 时，往往会大量用到函数对象，为此要编写很多函数对象类。有的函数对象类只用来定义了一个对象，而且这个对象也只使用了一次，编写这样的函数对象类就有点浪费。 说白了，就使用便捷👋","link":"/2020/11/06/C-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"title":"463.岛屿的周长","text":"在一个岛屿上生活，是我的梦想！😝 今天，leetcode给我这个机会。计算我岛屿的长度，但是他并没有给我这个岛。 描述给定一个包含 0 和 1 的二维网格地图，其中 1 表示陆地 0 表示水域。 网格中的格子水平和垂直方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。 岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。 示例 输入: [[0,1,0,0], [1,1,1,0], [0,1,0,0], [1,1,0,0]] 输出: 16 解释: 它的周长是下面图片中的 16 个黄色的边： 解题思路 看到这题题目，我也没什么解题思路；就知道逐个去遍历，应该是可以解出来的。但是并没有清晰的编码思路。 对于一个陆地格子的每条边，它被算作岛屿的周长当且仅当这条边为网格的边界或者相邻的另一个格子为水域。 因此，我们可以遍历每个陆地格子，看其四个方向是否为边界或者水域，如果是，将这条边的贡献（即 11）加入答案 \\textit{ans}ans 中即可。（官方解题思路） 官方提供的解题思路，就是遍历每一个正方形；然后看这个正方形的周围(右，下，左，上的遍历顺序，可以改变)时候有陆地或水域，如果有水域或者是网格的边缘，那周长就加1。 总时间复杂度为：O(4nm)=O(nm);空间复杂度：O(1)。 代码如下123456789101112131415161718192021222324252627282930class Solution{ int dx[4] = {0, 1, 0, -1}; int dy[4] = {1, 0, -1, 0};public: int islandPerimeter(vector&lt;vector&lt;int&gt;&gt; &amp;grid) { int ans = 0; for (int i = 0; i &lt; grid.size(); ++i) { for (int j = 0; j &lt; grid[0].size(); ++j) { if (grid[i][j]) { int cnt = 0; for (int k = 0; k &lt; 4; ++k) { int tx = i + dx[k]; int ty = j + dy[k]; if (tx &lt; 0 || tx &gt;= grid.size() || ty &lt; 0 || ty &gt;= grid[0].size() || !grid[tx][ty]) cnt++; } ans += cnt; } } } return ans; }}; 更优解法这个就我点困难了(这个题目，我也是看了官方的解释才懂的🤫)，我后期补。最优解一定是有的！！ 对啦，祝大家万圣夜快乐🤪🤪🤪🤪","link":"/2020/10/30/463-%E5%B2%9B%E5%B1%BF%E7%9A%84%E5%91%A8%E9%95%BF/"},{"title":"Konsole无法启动","text":"前几天，想实现打开终端自动显示系统相关信息。于是我就在修改了 Konsole Profile 的 Command 加入了一个命令。结果，konsole都打不开啦。 这就非常尴尬啦，需要改回Profile 需要先打开konsole 才行呀😝。可是，现在就是打不开。 纵然寻他千百度 打开百度已掉进黑灯瞎火处。这就是我不喜欢用百度的原因，啥都查不到。(啥都没有也敢叫百度呀！！) “一切皆文件”,这条Linux哲学。在我脑海中呈现🤔。我顿悟，我找到Konsole的配置文件，不久可以改回来啦吗？根本就不需要图形界面的Profile呀！！ Konsole profile 配置文件 所在路径 ~/.locla/share/konsole/*.profile 修改Command 项里面参数(记得保存哦) 点击Konsole图标，就可以启动成功这就ok啦 Note: 到这里Konsole 不能启动的问题就修复，下面完成我未尽的事业🤪 未尽事业🤣新建一个文件 最后是.开头的隐藏文件 这个文件用来存放，终端启动需要自动执行的命令1$ touch .neofetchShow 写入命令 把需要自动执行的命令，写入到文件中1$ echo 'neofetch' &gt;&gt; .neofetchShow neofetch 命令需要自己安装 修改shell配置文件 默认shell 的配置文件为～/.bashrc zsh配置文件为~/.zshrc 将文件路径写入配置文件1source ~/.neofetchShow 保存配置文件 Note: 以上上操作都在home目录下完成，如果配置失败了，请核对路径和需要启动的命令时候可以执行","link":"/2020/08/30/Konsole%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8/"},{"title":"EduCoder-Java面向对象之包装类","text":"我已经忘记了，上次更新博客是什么时候🤣。电脑上也有不少的知识点碎片没有整理，也许是我比较懒。 这几天，学校出了教学事故。上了半个学期的Java Spring boot开发，才知道同学没有学过Java，。🤪我也就只能偷偷笑了，反正我也不喜欢Spring boot开发(为啥呢？？ 后期更新说明)然后，学校就把Spring boot 的课程改成了Java(网课，Spring boot 也是一直上网课)。第一节课就是配个环境，对于我Linux用户配java环境不存在的(就是这么霸气)。不过，老师提供了在Educoder上的课程安排。 我就用了几天的课余时间刷了一下Java题目，回顾一下Java语言。 包装类 在JAVA中，八大基础数据类型（int,float,double…）是不具备对象的特征的，比如基本数据类型就不能调用方法，功能简单，为了让基本数据类型也具备对象的特征，就有了JAVA包装类(Wrapper Classes)。 基础数据类型是没有属性的，也是不能调用方法的。 包装类就是：将基本数据类型包装成对象，使其具有了对象的属性和方法。这样就可以使用方法和属性了。 包装类作用 将本类型与其他类型进行转换； 将字符串与本类型及包装类型相互转换。 包装类使用方式 很简单把TA当成对象就可以了(sorry,忘了你没有对象) 代码如下:🍖 12Integer i = new Integer(100);Integer j = 100; 以上两种方式都可以。 基本数据类型转换成包装类的过程叫做装箱(boxing)。 包装类转换成基本数据类型的过程叫做拆箱(unboxing)。 代码如下：🍖 1234567int i = 10;Integer x= new Integer(i); //手动装箱Integer y = i; //自动装箱Integer j = new Integer(9);iint m = j.intValue(); //手动拆箱int n = j;//自动拆箱 装箱和拆箱可以分为手动--和自动--(autoboxing)。 这里的手动(EduCoder上是这么说的)，我并没有找到官方的说法。 官方说法🔗 AutoboxingAs any Java programmer knows, you can’t put an int (or other primitive value) into a collection. Collections can only hold object references, so you have to box primitive values into the appropriate wrapper class (which is Integer in the case of int). When you take the object out of the collection, you get the Integer that you put in; if you need an int, you must unbox the Integer using the intValue method. All of this boxing and unboxing is a pain, and clutters up your code. The autoboxing and unboxing feature automates the process, eliminating the pain and the clutter. Autoboxing 是为了简化使用Collection时，从基本类型到包转类型，使用结束后，又要从包装类型转化到基本类型的繁琐过程。 基础类型和包装类 基本类型 对应的包装类型 bye Byte short Short int Integer long Long float Float double Double char Character boolean Boolean 上图，就是两者的对应关系了。 说了一大堆，感觉没啥用呀。其实我就是为了水一期博客😝 好吧，这里是为了后面Java Collection做准备，Collection 相当于C++里面的STL,今天就到这里吧！","link":"/2020/11/27/EduCoder-Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E5%8C%85%E8%A3%85%E7%B1%BB/"},{"title":"Linux安装VirtualBox","text":"昨天，我下载好了kali镜像后.今天,反手就是一个条命令把VirtualBox安装好了,结果可想而知🤣 安装的VirtualBox可以运行,但是就是不能启动里面的虚拟系统.这就很令我发愁,本来因为是BIOS没有开启虚拟化.经过排查并不是这个原因.🤔后来才知道,需要安装对应内核版本的安装包,才行 确定Linux内核版本 安装对应内核版本的安装,需要查询但前实习使用的内核. 使用uname -r 命令即可查询12$ sudo uname -r5.6.19-2-MANJARO 表示需要安装linux内核版本为5.6 安装VirtualBox需要安装VirtualBox和扩展包,以及内核模块 安装VirtualBox1$ sudo pacman -S virtualbox 安装VirtualBox扩展包1$ sudo pacman -S virtualbox-ext-oracle 安装内核模块1$ sudo pacman -S linux56-virtualbox-host-modules Note: 安装内核模块,一定要和系统内核是一致的版本.不然可能无法启动. 载入vboxdr模块 重启系统模块会自动载入. 手动使用命令载入1$ sudo modprobe vboxdrv 如果是其他衍生系统,大致安装步骤也和这个差不多.如果是初学者,注意包管理器的不同哦.🤞🤞🤞 完成这些,就可以在Linux下面愉快的玩耍啦.🎊🎊🎊","link":"/2020/08/14/Linux%E5%AE%89%E8%A3%85VirtualBox/"},{"title":"Emulator与主机软件socket通信","text":"我已经记不清楚，有多久没有更新博客。🙈今天，我就研究了一下。Android Emulator 与 主机之间的网络通信。以前使用的方法都是然emulator 和 主机连接同一个网络。要是没有外部网络的时候呢？ 前言在Android Developer 网站看了半天，只看到了下面这个表和两个模拟器如何通信 网络地址 说明 10.0.2.1 路由器/网关地址 10.0.2.2 主机回环接口的特殊别名（即，开发计算机上的 127.0.0.1） 10.0.2.3 第一个 DNS 服务器 10.0.2.4 / 10.0.2.5 / 10.0.2.6 可选的第二个、第三个和第四个 DNS 服务器（如果有） 10.0.2.15 模拟设备网络/以太网接口 127.0.0.1 模拟设备回环接口 表来源：emulator-networking 在看了老半天文档后，我就得出一个结果。我是不是语文不好！！后来，我只能改用英文关键字进行搜索了。看到了一篇名为ADB port forwarding and reversing 。看完我就知道了，我的语文没问题。 文章来源：ADB port forwarding and reversing Android Debug Bridge(ADB) Android调试桥（adb）是一种多功能的命令行工具，可让您与设备进行通信。adb命令可促进各种设备操作，例如安装和调试应用程序，并且提供对Unix shell的访问，您可以使用Unix shell在设备上运行各种命令。它是一个客户端服务器程序，包含三个组件： 客户端，发送命令。客户端在您的开发计算机上运行。您可以通过发出adb命令从命令行终端调用客户端。 守护程序（adbd），它在设备上运行命令。守护程序在每个设备上作为后台进程运行。 服务器，用于管理客户端和守护程序之间的通信。服务器在开发计算机上作为后台进程运行。 整个过程，只会用到端口转发 端口转发（即隧道传输）是一种幕后过程，该过程是拦截前往计算机IP /端口组合的数据流量并将其重定向到其他IP和/或端口的。在目标计算机（主机）上运行的程序通常会导致重定向，但有时也可以是中间硬件组件，例如路由器，代理服务器或防火墙。 端口转发 使用forward命令设置任意端口转发，该转发将特定主机端口上的请求转发到设备上的其他端口。 12adb forward tcp:6100 tcp:7100#设置将主机端口6100转发到模拟器端口7100 使用reverse命令进行反向转发 12adb reverse tcp:3000 tcp:3001# 模拟器的端口3000重定向到计算机的端口30001 相关参数 命令 作用 forward/reverser –list list all forward socket connections forward/reverser –remove LOCAL remove specific forward socket connection forward/reverser –remove-all remove all forward socket connections 今天，就到这里。终于把这个坑给填上了🎊🎊🎊","link":"/2021/01/06/Emulator%E4%B8%8E%E4%B8%BB%E6%9C%BA%E8%BD%AF%E4%BB%B6socket%E9%80%9A%E4%BF%A1/"},{"title":"Manjaro连接隐藏WIFI","text":"今天远行，但是高铁晚点啦几分钟。我又很饿🤗。我就非常的不开心。现在我已经到达了，目的地。于是乎我开启了我的电脑，想要上上网～～～ 可是wifi是隐藏的，也就是说没有广播SSID。这对于我来说，是一个大问题。因为我以前就遇到啦这个问题，但是我利用啦曲线救国。我就直接改了路由器的设置，开启啦SSID广播。不过，这个我懒得捣腾啦。🤣 我决定好好，看看官方的Wiki了。巧了官方还针给出啦，连接隐藏wifi的方案！！！不过，填写SSID的时候需要加入单引号，才能连接成功，不然会提示SSID找不到 https://wiki.archlinux.org/index.php/NetworkManager_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87) 官方wiki都很详细，我就不多说啦。我只记录官方没有说明的一些细节部分。🤪今天就到这里吧！！","link":"/2020/07/30/Manjaro%E8%BF%9E%E6%8E%A5%E9%9A%90%E8%97%8FWIFI/"},{"title":"Linux编写C51程序","text":"近期，在读计算机程序设计艺术这个书。之前尝试和很多次，在前面章节就没有咋看懂。很多人都说这是计算机界中的圣经。有时间闲下来读一些书，对于我来说是一件比较休闲的事情。平时基本上面对电子屏幕，我不想我的世界里离不开它。所以在很多娱乐的时候，我都选择一些跟电子设备不太相关的活动。ok,近期Blog更新也会比较慢。Let’s go 🎊 今天的正题是，如何在Linux搭建开发C51的开发环境。因为我手上一直有一块C51的开发板。 安装SDCC(Small Device C Compiler) 官方介绍 SDCC is a retargettable, optimizing Standard C (ANSI C89, ISO C99, ISO C11) compiler suite that targets the Intel MCS51 based microprocessors (8031, 8032, 8051, 8052, etc.), Maxim (formerly Dallas) DS80C390 variants, Freescale (formerly Motorola) HC08 based (hc08, s08), Zilog Z80 based MCUs (z80, z180, gbz80, Rabbit 2000/3000, Rabbit 3000A, TLCS-90), Padauk (pdk14, pdk15) and STMicroelectronics STM8. Work is in progress on supporting the Padauk (pdk13), Microchip PIC16 and PIC18 targets. It can be retargeted for other microprocessors. sdcc 使用编译C51代码的。 Arch系列安装命令 1$ sudo pacman -S sdcc # 安装sdcc 其他衍生版可以查看自己的软件仓库，或者自行下载 下载地址 安装stcflash 使用Python编写，用于烧入sdcc生成的二进制文件 源码开源在Github Arch系列安装命令 1$ yay -S stcflash-git # 安装stcflash 在用户仓库中。 其他衍生版可以查看自己的软件仓库，或者自行下载。解压皆可使用。 注意： 如果需要在终端如何地方打开，需要把stcflash.py 复制到usr/bin/目录下面。 stcflash 更多使用说明 编写C51代码 需要包含&lt;mcs51/&gt;8051.h&gt;头文件。 引脚的定义为P1_0表示为P1 io 口的第一个引脚 。1234567891011121314151617#include&lt;mcs51/8051.h&gt;void delay(unsigned int t){ unsigned int a,b; for(a=t; a &gt;0;a--){ for(b=100;b&gt;0;b--); }}void main(){ while(1){ P1_0 = 0;//相当于keil c51 定义 P1^0 delay(1000); P1_0 = 1; delay(1000); }} 编译 使用sdcc进行编译,生成.ihx 文件。 编译命令。1$ sdcc main.c -o main.ihx # -o 指定文件名 如果语法正确，就能编译成功。否则请检查语法。🤞 转化 stcflash 烧入的文件是.hex。 我们需要转化.hpx 为 .hex。 转化命令1$ packihx main.ihx &gt; main.hex 写入程序 利用stcflash 向开发版烧入.hex程序。 写入命令1$ stcflash main.hex 扩展命令 命令 作用 示例 –port 指定写串口 $ stcflash --port /dev/ttyUSB1 -lowbaud 1200 指定波特率 stacflash -lowbaud 1200 更多配置信息 阅读Github 动画演示 该动画不包含sdcc和stcflash的配置过程。 仅包含代码编写、编译、转化、写入等过程。","link":"/2021/01/19/Linux%E7%BC%96%E5%86%99C51%E7%A8%8B%E5%BA%8F/"},{"title":"Linux相关网络命令","text":"搞了几天运动会，今天才意识到计算机网络的实验报告还没有写完。不过上实验课程的时候，我都把命令敲过了一篇(ping,ipconfig,arp,netstat)。这些我以前就玩过，有点无聊 今天，我在linux下面敲这些命令的时候发现有些命令找不到。😭我就查了一下🤔热爱学习的我 ping在Windows默认ping 4次。而在Linux下面需要用-c指定次数。 ipconfig可以使用ifconfig，不过有些版本的linux这个命令被取代了。需要是ip address show，就可以查看相关网络配置。 ARP地址解析协议，玩过kali局网攻击的话。就很熟悉啦！这个命令在linux下面一样没有，代替命令是ip neighbor会列出 IP 对应的MAC地址。 netstat这个命令听说linux系统自带有，不过我的linux版本没有。只有默认的ss(Socket Statistics)命令。加入-t显示IP/TCP相关的信息 一个小小的命令记录。bye～～～","link":"/2020/11/08/Linux%E7%9B%B8%E5%85%B3%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4/"},{"title":"STL容器分类","text":"C++ STL(Standard Template Library) 标准模板库，是类模板的通用集合。 STL结构STL 结构分为三类 Sequences(顺序) Vectors Lists Double-Ended Queues Container Adapters(容器适配器) Stacks Queus Priority Queues Associative Containser(关联容器) Bitsets Maps Multimaps Sets MultiSets Iterators(迭代器)在使用STL过程经常需要访问Container中的元素，Iterator是不可少的。 迭代器用于访问容器类的成员，并且可以在类似的情况下使用指针的方式。例如，可能使用迭代器逐步遍历元素。 迭代器共分为六种 input_iterator只能一次一个向前读取元素，按此顺序一个个传回元素值。 output_iteratorOutput迭代器和Input迭代器相反，其作用是将元素值一个个写入。 forward_iteratorForward迭代器是Input迭代器与Output迭代器的结合，具有Input迭代器的全部功能和Output迭代器的大部分功能。 bidirectional_iteratorBidirectional（双向）迭代器在Forward迭代器的基础上增加了回头遍历的能力。换言之，它支持递减操作符，用以一步一步的后退操作。 random_iteratorRandom Access迭代器在Bidirectional迭代器的基础上再增加随机存取能力。因此它必须提供“迭代器算数运算”（和一般指针“指针算术运算”相当）。 reverse_iterator逆向迭代器重新定义递增运算和递减运算，使其行为正好倒置。成员函数rbegin()和rend()各传回一个Reverse迭代器，和begin()和end()类似，共同定义一个半开区间。 在后续，我会从Sequences的Vectors到MultiSets逐步编写博文。加油!!","link":"/2020/11/09/STL%E5%AE%B9%E5%99%A8%E5%88%86%E7%B1%BB/"},{"title":"Shell之函数","text":"我已经有几天没有写博客啦，因为这几天成绩出来了。🤹🏼‍♂️这我又看出来了，公布成绩的耍猴过程。其实这几天，我也没有看shell脚本的知识。我最近迷上啦，看纸质的书;在阅读奥古斯丁《忏悔录》 这本书真的很有意思👋，我就不多说啦！这就开始吧！！！！！ 函数定义Shell也支持函数，Shell函数必须定义在使用前面。函数调用只需要给出函数名，不需要加入括号。函数返回值，可以显式增加return语句；如果不加，会将最后一条命令运行结果作为返回值。Shell 函数返回值只能是整数 格式1234function function_name () { list of commands [ return value ]} function 为可选关键字 示例123hello(){ echo 'hello';} 运行结果很显然，我就不多说啦🤣 返回字符串如果一定要让函数返回字符串，那么可以先定义一个变量，用来接收函数的计算结果。脚本在需要的时候访问这个变量来获得函数返回值。 示例12345function hello(){ return 'hello';}str=helloecho $str 这样就可以返回字符串啦🤔🤔🤔 函数参数Shell 调用函数时可以向其传递参数，在函数内部，通过$n的形式获取参数 示例12345678910111213#!/bin/bashfunction sum(){ case $# in 0) echo \"no param\";; 1) echo \"1 param\";; 2) echo \"2 param\";; 3) echo \"3 param\";; *) echo \"$# params!!\";; esac}sum 1 2 3 4 变量说明 特殊变量 说明 $# 传递给函数的参数个数 $* 显示所有传递给函数的参数 $@ 与$*相同，但是略有区别，请查看Shell特殊变量 $? 函数的返回值 获取函数返回值1234567#!/bin/bashfunction sum(){ echo 1}echo $(sum) 这就可以获取到函数的返回值啦，是不是非常Amagzing🧖🏻 shell脚本结合Linux一些命名，在使用过程中是非常便捷的。如果需要批连创建文件，或者进行软件的编译安装。都可以通过shell脚本进行操作。","link":"/2020/07/20/Shell%E4%B9%8B%E5%87%BD%E6%95%B0/"},{"title":"List和Tuple","text":"之前写了，学习了基本数据类型。今天就该学习List了 List（列表）List是Python 内置的一种数据类型。他是一种有序的集合，可以随时添加和删除其中的元素 创建列表1name = ['Linux','arch','kernel','manjaro'] 列表元素不一定是相同的元素。 使用print可以直接打印。 访问元素 通过索引来访问1print(name[2]) 通过方括号的形式来截取列表中的元素1print(name[0:2]) #左闭右开 左索引缺省为01print(name[:2]) 右索引缺省为列表最后一个1print(name[1:]) 更新元素对索引直接赋值，就可以 1name[2]='archkernel' 添加元素使用append()方法来添加 1name.append('ubuntu') #元素添加到列表末尾 删除元素使用del语句来删除列表的元素 1del name[2] #删除位置的以后索引的元素自动先前填充 List运算符 Python 表达式 结果 描述 len([1, 2, 3]) 3 计算元素个数 [1, 2, 3] + [4, 5, 6] [1, 2, 3, 4, 5, 6] 组合 [‘Hi!’] * 4 [‘Hi!’, ‘Hi!’, ‘Hi!’, ‘Hi!’] 复制 3 in [1, 2, 3] True 元素是否存在于列表中 for x in [1, 2, 3]: print x, 1 2 3 迭代 List函数 函数 描述 max(list) 返回列表元素最大值 min(list) 返回列表元素最小值 list(seq) 将元组转换为列表 list.append(obj) 在列表末尾添加新的对象 list.count(obj) 统计某个元素在列表中出现的次数 list.extend(seq) 在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表） list.index(obj) 从列表中找出某个值第一个匹配项的索引位置” list.insert(index, obj) 将对象插入列表 list.pop(obj=list[-1]) 移除列表中的一个元素（默认最后一个元素），并且返回该元素的值 list.remove(obj) 移除列表中的一个元素（参数是列表中元素），并且不返回任何值} list.reverse() 反向列表中元素 list.sort([func]) 对原列表进行排序 Tuple (元组)tuple一旦初始化就不能修改。 创建元组1tuple=('Linux','arch','kernel','manjaro') 创建空元组 1tuple=() Note: 创建元组中只包含一个元素时，需要在元素后面添加逗号。避免产生歧义。 访问元组访问方式和List一样👋 修改元组可以对元组进行连接组合，而打到修改元组内容的🤗。 123456list1=[123,456]tuple1=('两点水','twowater','liangdianshui',list1)print(tuple1)list1[0]=789list1[1]=100print(tuple1) 这样就可通过修改List，而达到修改Tuple的目的。 Note: Tuple一开始指向list，修改list的内容，并没有改变别指向。 删除元组与List一致，使用del语句。但是不能单独删除单个元素，因为不可变。 1del tuple 元组运算符元组之间可以使用 + 号和 * 号进行运算。这就意味着他们可以组合和复制，运算后会生成一个新的元组。 Python表达式 结果 描述 len((1, 2, 3)) 3 计算元素个数 (1, 2, 3) + (4, 5, 6) (1, 2, 3, 4, 5, 6) 连接 (‘Hi!’,) * 4 (‘Hi!’, ‘Hi!’, ‘Hi!’, ‘Hi!’) 复制 3 in (1, 2, 3) True 元素是否存在 for x in (1, 2, 3): print(x) 1 2 3 迭代 元组内置函数 方法 描述 len(tuple) 计算元组元素个数 max(tuple) 返回元组中元素最大值 min(tuple) 返回元组中元素最小值 tuple(seq) 将列表转换为元组","link":"/2020/08/02/List%E5%92%8CTuple/"},{"title":"Shell之变量","text":"这是Shell脚本的第一遍博客，为啥要写呢？？ ❓当然，我最近在学shell脚本啦，那为啥要学呢？正所谓，学习是一种人生的追求……（装不下去啦 😼） 其实学习Shell脚本，是为了简化一些需要大量重复的工作。 🙆‍♂ 闲言少叙。Let’s go！！！！ 什么是Shell脚本Shell脚本（英语：Shell script），又称Shell命令稿、程序化脚本，是一种电脑程序使用的文本文件，内容由一连串的shell命令组成，经由Unix Shell直译其内容后运作。被当成是一种脚本语言来设计，其运作方式与解释型语言相当，由Unix shell扮演命令行解释器的角色，在读取shell脚本之后，依序运行其中的shell命令，之后输出结果。利用shell脚本可以进行系统管理，文件操作等。（WIkipedia 就是这么解释的 😄） Shell脚本基本内容第一行，#!开头就是自定解释器，这里使用/usr/bin/sh 做解释器。其他的后面会说 💁‍♂ 12345#!/usr/bin/shcd ~/Desktopfor ((i=0; i&lt;100; i++)); do mkdir 换回windows吧_$idone 查看解释器该命令可以查看系统，已经安装了那些脚本解释器。 1$ cat /etc/shells 变量变量这个东西，是非常基础的。基础到我不想多说 :smile: 定义变量显式直接赋值12i=0str=\"Hello J\" 间接赋值通过另一个输出，输入到变量中 12345678910111213for file in `ls /etec` # ls /etc 输出的结果，输入到变量 file中``` ##### Note: 变量名和等号之间不能有空格,单个#开头是注释### 使用变量这就很简单啦 😸在变量面前加一个美元符号就可以。果然只要给钱啥都简单～～～```Bashecho $file # echo 输出语句echo ${file} # 等价上面，花括号可选 Note: 花括号是为了标定变量边界重定义变量这就有点，不符合我以往的编程经验啦～已定义的变量，可以被重新定义 12345i=0echo &amp;ii=12echo &amp;i 字符串这个东西经常用到 😼，可以使用单引号或双引号 单引号1string='i am j' 单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的 单引号字串中不能出现单引号（对单引号使用转义符后也不行） 双引号12j=1string=&quot;I am Janking \\&quot;$j&quot;! \\n&quot; 双引号里可以有变量 双引号里可以出现转义字符 获取长度12string=\"abcdef\"echo ${#string} #输出 6 提取子串12string=\"linux is a great OS\"echo ${string:0:4} #输出：linux 今天就到这里吧，finger crossed!!","link":"/2020/07/14/Shell%E8%84%9A%E6%9C%AC%E4%B9%8B%E5%8F%98%E9%87%8F/"},{"title":"Python之基本数据类型","text":"我回来啦！！ 回到我的家乡🎊今天拿到啦毕业证书，没想到里面还有一张优秀毕业设计证书🤣可是好简陋，我一脸嫌弃😏 闲言少叙，下面就开写进入Python的世界吧～～～🐍 字符串字符串英文 string ，是 python 中随处可见的数据类型。 字符串的识别也非常的简单，就是用「引号」括起来的引号包括单引号 ‘ ‘ ，双引号 “ “ 和 三引号 ‘’’ ‘’’ ，比如 ‘abc’ ，”123” 等等。 Note: 为啥有这么多引号呢？ 一个不行吗？🤔原因其实很简单 单引号： 引用的字符串中不能有单引号「·用双引号」 双引号： 引用的字符串中不能有双引号「·用三引号」 其实这里可以直接转义字符比如单引号，你可以使用 \\‘ 来表示，双引号可以使用 \\“ 来表示。 示例123print('Hello Python')print(\"Hllo 'Python'\")print('''Hello \"Python\"''') 运行结果 123Hello PythonHllo 'Python'Hello \"Python\" 整数整数英文为 integer 。这里不多说,和C非常相似。我们直接看代码🤪 示例123456789int1 = 1int2 = 100int3 = -100int4 = 1 / 2print(int1)print(int2)print(int3)print(int4) 运行结果： 12341100-1000.5 Note： 1／２ 会得到０.5 int4会自动提升为float类型。 １//2 才会得到０Python运算符＋ 、- 、* 我就不列举啦，太简单和日常一样 运算符 表示 说明 ／ 除 １／２ 输出结果０.５ ％ 取模 5%2 输出结果１ ** 幂 2**3 为２的３次方 // 取整 11//2 输出结果 ５ 浮点数浮点数的英文名是 float ，是指带小数的数字。对浮点数的表达本身是不精确的。保存在计算机中的是二进制数，二进制对有些数字不能准确表达，只能非常接近这个数。 示例123print(0.55+0.41)print(0.55+0.4)print(0.55+0.411) 运行结果: 1230.960.95000000000000010.9610000000000001 #####Note: 浮点数不能准确表达，对浮点数做运算和比较大小的时候要小心。 布尔值一个布尔值只有True、False两种值「注意大写开头」🤫布尔值可以用and、or、not运算。 and 运算是与运算，只有所有都为 True，and 运算结果才是 True。 or 运算是或运算，只要其中有一个为 True，or 运算结果就是 True。 not 运算是非运算，它是一个单目运算符，把 True 变成 False，False 变成 True。 这里很多语言都是一致的🤫,其实就是布尔代数🙃 空值Python 使用Node「开头大写」来表示 编码问题 我们都知道计算机只能处理数字，如果要处理文本，就必须先把文本转换为数字才能处理。最早的计算机在设计时采用8个比特（bit）作为一个字节（byte），所以，一个字节能表示的最大的整数就是255（二进制11111111=十进制255），0 - 255被用来表示大小写英文字母、数字和一些符号，这个编码表被称为ASCII编码，比如大写字母 A 的编码是 65，小写字母 z 的编码是 122。 如果要表示中文，显然一个字节是不够的，至少需要两个字节，而且还不能和 ASCII 编码冲突，所以，中国制定了 GB2312 编码，用来把中文编进去。类似的，日文和韩文等其他语言也有这个问题。为了统一所有文字的编码，Unicode 应运而生。 Unicode 把所有语言都统一到一套编码里，这样就不会再有乱码问题了。Unicode 通常用两个字节表示一个字符，原有的英文编码从单字节变成双字节，只需要把高字节全部填为 0 就可以。 因为 Python 的诞生比 Unicode 标准发布的时间还要早，所以最早的Python 只支持 ASCII 编码，普通的字符串 ‘ABC’ 在 Python 内部都是 ASCII 编码的。&gt;Python 在后来添加了对 Unicode 的支持，以 Unicode 表示的字符串用u’…’表示。不过在最新的 Python 3 版本中，字符串是以 Unicode 编码的，也就是说，Python 的字符串支持多语言。就像上面的例子一样，我的代码中没有加u’…’，也能正常显示。 不过由于 Python 源代码也是一个文本文件，所以，当你的源代码中包含中文的时候，在保存源代码时，就需要务必指定保存为 UTF-8 编码。当Python 解释器读取源代码时，为了让它按 UTF-8 编码读取，我们通常在文件开头写上这两行： 12#!/usr/bin/env python3 # -*- coding: utf-8 -*- 第一行注释是为了告诉 Linux/OS X 系统，这是一个 Python 可执行程序，Windows 系统会忽略这个注释；第二行注释是为了告诉 Python 解释器，按照 UTF-8 编码读取源代码，否则，你在源代码中写的中文输出可能会有乱码。 申明了 UTF-8 编码并不意味着你的 .py 文件就是 UTF-8 编码的，必须并且要确保文本编辑器正在使用 UTF-8 without BOM 编码 今天就先到这里吧～～ 加油，加油🧑‍🔬","link":"/2020/07/27/Python%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"title":"Shell之处理命名参数","text":"今天练习了一下shell脚本，之前简单的学习啦shell脚本的语法。😅刷了HackerRank的题目以后，发现还是不能很好的驾驭shell这把神剑。 于是，我决定闭关修炼😝修炼过程中，我发现啦很多武林绝学🌻。令我感到非常的Amazing。下面就来看看吧！！！ 示例12345678910111213deploy=falseuglify=falsewhile(( $# &gt; 1 ));do case $1 in --deploy) deploy=\"$2\";; --uglify) uglify=\"$2\";; *) break; esac; shift 2done$deploy &amp;&amp; echo \"will deploy... deploy = $deploy\"$uglify &amp;&amp; echo \"will uglify... uglify = $uglify\" Note: 最后两行，与&amp;&amp;的运算方式有关 $# 参数个数运行方式1bash script.sh --deploy true --uglify false true 和fasle 为输入值特殊变量 变量 含义 $0 当前脚本的文件名 $n 传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例 $# 传递给脚本或函数的参数个数。 $* 传递给脚本或函数的所有参数。 $@ 传递给脚本或函数的所有参数。被双引号(“ “)包含时，与 $* 稍有不同 $? 上个命令的退出状态，或函数的返回值。 $$ 当前Shell进程ID。对于 Shell 脚本，就是这些脚本所在的进程ID。 $@和$*的区别 不被双引号(“ “)包含时，都以”$1” “$2” … “$n” 的形式输出所有参数。 被双引号(“ “)包含时， “$*” 会将所有的参数作为一个整体，以”$1 $2 … $n”的形式输出所有参数； “$@” 会将各个参数分开，以”$1” “$2” … “$n” 的形式输出所有参数(带换行输出)。 示例1234567891011121314151617181920212223echo \"print each param from \\$*\"for var in $*do echo \"$var\"doneecho \"print each param from \\$@\"for var in $@do echo \"$var\"doneecho \"print each param from \\\"\\$*\\\"\"for var in \"$*\"do echo \"$var\"doneecho \"print each param from \\\"\\$@\\\"\"for var in \"$@\"do echo \"$var\"done 今天，就先到这里吧!!","link":"/2020/08/09/Shell%E4%B9%8B%E5%A4%84%E7%90%86%E5%91%BD%E5%90%8D%E5%8F%82%E6%95%B0/"},{"title":"Linux使用QQ与微信","text":"对于一般Linux用户，QQ，微信。是经常需要使用的东西。🙃不过对于我这种，神一般的Linux用户而言。QQ啥的就不是很需要啦。🤣“有事给我发电子邮件”，这是我常说的。 QQ的确用的很少，但还是要记录一下QQ、微信安装和配置的！！ QQ for Linux这是首选Linux 下面的QQ解决方案。这个东西，在愚人节过后更新啦，我也是很佩服。但是依旧是秦始皇年代的界面风格🤪这个QQ毕竟可以流畅的使用，虽然有时崩溃。### 安装安装方式都是很简单，官方都有。如果Arch ,Manjaro 就使用下面这条命令 1sudo pacman -S qq-linux https://im.qq.com/linuxqq/index.html Deepin-QQ与Deepin-Wechat需要完整的QQ、Wechat体验，可以安装Deepin应用，在Manjaro中，由于有AUR源、Archlinuxcn源的加持，安装过程是非常方便的。安装微信，只需在AUR中找到并安装deepin-wine-wechat；安装QQ，只需在AUR中找到并安装deepin-wine-tim或者deepin-wine-qq即可。安装软件包后，打开软件，按照提示完成进一步的安装配置之后就可使用。 安装TIM1yay -S deepin-wine-tim QQ1yay -S deepin-wine-qq wechat1yay -S deepin-wine-wechat DPI安装完成后，会发现字体比较小，使用 12WINEPREFIX=~/.deepinwine/Deepin-QQ deepin-wine winecfg #修改QQ的DPIWINEPREFIX=~/.deepinwine/Deepin-TIM deepin-wine winecfg #修改TIM的DPI 则可以调整DPI了对于微信，可以使用网页版，也可以去Github下载高手封装好了的网页版微信，就不用打开浏览器登入微信啦 无法显示图片聊天图片与头像无法显示，或者始终处于加载中，是因为QQ的图片解析与ipv6不兼容，需要关闭ipv6。在终端使用 123sudo sysctl -w net.ipv6.conf.all.disable_ipv6=1sudo sysctl -w net.ipv6.conf.default.disable_ipv6=1sudo sysctl -w net.ipv6.conf.lo.disable_ipv6=1 Note：以上命令在深度Deepin Linux系统下有效，其他Linux发行版可参考。我也没测试。我的安装好就能用🤣","link":"/2020/07/21/%E4%BD%BF%E7%94%A8QQ%E4%B8%8E%E5%BE%AE%E4%BF%A1/"},{"title":"Shell之语句","text":"昨天我….陪小朋友👦打球🏀去啦，就没有写🤣。不过，有个人告诉我，TA看了我的博客(开心😃)今天就直接开始吧 if语句格式1234if [ expression ]then Statement(s) to be executed if expression is truefi Note: expression和方括号([ ])之间必须有空格，否则会有语法错误。形式有三种形式 123if ... fi 语句if ... else ... fi 语句if ... elif ... else ... fi 语句 示例12345678910111213#!/us/bin/sha=10b=10c=12if [ $a == $b ]then trans -sp \"a等于b\"elif [ $a == $c ]then trans -sp \"a等于c\"else trans -sp \"用会Windows吧\"fi 示例很简单，就不多罗嗦啦🤫 case语句M为需要匹配的东西，*) 其他没有匹配则执行 格式12345case $var in M) Statement；; M) Statement;; *) Statement;;esac Note 取值后面必须为关键字 in. 每一模式必须以右括号结束。 取值可以为变量或常数。 匹配发现取值符合某一模式后，其间所有命令开始执行直至 ;;。;; 与其他语言中的 break 类似，意思是跳到整个 case 语句的最后。 示例1234567#!/us/bin/sha=10case $a in 10) trans -sp \"a等于b\";; 12) trans -sp \"a等于c\";; *) trans -sp \"用会Windows吧\";;esac for语句格式1234567for var in rangedo Statement1 Statement2 ... StatementNdone range 为循环范围，如果学过Python的话，这里和python很类似。🙈 示例12345#!/us/bin/shfor value in 5 4 3 2 1 do trans -sp \"用会Windows吧${value}\"done while语句格式1234while [ expression ]do Statement(s) to be executed if expression is truedone 示例1234567#!/us/bin/shc=0;a=0;while [ $a == $c ]do echo $cdone 会一直在终端输出0,小心哦🙃 until 语句until 循环执行一系列命令直至条件为 true 时停止。until 循环与 while 循环在处理方式上刚好相反。一般while循环优于until使用。 格式1234until [ expression ]do Statement(s) to be executed if expression is falsedone 示例1234567#!/us/bin/shc=0;a=1;until [ $a == $c ]do echo $cdone 这个东西和wile好相似哦。这个脚本也会一直在终端输出。 跳出循环break,continue 和c语言使用类似 breakbreak 命令跳出最外层循环。🤹🏼‍♂️ 示例1234567891011#!/us/bin/shc=0;a=0;b=0;while [ $c == $a ]do if [ $b == $a ] then break fidone 在嵌套循环中，break 命令后面还可以跟一个整数，表示跳出第几层循环 1break n continuecontinue 终止该次循环，继续下一次。👷 示例123456789#!/us/bin/shfor a in 1 2 3 4 5do if [ $a == 2 ] then continue fi echo $adone 不会输出2 ～～～～～～～～～～～～The End ~ 哈哈哈哈，如果我是一只企鹅🐧，我就会非常努力学习游泳，游到北极去和北极熊🐨玩耍！！！","link":"/2020/07/16/Shell%E8%84%9A%E6%9C%AC%E4%B9%8B%E8%AF%AD%E5%8F%A5/"},{"title":"qBittorrent下载加速","text":"Linux 下面如何下载Bittorrent的资源呢🤔🤔？？如果是在Windows下面,迅雷🐦一般是第一选择． 今天，我试图下载Kali Linux 镜像的时候，发现官方提供了，BitTorrent下载方式．我就打算在我的Linux 下面尝试一下．结果下载速度非常快😝 安装qBittorrentqBittorrent是一个跨平台的自由BitTorrent客户端，其图形用户界面是由Qt所写成的． 下载链接：https://www.qbittorrent.org/download.php 等待下载完成后，就可以安装啦． Arch系列如果是Arch Linux ，或者是基于Arch Linux 的系统 1sudo pacman -S qbittorrent 可以使用上述命令直接安装． 加入Tracker 服务器Tracker服务器，主要目的是为了，提升下载速度. 由于tracker对BT下载起到客户端协调和调控的重要作用，所以一旦被封锁会严重影响BT下载，如2009年12月，中华人民共和国广电总局对BTchina一系列的tracker进行打击，因此也促使新BT客户端支持DHT网络实现无中心tracker，分布式资源分享的影响需要了解更多Tracker服务器，可以自行搜索． qBittorrent 添加tracker服务器添加tracker服务器 点击Preferences 找到Bittorent选项 勾选 automatically add thes trackers to new downloads 选项 粘贴tracker服务器列表，即可点击apply Note: qBittorrent添加完成tracker服务器后需要，重新启动软件． tracker服务器列表 Best Tracker list: https://trackerslist.com/best.txt All Tracker list: https://trackerslist.com/all.txt Http(s) Tracker list: https://trackerslist.com/http.txt 这些是我日程使用的Tracker服务器列表，这个仓库列表，已有人发布到github仓库中．这里我就不给出仓库连接了，在我的收藏的仓库中可以找到😝 关于Bittorent 就分享到这里吧，DHT的中文全称是分布式哈希表(distributed has table 的缩写)，这可以避免中心tracker服务器的不能工作而导致这个系统的瘫痪．是一些天才的杰作．","link":"/2020/08/13/qBittorrent%E4%B8%8B%E8%BD%BD%E5%8A%A0%E9%80%9F/"},{"title":"基本排序算法","text":"半个月没写博客了，两个星期前结束了HMTL课程。然后就考完试了，终于不用上这么无聊的课程了。博客有时间还是要坚持写的，今天就开始吧。 今天就来看看，下面这些基本算法吧！ Selection-Sort 选择排序。 时间复杂度O(n^2)、空间复杂度O(1)。 采用双重遍历，内层遍历没次寻找[i,n)区间里的最小值然后，与第i个元素进行交换( [0,i) 区间为有序序列)。 图解如下： 代码如下：123456789101112void selectionSort(int arr[], int n){ for(int i = 0 ; i &lt; n ; i ++){ // 寻找[i, n)区间里的最小值 int minIndex = i; for( int j = i + 1 ; j &lt; n ; j ++ ) if( arr[j] &lt; arr[minIndex] ) minIndex = j; swap( arr[i] , arr[minIndex] ); }} Insertion-Sort 插入排序。 时间复杂度O(n^2)、空间复杂度O(1); 采用双重遍历，单独看最左边的原始为有序(任意一个单独的元素都为有序序列)。选择该元素的下一元素，插入到前面的有序序列中，是该序列依旧有序。 图解如下： 代码如下：12345678910111213void insertionSort(T arr[], int n){ for( int i = 1 ; i &lt; n ; i ++ ) { // 寻找元素arr[i]合适的插入位置 //[0,i-1)区间为有序序列，[i-1,n) 为待遍历序列。 for( int j = i ; j &gt; 0 ; j-- ) if( arr[j] &lt; arr[j-1] ) swap( arr[j] , arr[j-1] ); else break; }} Bubble-Sort 冒泡排序 (这个好熟悉呀) 时间复杂度O(n^2)、空间复杂度O(1); 采用双重遍历，每次内层需要寻找最大的元素，使该元素沉到数组尾部(有序序列的最前面)。 图解如下： 代码如下：123456789void Bubble(vector&lt;int&gt;&amp; nums){ int sum = 0; for(int i = 0; i &lt; nums.size() - 1; ++i) for(int j = 0; j &lt; nums.size() - 1 ; ++j) if(nums[j] &gt; nums[j + 1]) swap(nums[j],nums[j+1]); } Shell-Sort 希尔排序 (日常见的比较少)。 时间复杂度O(n^1.3) 空间复杂度O(1)。 希尔排序又称缩小增量排序，基于插入排序。基本思想是划分多组分别进行插入排序。 图解如下： 代码如下:123456789101112131415161718void sort(vector&lt;int&gt; arr){ //增量gap，并逐步缩小增量 for (int gap = arr.size() / 2; gap &gt; 0; gap /= 2) { //从第gap个元素，逐个对其所在组进行直接插入排序操作 for (int i = gap; i &lt; arr.size(); i++) { int j = i; while (j - gap &gt;= 0 &amp;&amp; arr[j] &lt; arr[j - gap]) { //插入排序采用交换法 swap(arr, j, j - gap); j -= gap; } } }} 基本排序算法时间复杂度基本都是O(n^2)，shell-sort时间复杂度度也达不到O(n)。🙄 今天就到这里吧～～～ bye.💝","link":"/2020/11/22/%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"title":"初次遇见，Howdy","text":"自从上次双11，剁手买来Lenovo 小新 Pro 13 电脑后，我就天天想着安装Arch Linux系统 😄，可以是刚好临近毕业。毕业文档要用word写，我也很无奈，毕竟Linux 中对word支持不是很好 👎。 就在前不久，我入手啦Arch的儿子。就是Manjaro(基于arch开发)，我终于体会到啦，安装系统过程的简便性。(好评 👍 👍)。但是我的Windows Hello功能就废了。 初识Howdy不久就我逛Github的时候就发现这个仓库，这就令我非常Amazing呀。对于Arch 派，一条命令就能安装。 1yay -S howdy arch派就是这么简单，欢迎加入 🇯🇴不过重点不在这里，因为国内网络的问题(我也不想多说，懂的自然懂 ☕️)下载一个包特别慢，我就尝试啦proxychains。结果yay不支持 😢 YAY 重造查了老半天发现，需要重新编译yay才行。下面直接开干吧！ 👷 安装gcc-go需要使用gcc-go 重新编译 1yay -S gcc-go 克隆yay源码并编译这里就使用git 123git clone https://aur.archlinux.org/yay.gitcd yaymakepkg -si 克隆proxychains-ng 并编译最后一条命令可以不执行，懂得都懂 😏 123456git clone https://github.com/rofl0r/proxychains-ng.gitcd proxychains-ng./configuremake &amp;&amp; make installcp ./src/proxychains.conf /etc/proxychains.confcd .. &amp;&amp; rm -rf proxychains-ng 配置proxychains路径为/etc/proxychains.conf使用vim修改配置文件 1vim /etc/proxychains.conf 将 1socks4 127.0.0.1 9095 改为 1socks5 127.0.0.1 1080 端口有可能有差异，与代理软件设定的端口一致就可以。到这里yay就重新编译完成啦。 Howdy安装在需要使用代理的命令上加上 proxychains4 1proxychains4 yay -S howdy 到这里就结束啦，howdy的具体配置在Arch wiki都有。而且非常的详细，我就不多说啦！！！","link":"/2020/07/11/%E5%88%9D%E6%AC%A1%E9%81%87%E8%A7%81%EF%BC%8CHowdy/"},{"title":"我的Linux桌面环境","text":"今天，我是来填坑的。前段时间挖了这个坑，今天就把它填上。 这篇Blog是我与Linux的爱恨情仇后续之作。 我的Linxu软件开发文档查看工具 Zeal 安装方式 123$ sudo pacman -S zeal#如果打不开，提示是Qt的相关问题#可以去github下载源代码，然后编译就可以用了 代码仓库 https://github.com/zealdocs/zeal 软件界面 桌面程序开发 Qt,KDE就是使用Qt开发的，我越来越喜欢Qt了。 安装方式1$ sudo pacman -S qtcreator 软件界面 团队沟通工具 我用过很多，就目前而言国内的都不好用。 Microsoft Teams(非常好用，除了网络问题) 安装方式123$ sudo pacman -S teams-insiders#软件仓库中，就是有insider版。#官方网站可以下载正式版的 软件界面 录屏推流软件我为了用Linux开会，也是愁死我了。最后，只能使用OBS进行推流共享屏幕了。 OBS Studio 安装方式1$ sudo pacman -S obs-studio 软件界面 RSS订阅软件这软件我是找了好久，以前还打算自己用Qt写一个。这是我每天基本都是打开的软件。 Akregator 安装方式1$ sudo pacman -S akregator 软件界面 远程控制软件我也是听我朋友说，才知道TeamViewer有全平台版本，就是目前功能不全。 TeamViewer 安装方式1$ sudo pacman -S teamviewer 软件界面 资源下载我以前写过一篇qBittorrent的博客 qBittorrent enhanced editors (增强版，会自动更新tracker服务器列表) Github https://github.com/c0re100/qBittorrent-Enhanced-Edition 软件界面 网络仿真 我在计算机网络实验课程，用来做实验的。 Cisco Packet Tracer 安装命令1$ sudo pacman -S packettracer 软件界面 这个故事就到这里吧🎊🎊🎊 Linux没有你想的那么好，但也没有你想的那么差。","link":"/2020/11/27/%E6%88%91%E7%9A%84Linux%E6%A1%8C%E9%9D%A2%E7%8E%AF%E5%A2%83/"},{"title":"我与Linux的爱恨情仇","text":"我与你第一次相遇，是在2016年。那个时候作为电脑小白的我，带着好奇心把你安装到了我电脑上，那个时候你叫Ubuntu16.04。💝 安装完成后，我失去是我的磁盘原有的所有数据🤔。我当时以为，你的安装方式和Windows是一样的。谁能想到你独吞我整个硬盘，使用你不到一天的时间，我就把Windows给重新安装上了。🤣 我与Linux爱恨后来，和你的见面方式都是在VMware里面了；你就没有单独存在于我的物理机里面。在VMware里面，我尝试过很多的Linux系统。有CentOS、Redhat、Fedora；真正第一次认真敲入命令是在CentOS里面。那个时候，跟着教程一步一步的敲入命令。刚刚开始的时候，还经常敲错。😭 2018年，我遇到到一个IDE(Android Studio)，体会到什么叫编码两分钟，编译两小时(其实是自己电脑太卡，联想G400)的感觉。每当我有空闲时间的时候，我都会打开浏览器。看看有没有什么可以优化编译的方法，的确通过修改Android Studio的一些配置可以加快编译。但是作用不是很大。🙄，还看到了很多关于Linux对硬件性能低的博客。 我的Linux时代2018年的冬天，我就在我的物理机里面安装Fedora系统。当时我还在我的VMware里面体验过，感觉不错。可是，在实际中出现了几个问题。 使用的人比较少，出了问题比较难解决。 我在安装51编译库的时候，发现编译工具的名称尽然不同。(当时想骂人) 对于国内用户QQ是非常重要的，Fedora安装QQ是比较困难的。 用了不到一个星期。我就从Fedora，步入了Arch魔教的阵营(现在我新买的电脑上用Manjaro(基于arch开发的))。 从2018年到现在，我已经习惯了Linux的简洁和高效。对于Linux，我喜欢一下几点 一切皆文件 拥有Root，拥有一切 一条命令，安装需要的软件。(next..next..next 不存在的) 我可以任意修改所有文件，达到我想要的效果。 我可以任意改动我的桌面布局，不需要安装任何额外的软件。 我可以切换不同的桌面环境。 我的Linux软件下面说说，我日常使用哪些软件。 浏览器 Google Chrome (刚刚从chromuim切换过来) 安装方式1$ sudo pacman -S google-chrome 软件界面 编程工具Android 开发 Android Studio 安装方式1$ sudo pacman -S android-studio 软件界面 Java开发 IntelliJ idea 社区版 安装方式1$ sudo pacman -S intellij-idea-community-edition 软件界面 C++开发 Visual Studio Code 这个编辑器结合插件非常好用，我写博客也是用这个 安装方式1$ sudo pacman -S visual-stduio-code-bin 软件界面 虚拟机VirtualBox 安装方式，看我以前写的如何安装Virtualbox的博客VMware（需要激活） 安装方式1$ sudo pacman -S vmware-workstation 这个两个我都使用过，目前在使用vmware 软件界面 通讯QQ 使用deepin的wine运行的TIM 安装方式1$ sudo pacman -S deepin.com.qq.office 软件界面 Evolution 这是一个电子邮箱客户端(主要用来给老师和学委发作业之类的) 安装方式1$ sudo pacman -S evolution 软件界面 AUR 助手工具 用来安装AUR(Arch User Repository)仓库的软件 安装方式1$ sudo pacman -S yay 软件界面 音乐 落雪音乐助手，一款开源软件 安装方式,需要自己下载.pacman的包，然后安装1$ sudo pacman -U *.pacman 直接下载Appimage后缀的，可以自己运行。 软件界面 office替代品 Micosoft office 的良好替代品 安装方式1$ sudo pacman -S wps-office 软件界面今天就分享到这里吧，有些软件后续补上。🎊🎊 希望，你也加入Linux","link":"/2020/11/02/%E6%88%91%E7%9A%84Linux/"},{"title":"测试排序性能","text":"今天尝试了VScode中Code Runner插件，尽然可以多文件运行。 以前我都一直觉得需要cmake才行，只不过Code Runner这个需要main.cpp文件中点击运行才行，如果是在头文件点击运行，会把头文件直接进行编译😿。于是，我就把整个排序辅助相关函数，写到了不同的文件中，采用不同的命名空间。 判断是否有序代码是从小到打排序 12345678template &lt;typename T&gt; bool isSorted(T arr[], int n) { for (int i = 0; i &lt; n - 1; i++) if (arr[i] &gt; arr[i + 1]) return false; return true; } 性能测试获取系统时钟，计算排序的耗时长短，单位为秒。采用啦assert函数，进行中断，有些编译器需要包含头文件。P不过，编写的时候也没有包含，不过编译提示我啦。Linux 好评👍 123456789101112template &lt;typename T&gt;void testSort(string sortName, void (*sort)(T[], int), T arr[], int n){ clock_t startTime = clock(); sort(arr, n); clock_t endTime = clock(); assert(isSorted(arr, n)); cout &lt;&lt; sortName &lt;&lt; \":\" &lt;&lt; double(endTime - startTime) / CLOCKS_PER_SEC &lt;&lt; \" S\" &lt;&lt; endl; return;} 排序辅助空间在头文件中实现，并创建啦SortTestHelper命名空间。在main函数中变可以直接调用。对于过多的实现，不推荐把实现代码写在头文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#ifndef SORTTESTHELPER_H#define SORTTESTHELPER_H#include &lt;iostream&gt;#include &lt;cassert&gt;using namespace std;namespace SortTestHelper{ int *generateRandomArray(int rangeL, int rangeR, int n) { int *arr = new int[n]; srand(time(NULL)); for (int i = 0; i &lt; n; i++) { arr[i] = rand() % (rangeR - rangeL) + rangeL; } return arr; } template &lt;typename T&gt; void printArray(T arr[], int n) { for (int i = 0; i &lt; n; i++) { cout &lt;&lt; arr[i] &lt;&lt; \" \"; } cout &lt;&lt; endl; } template &lt;typename T&gt; bool isSorted(T arr[], int n) { for (int i = 0; i &lt; n - 1; i++) if (arr[i] &gt; arr[i + 1]) return false; return true; } template &lt;typename T&gt; void testSort(string sortName, void (*sort)(T[], int), T arr[], int n) { clock_t startTime = clock(); sort(arr, n); clock_t endTime = clock(); assert(isSorted(arr, n)); cout &lt;&lt; sortName &lt;&lt; \":\" &lt;&lt; double(endTime - startTime) / CLOCKS_PER_SEC &lt;&lt; \" S\" &lt;&lt; endl; return; }} // namespace SortTestHelper#endif 排序空间也写在啦头文件中 😄,采用的是Sort这个命名空间。后期所有的排序算法都写在这个命名空间下面。 👍（自我安慰一下 🍮）第一算法是选择排序，时间复杂度是O(n^2)整个排序思维比较简单，我就不多说了 🦎 🦎 123456789101112131415161718192021#ifndef SORT_H#define SORT_H#include &lt;iostream&gt;#include &lt;cassert&gt;using namespace std;namespace Sort{ void selectionSort(int arr[], int n) { for (int i = 0; i &lt; n; i++) { int minIndex = i; for (int j = i + 1; j &lt; n; j++) if (arr[j] &lt; arr[minIndex]) minIndex = j; swap(arr[i], arr[minIndex]); } }} // namespace Sort#endif 调用🤽‍♀ 到啦这里是不是amazing丫调用就是如此简单，不太推荐使用using namespace std;(我还是这么写啦 😄)这种方式声明命名空间，会污染命名空间 12345678910111213#include &lt;iostream&gt;#include \"SortTestHelper.h\"#include \"Sort.h\"using namespace std;int main(){ int n = 100; int *arr = SortTestHelper::generateRandomArray(1,n,n); SortTestHelper::testSort(\"Selection sort\",Sort::selectionSort,arr,n); SortTestHelper::printArray(arr,n); return 0;}","link":"/2020/07/10/%E6%8E%92%E5%BA%8F%E8%BE%85%E5%8A%A9/"},{"title":"生成随机数组","text":"好久没有写代码，最近这几天把Blog迁移完成啦！！也从Windows切换到了Manjaro 今后几天打算重温一下以前的算法，自从上次程序设计大赛后。感觉自己也没认真学习过多的算法啦。今天就开个头吧，在不温习一下C++,就忘的差不多了！！！ 生成指定范围的随机数在有些编译器中，需要加入头文件ctime就可以调用time()函数, Note: 需要注意rangeL，和rangeR的范围123456789int* generateRandomArray(int rangeL,int rangeR,int n){ int *arr = new int[n]; srand(time(NULL)); for(int i = 0; i &lt; n; i++){ arr[i] = rand() % (rangeR - rangeL ) + rangeL; } return arr;} 采用模板函数进行打印1234567template&lt;typename T&gt;void printArray(T arr[], int n){ for(int i = 0; i &lt; n; i++){ cout &lt;&lt; arr[i]&lt;&lt;\" \"; } cout &lt;&lt; endl;} 随机数的生成，主要是用于排序过程中生成模拟数据。","link":"/2020/07/09/%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%BB%84/"},{"title":"永别ActiveWindowControl","text":"当初刚刚接触Ubuntu的时候,我就很喜欢Unity桌面的全局菜单整合功能,🎊可以把窗口标题和全局菜单整合为一体.这样就可以节省一行显示标题的空间. 可是后来,Ubuntu放弃啦Unity桌面,搞了Gnome桌面.👎当初,其他衍生版搞Gnome桌面,他特立独行搞Unity现在有放弃.这是我不喜欢Ubuntu的其中原因之一. 后来,在我的老电脑上,我已经转入了Arch魔教.我是非常喜欢Arch的包管理器.这是非常Amazing.🤪 不过,现在在我的新电脑(Lenovo 小新13 Pro)已经使用Manjaro一段时间,Manjaro是基于Arch开发的,Arch的一些优势基本上都有.主要还是安装系统过程中,简便啦很多. 我使用的KDE桌面,是已经预装了全局菜单.不过还是不能实现Unity桌面的风格.后来知道active Window Control 插件,可以实现这个功能, 我个人觉得这个东西不太友好,我几次配置都出现了桌面黑黑的(我也不知道是啥情况.).而且,对于Window Title显示不太好,因为Title长度不一致,所以显示就有一些问题.有强迫症的我,就能难忍受啦.😅 直到遇到了你,由psifidotos开发的applet-window系列插件🤪另外,提一下.这个位开发者处理Github issue 的速度是很快的.由于我的无知(我对系统不熟悉),在Windos title 这个仓库中Open issue .没过多久他就回复我,而且,非常友好的给出了解决我问题的方式. 如何实现Unity桌面风格需要安装如下插件,目前这些都不在AUR仓库中,需要自己下载编译安装. applet-window-title applet-window-buttons applet-window-appmenu Note: 编译过程,系统需要有cmake 和 extra-cmake-modules 环境 . 这两个可以直接安装. 安装插件安装applet-window-title 克隆仓库 1git clone https://github.com/psifidotos/applet-window-title.git 该插件使用QML编写,可以直接装入.不需要编译 安装 12cd applet-window-titleplasmapkg2 -i . 至此,安装完成🤞 安装applet-window-buttons 克隆仓库1git clone https://github.com/psifidotos/applet-window-buttons.git 编译安装12cd applet-window-buttonssh install.sh shell 脚本需要知道完成,编译和安装工作. Note: 一定要安装cmake和 extra-cmake-modules . 不然会无法编译 至此,安装完成🤞 安装applet-windows-appmenu如果,系统已经预装了,全局菜单. 这个可以不安装.我就是使用系统预装的全局菜单的😝 如果没有就看下吧!! 克隆仓库1git clone https://github.com/psifidotos/applet-window-appmenu.git 编译安装12cd applet-window-appmenush install.sh 同样,shell会搞定一切.开发者还是蛮贴心的哈~👋 到这就全部安装完成啦. 后记安装完成,就可以愉快到需要的地方.添加插件啦.","link":"/2020/08/20/%E6%B0%B8%E5%88%ABActiveWindowControl/"},{"title":"STL之Vectors","text":"Vector包含存储为数组的连续元素。访问向量的成员、添加元素可以在常数时间内完成，而查找特定值或将元素插入向量需要线性时间。 Vector 构造函数1234vector();vector( const vector&amp; c );vector( size_type num, const TYPE&amp; val = TYPE() );vector( input_iterator start, input_iterator end ); 默认构造函数没有参数，创建一个新的实例对象vector。 第二个构造函数，是默认复制构造函数，创建c的副本。 第三个构造函数，创建一个具有num大小的空间，如果指定val的值。则num空间中默认初始值为val。 最后一个构造函数，创建一个vector，并初始化值为start到end的元素值。 12345678910111213141516vector&lt;int&gt; v;for(int i = 0; i &lt; 10; i++){ v.push_back(i); } // v 包含 0,1,2,3,4,5,6,7,8,9,10; vector&lt;int&gt;::iterator iter1 = v.begin(); iter1 += 2; //iter1 指向v中值为3的元素 vector&lt;int&gt;::iterator iter2 = v.end(); iter2 -= 3; //iter2 指向v中值为7的元素 vector&lt;int&gt; a(iter1,iter2);//[iter1,iter2) 赋值给a for(auto i: a){ cout &lt;&lt; \"res out:\"&lt;&lt;i &lt;&lt; \" \"; } // res out : 2 3 4 5 6 所有这些构造函数都以线性时间运行，除了第一个以常数时间运行。 Vector 运算符重载123456789TYPE&amp; operator[]( size_type index );const TYPE&amp; operator[]( size_type index ) const;vector operator=(const vector&amp; c2);bool operator==(const vector&amp; c1, const vector&amp; c2);bool operator!=(const vector&amp; c1, const vector&amp; c2);bool operator&lt;(const vector&amp; c1, const vector&amp; c2);bool operator&gt;(const vector&amp; c1, const vector&amp; c2);bool operator&lt;=(const vector&amp; c1, const vector&amp; c2);bool operator&gt;=(const vector&amp; c1, const vector&amp; c2) const TYPE&amp; operator[] 操作是以常数时间，其他都是线性时间 Vector 函数assign12void assign( size_type num, const TYPE&amp; val );void assign( input_iterator start, input_iterator end ); 将vector 赋值为num个val; 或者vector赋值为从start到end的元素 此函数将破坏向量的先前内容。 at12TYPE&amp; at( size_type loc );const TYPE&amp; at( size_type loc ) const; 返回索引为loc的向量中元素的引用。 at()函数比[]运算符更安全，因为它不会让您引用向量的边界。 back12TYPE&amp; back();const TYPE&amp; back() const; 返回vector中最后一个元素的引用 begin12iterator begin();const_iterator begin() const; 返回一个迭代器指向vector的首个元素，常数时间。 capacity1size_type capacity() const; 返回vector的容量，然后可以通过reserve() 重新定制大小。 C ++容器旨在动态增加大小。这使程序员摆脱了不必担心在容器中存储任意数量的元素。然而，有时程序员可以通过提示来提高程序性能向编译器询问程序将使用的容器的大小。 clear1void clear(); 删除vector所有元素，常数时间。 empty1bool empty() const; 判断vector是否为空。 end1const_iterator end() const; 返回一个迭代器指向vector的追后一个元素的下一个位置。 eras12iterator erase( iterator loc );iterator erase( iterator start, iterator end ); 擦除一个元素或[start,end)个元素。返回擦除的最后一个元素。 front12TYPE&amp; front();const TYPE&amp; front() const; 返回第一元素。 insert123iterator insert( iterator loc, const TYPE&amp; val );void insert( iterator loc, size_type num, const TYPE&amp; val );void insert( iterator loc, input_iterator start, input_iterator end ); 插入val在loc之后，放回插入元素位置的迭代器。 插入num个val 在loc之后。 插入[start,end) 区间内的元素，在loc之后。 max_size1size_type max_size() const; 返回vector在更多内存的情况下，允许分配的最大值。 需要与size()和capacity()区分 pop_back1void pop_back(); 删除最后一个元素。 push_back1void push_back( const TYPE&amp; val ); 添加一个元素到vector尾部。 rbegin12reverse_iterator rbegin();const_reverse_iterator rbegin() const; 返回一个迭代器指向vector末尾的下一个元素。 rend12reverse_iterator rend();const_reverse_iterator rend() const; 返回一个迭代器指向vector第一个元素。 reserve1void reserve( size_type size ) 设置vector的容量最小大为size。 resize1void resize( size_type num, const TYPE&amp; val = TYPE() ); 改变vector的大小，如果指定val 则新增的空间初始化为val。 size1size_type size() const; 返回vector中元素的个数。 swap1void swap( container&amp; from ); 将vector的内容与from的内容进行交换，常数时间。 Vector 的介绍就先到这里吧，加油！！！","link":"/2021/02/24/STL%E4%B9%8BVectors/"},{"title":"编译原理之一","text":"今天写题目的时候遇到了有限状态机这个概念。我也不懂，查完资料后，就写个博客记录一下吧！ 编译过程的前三个阶段会进行词法分析、语法分析、语义分析。 词法分析编译器的第一项工作就是词法分析，就像阅读文章一样,文章是由一个个的文字 组成的。程序处理也一样,只是叫做词法记号,英文叫Token。 生成过程利用词法分析器可以生成分词规则,比如 Lex。 这些生成工具是基于一些规则来工作的,这些规则用正则文法表达。 生成工具可以读入正则表达式,生成一种叫有限自动机的算法,来完成具体的词法分析工作。 符合正则文法的表达式称为正则表达式。 有限自动机是有限个状态的自动机器。 拿抽水马桶举例,它分为两个状态:“注水”和“水满”。 摁下冲马桶的按钮,它转到“注水”状态,而浮球上升到一定高度,就会把注水阀门关闭,它转到“水满”状态。 语法分析这是编译器的第二项工作，词法分析是识别一个个的单词, 而语法分析就是在词法分析的基础上识别出程序的语法结构。 这个结构是一个树状结构,是计算机容易理解和执行的。 抽象语法树(AST)语法分析过程,就是构造这么一棵树。 一个程序就是一棵树,这棵树叫做抽象语法树(Abstract Syntax Tree,AST)。 树的每个节点是一个语法单元,这个单元的构成规则就叫“语法”。 这里可以生成直观的JS语法树：https://resources.jointjs.com/demos/javascript-ast 了解更多的AST相关的内容: http://icps.u-strasbg.fr/~pop/gcc-ast.html 语义分析语义分析是消除语义模糊,生成一些属性信息,让计算机能够依据这些信息生成目标代码。 某个表达式的计算结果是什么数据类型？ 如果有数据类型不匹配的情况。 如果在一个代码块的内部和外部有相同名称的变量。 语义分析工作的某些成果,会作为属性标注在抽象语法树上。 以上就是编译器的前三个阶段的过程!!!","link":"/2021/02/26/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%861/"},{"title":"计算机基本知识","text":"别问我，为啥要写这么基础的博文。我也不知道！！！ 计算机发展的四个阶段 1946 - 1957： 电子管计算机(ENIAC)，第二次世界大战是催化机。 1957-1964 ： 晶体管计算机(TX-0 ,PDP-1)，贝尔实验室的三个科学家发明了晶体管。 TX-0: 来自MIT林肯实验室 1964-1980：集成电路计算机(诞生了操作系统) ， 德州仪器的工程师发明了集成电路(IC) IBM 7094 1401 操作系统，两个系无法兼容，后来推出System/360(操作系统的雏形) 1980- ： 超大规模集成电路计算机 1TFlop/s : 每秒一万亿次浮点计算 计算机的体系与结冯诺依慢体系将程序指令和数据一起存储的计算机设计概念结构 存储程序指令，设计通用电路。 存储器、控制器、运算器、输入设备、输出设备 CPU和存储速率之间的问题无法调和，称为“冯诺依曼瓶颈” 计算机的层次 硬件逻辑层门、触发器等逻辑电路组成，属于EE的领域。 微程序机器层 编程语言是微指令集。 微指令所组成的微程序直接交由硬件执行。 传统机器层 编程语言是CPU指令集(机器指令)。 编程语言和硬件是直接相关。 不同架构的CPU使用不同的CPU指令集。 一条机器指令对应一个微程序，一个微程序对应一组微指令 操作系统层 向上提供了简易的操作界面。 向下对接了指令系统，管理硬件资源。 操作系统层是在软件和硬件之间的适配层。 汇编语言层 编程语言是汇编语言。 汇编语言可以翻译成可以直接执行的机器语言。 完成翻译的过程的程序就是汇编器。 高级语言层日常的编程语言，C/C++、Java、Golang等 应用层满足计算机针对某种用途而专门设计，office、ps 分层的目的是便于理解 计算机的计算单位 在物理成面，高低电平记录信息 理论上只认识0/1两种状态 速度单位网络速度 网络常用单位为(Mbps) 100 M/s = 100 Mbps = 100 Mbit/s = (100/8)MB/s = 12.5 MB/s CPU速度 CPU的速度一般体现为CPU的时钟频率 CPU的时钟频率的单位一般是赫兹(Hz) 主流CPU的时钟频率都是在2 GHz以上 Hz 每秒中的周期性变动重复次数的计量 字符与编码集ASCII码 使用7个bits 就可以表示 包含95个可打印字符 33个不可打印字符 很多应用或者国际中的符号都无法表示 第一次对ASCII码进行扩充，7 bits-&gt;8 bits Extended ASCII码 有常见的数学运算符 带音标的欧洲字符 其它常用、表个符等 中文编码集 GB2312(不符合国际编码) GBK(兼容GB2312 、ISO标准，支持中日韩所有文字) Unicode 统一码、万国码、单一码。 定义了世界通用的符号集，UTF-*实现了编码 UTF-8 以字节为单位对Unicode进行编码 兼容全球的字符集","link":"/2021/02/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"},{"title":"计算机存储器","text":"续输入输出设备之后，内容还是很简单！ 存储器分类 存储器的层次结构 缓存-主存层次 局部性原理(某个事件趋于聚集在一个较小的连续区域中) 在CPU与主存之间增加一层速度快(容量小)的Cache 解决主存速度不足问题 主存-辅存层次 局部性原理 在主存之外增加辅助存储器(磁盘、SD卡、U盘) 解决主存容量不足问题 主存储器（内存） RAM(随机存取存储器：Random Access Memory) RAM通过电容存储数据，必须隔一段时间刷新一次 如果掉电，那么一段时候后丢失所有数据 辅助存储器（磁盘） 磁头调度算法 先来先服务算法 最短寻道时间优先算法 扫描算法（电梯算法） 循环扫描算法","link":"/2021/03/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%98%E5%82%A8%E5%99%A8/"},{"title":"计算机输入输出设备","text":"我打算水一期，这里做一下简单的记录！ 常见的输入输出设备字符输入设备 键盘 薄膜键盘 机械键盘 电容键盘 图形输入设备 鼠标 数位板 扫描仪 图像输出设备 显示器 CRT显示器 液晶显示器 打印机 投影仪 输入输出接口的通用设计 数据线： I/O设备与主机之间进行数据交换的传送线 双向传输数据线 单向传输数据线 状态线： IO设备状态向主机报告的信号线，查询设备的状态(正常连接、就绪、占用) 命令线： CPU向设备发送命令的型号线（读写信号、启动停止信号） 设备选择线： 主机选择I/O 设备进行操作的信号线(选择指定设备进行读写) CPU与IO设备的通信程序中断 当外围IO设备就绪时，向CPU发出中断信号 CPU有专门的电路响应中断信号 提供低速设备通知CPU的一种异步的方式，CPU可以在高速运转的同时兼顾低速设备 DMA(直接存储器访问) DMA直接连接主存与IO设备 DMA工作时不需要CPU的参与 可以提高CPU效率","link":"/2021/03/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87/"},{"title":"计算机总线","text":"提供了对外连接的接口 不同设备可以通过USB(通用串行总线)接口进行连接 连接的标准、促使外围设备接口的统一 解决不同设备之间的通信问题 总线的分类 片内总线 芯片内部的总线 寄存器与寄存器之间 寄存器与控制器、运算器之间 高集成读芯片内部的信息传输 系统总线 数据总线(一般与CPU位数相同) 双向传输各个部件的数据信息 数据总线的位数（总线宽度）是数据总线的重要参数 地址总线(地址总线位数 = n, 寻址范围： 0 ～ 2^n) 制定源数据或目的数据在内存中的地址 地址总线的位数与存储单位元有关 控制总线 控制总线是用来发出各种控制信号的传输线 控制信号经由控制总线从一个组件发给另一个组件 控制总线可以监视不同组件之间的状态(就绪/未就绪) CPU、主内存、IO设备、各组件之间的信息传输线 总线的仲裁不同设备之间使用总线的优先级别。 为了解决总线使用权的冲突问题 方法链式查询 电路复杂度低、仲裁方式简单 优先级低的设备难以获得总县使用权 对电路敏感 定时查询 仲裁控制其与设备编号并使用计数器累计基数 接收到仲裁信号后，往所有设备发出计数值 计数至与设备编号一致则获得总线使用权 独立请求 每个设备均有总线独立连接仲裁器 设备可单独向仲裁器发送请求和接受请求 当同时收到多个信号，仲裁器有权按优先级别分配使用权 响应速度快、优先顺序可动态改变 设备连接，总线控制复杂","link":"/2021/02/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%80%BB%E7%BA%BF/"},{"title":"STL之Lists","text":"List 是存储在Linked list中的序列元素，与Vectors相比它能快速插入和删除元素，但是随机访问比较慢。 List 构造函数1234list();list( const list&amp; c );list( size_type num, const TYPE&amp; val = TYPE() );list( input_iterator start, input_iterator end ); 默认构造函数没有参数，创建一个新的实例化对象。 第二个是默认复制函数，创建一个新的实例对象，并初始为c中元素。 第三个是创建一个带有num个对象空间的list，如果val指定值，则初始化值为val。 任何一个list都有 默认构造、赋值构造以及析构函数。 List 运算符重载1234567list operator=(const list&amp; c2);bool operator==(const list&amp; c1, const list&amp; c2);bool operator!=(const list&amp; c1, const list&amp; c2);bool operator&lt;(const list&amp; c1, const list&amp; c2);bool operator&gt;(const list&amp; c1, const list&amp; c2);bool operator&lt;=(const list&amp; c1, const list&amp; c2);bool operator&gt;=(const list&amp; c1, const list&amp; c2); 执行比较和赋值都需要线性的时间 List 函数assign12void assign( size_type num, const TYPE&amp; val );void assign( input_iterator start, input_iterator end ); 将list 赋值为num个val; 或者list赋值为从start到end的元素 此函数将破坏list的先前内容。 back12TYPE&amp; back();const TYPE&amp; back() const; 返回list中最后一个元素的引用 begin12iterator begin();const_iterator begin() const; 返回一个迭代器指向list的首个元素，常数时间。 clear1void clear(); 删除list所有元素，常数时间。 empty1bool empty() const; 判断list是否为空。 end1const_iterator end() const; 返回一个迭代器指向list的追后一个元素的下一个位置。 eras12iterator erase( iterator loc );iterator erase( iterator start, iterator end ); 擦除一个元素或[start,end)个元素。返回擦除的最后一个元素。 front12TYPE&amp; front();const TYPE&amp; front() const; 返回第一元素。 insert123iterator insert( iterator loc, const TYPE&amp; val );void insert( iterator loc, size_type num, const TYPE&amp; val );void insert( iterator loc, input_iterator start, input_iterator end ); 插入val在loc之后，放回插入元素位置的迭代器。 插入num个val 在loc之后。 插入[start,end) 区间内的元素，在loc之后。 max_size1size_type max_size() const; 返回list在更多内存的情况下，允许分配的最大值。 需要与size()和capacity()区分 merge12void merge( list &amp;lst );void merge( list &amp;lst, BinPred compfunction ); 合并list与lst 默认以&lt;的方式合并，如果指定compfunction，则遵循compfunction的对比方式。 pop_back1void pop_back(); 删除最后一个元素。 pop_front1void pop_front() 删除第一元素 Vector 没有该函数 push_back1void push_back( const TYPE&amp; val ); 添加一个元素到list尾部。 push_front1void push_front( const TYPE&amp; val ); Vector 没有该函数 remove1void remove( const TYPE &amp;val ); 删除所有等于val的元素。 Vector 没有该函数 remove_if1void remove_if( UnPred pr ); 删除所有pr为true的元素。 Vector 没有该函数 rbegin12reverse_iterator rbegin();const_reverse_iterator rbegin() const; 返回一个迭代器指向list末尾的下一个元素。 rend12reverse_iterator rend();const_reverse_iterator rend() const; 返回一个迭代器指向list第一个元素。 reserve1void reserve( size_type size ) 设置list的容量最小大为size。 size1size_type size() const; 返回list中元素的个数。 sort12void sort();void sort( BinPred p ); 以升序的方式排序list，如果指定p这按照该方式排序。 Vector 没有该函数 splice123void splice( iterator pos, list&amp; lst );void splice( iterator pos, list&amp; lst, iterator del );void splice( iterator pos, list&amp; lst, iterator start, iterator end ); 在pos的位置插入lst，或者在插入list中的del位置的元素。抑或插入start到end中的元素。 在参数时间级别完成 Vector 没有该函数 swap1void swap( container&amp; from ); 将list的内容与from的内容进行交换，常数时间。 unique12void unique();void unique( BinPred pr ); 移除list中所有连续重复的元素，去重需要先排序。 使用==进行比较，除非指定pr。 调用后原有元素顺序不会改变。 Vector 没有该函数 Lists的就先到这里吧，Lists和Vector有很多函数都是相似的可以对比着学习 加油～～～🎉🎉🎉","link":"/2021/03/03/STL%E4%B9%8BLists/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","link":"/tags/Leetcode/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"Arch","slug":"Arch","link":"/tags/Arch/"},{"name":"Manjaro","slug":"Manjaro","link":"/tags/Manjaro/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"EduCoder","slug":"EduCoder","link":"/tags/EduCoder/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"Socket","slug":"Socket","link":"/tags/Socket/"},{"name":"TCP","slug":"TCP","link":"/tags/TCP/"},{"name":"UDP","slug":"UDP","link":"/tags/UDP/"},{"name":"Development Environment","slug":"Development-Environment","link":"/tags/Development-Environment/"},{"name":"C51","slug":"C51","link":"/tags/C51/"},{"name":"Shell","slug":"Shell","link":"/tags/Shell/"},{"name":"编程语言","slug":"编程语言","link":"/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"脚本","slug":"脚本","link":"/tags/%E8%84%9A%E6%9C%AC/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"排序","slug":"排序","link":"/tags/%E6%8E%92%E5%BA%8F/"},{"name":"代理","slug":"代理","link":"/tags/%E4%BB%A3%E7%90%86/"},{"name":"人脸识别","slug":"人脸识别","link":"/tags/%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/"},{"name":"STL","slug":"STL","link":"/tags/STL/"},{"name":"计算机基础知识","slug":"计算机基础知识","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"编译原理","slug":"编译原理","link":"/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"name":"日常知识","slug":"日常知识","link":"/tags/%E6%97%A5%E5%B8%B8%E7%9F%A5%E8%AF%86/"}],"categories":[{"name":"修炼之路","slug":"修炼之路","link":"/categories/%E4%BF%AE%E7%82%BC%E4%B9%8B%E8%B7%AF/"},{"name":"C++","slug":"C","link":"/categories/C/"},{"name":"Linux之路","slug":"Linux之路","link":"/categories/Linux%E4%B9%8B%E8%B7%AF/"},{"name":"回归之路","slug":"回归之路","link":"/categories/%E5%9B%9E%E5%BD%92%E4%B9%8B%E8%B7%AF/"},{"name":"嵌入式开发","slug":"嵌入式开发","link":"/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/"},{"name":"脚本","slug":"脚本","link":"/categories/%E8%84%9A%E6%9C%AC/"},{"name":"Python","slug":"Python","link":"/categories/Python/"},{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"编译原理","slug":"编译原理","link":"/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"name":"计算机基本知识","slug":"计算机基本知识","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/"}]}