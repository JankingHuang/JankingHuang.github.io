<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jankin&#39;s Blog</title>
  
  
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-01-06T02:52:19.995Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Jankin Huang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Emulator与主机软件socket通信</title>
    <link href="http://yoursite.com/2021/01/06/Emulator%E4%B8%8E%E4%B8%BB%E6%9C%BA%E8%BD%AF%E4%BB%B6socket%E9%80%9A%E4%BF%A1/"/>
    <id>http://yoursite.com/2021/01/06/Emulator%E4%B8%8E%E4%B8%BB%E6%9C%BA%E8%BD%AF%E4%BB%B6socket%E9%80%9A%E4%BF%A1/</id>
    <published>2021-01-06T02:20:02.000Z</published>
    <updated>2021-01-06T02:52:19.995Z</updated>
    
    <content type="html"><![CDATA[<p>我已经记不清楚，有多久没有更新博客。🙈<br>这段时间，学校终于放假。可是还不能回家,几天后几个重要的会议。<br>今天，我就研究了一下。<code>Android Emulator</code> 与 <code>主机</code>之间的网络通信。<br>以前使用的方法都是然emulator 和 主机连接同一个网络。要是没有外部网络的时候呢？</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在Android Developer 网站看了半天，只看到了下面这个<code>表</code>和<code>两个模拟器</code>如何通信</p><table><thead><tr><th>网络地址</th><th>说明</th></tr></thead><tbody><tr><td>10.0.2.1</td><td>路由器/网关地址</td></tr><tr><td>10.0.2.2</td><td>主机回环接口的特殊别名（即，开发计算机上的 127.0.0.1）</td></tr><tr><td>10.0.2.3</td><td>第一个 DNS 服务器</td></tr><tr><td>10.0.2.4 / 10.0.2.5 / 10.0.2.6</td><td>可选的第二个、第三个和第四个 DNS 服务器（如果有）</td></tr><tr><td>10.0.2.15</td><td>模拟设备网络/以太网接口</td></tr><tr><td>127.0.0.1</td><td>模拟设备回环接口</td></tr></tbody></table><p><a href="https://developer.android.com/studio/run/emulator-networking">表来源：emulator-networking</a></p><p>在看了老半天文档后，我就得出一个结果。我是不是语文不好！！<br>后来，我只能改用英文关键字进行搜索了。看到了一篇名为<code>ADB port forwarding and reversing</code> 。看完我就知道了，我的语文没问题。</p><p><a href="https://blog.usejournal.com/adb-port-forwarding-and-reversing-d2bc71835d43">文章来源：ADB port forwarding and reversing</a></p><h2 id="Android-Debug-bridge-ADB"><a href="#Android-Debug-bridge-ADB" class="headerlink" title="Android Debug bridge(ADB)"></a>Android Debug bridge(ADB)</h2><blockquote><p>Android调试桥（adb）是一种多功能的命令行工具，可让您与设备进行通信。adb命令可促进各种设备操作，例如安装和调试应用程序，并且提供对Unix shell的访问，您可以使用Unix shell在设备上运行各种命令。它是一个客户端服务器程序，包含三个组件：</p><p>客户端，发送命令。客户端在您的开发计算机上运行。您可以通过发出adb命令从命令行终端调用客户端。</p><p>守护程序（adbd），它在设备上运行命令。守护程序在每个设备上作为后台进程运行。</p><p>服务器，用于管理客户端和守护程序之间的通信。服务器在开发计算机上作为后台进程运行。</p></blockquote><p>整个过程，只会用到端口转发</p><blockquote><p>端口转发（即隧道传输）是一种幕后过程，该过程是拦截前往计算机IP /端口组合的数据流量并将其重定向到其他IP和/或端口的。在目标计算机（主机）上运行的程序通常会导致重定向，但有时也可以是中间硬件组件，例如路由器，代理服务器或防火墙。</p></blockquote><h2 id="端口转发"><a href="#端口转发" class="headerlink" title="端口转发"></a>端口转发</h2><ul><li>使用<code>forward</code>命令设置任意端口转发，该转发将特定主机端口上的请求转发到设备上的其他端口。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb forward tcp:6100 tcp:7100</span><br><span class="line"><span class="comment">#设置将主机端口6100转发到模拟器端口7100</span></span><br></pre></td></tr></table></figure></li><li>使用<code>reverse</code>命令进行反向转发<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb reverse tcp:3000 tcp:3001</span><br><span class="line"><span class="comment"># 模拟器的端口3000重定向到计算机的端口30001</span></span><br></pre></td></tr></table></figure><h2 id="相关参数"><a href="#相关参数" class="headerlink" title="相关参数"></a>相关参数</h2><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>forward/reverser –list</td><td>list all forward socket connections</td></tr><tr><td>forward/reverser –remove LOCAL</td><td>remove specific forward socket connection</td></tr><tr><td>forward/reverser –remove-all</td><td>remove all forward socket connections</td></tr></tbody></table></li></ul><p>今天，就到这里。终于把这个坑给填上了🎊🎊🎊</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我已经记不清楚，有多久没有更新博客。🙈&lt;br&gt;这段时间，学校终于放假。可是还不能回家,几天后几个重要的会议。&lt;br&gt;今天，我就研究了一下。&lt;code&gt;Android Emulator&lt;/code&gt; 与 &lt;code&gt;主机&lt;/code&gt;之间的网络通信。&lt;br&gt;以前使用的方法都是然emulator 和 主机连接同一个网络。要是没有外部网络的时候呢？&lt;/p&gt;</summary>
    
    
    
    <category term="嵌入式开发" scheme="http://yoursite.com/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
    <category term="Socket" scheme="http://yoursite.com/tags/Socket/"/>
    
    <category term="TCP" scheme="http://yoursite.com/tags/TCP/"/>
    
    <category term="UDP" scheme="http://yoursite.com/tags/UDP/"/>
    
  </entry>
  
  <entry>
    <title>我的Linux桌面环境</title>
    <link href="http://yoursite.com/2020/11/27/%E6%88%91%E7%9A%84Linux%E6%A1%8C%E9%9D%A2%E7%8E%AF%E5%A2%83/"/>
    <id>http://yoursite.com/2020/11/27/%E6%88%91%E7%9A%84Linux%E6%A1%8C%E9%9D%A2%E7%8E%AF%E5%A2%83/</id>
    <published>2020-11-27T12:17:43.000Z</published>
    <updated>2020-11-27T13:31:35.165Z</updated>
    
    <content type="html"><![CDATA[<p>今天，我是来填坑的。前段时间挖了这个坑，今天就把它填上。</p><p>这篇Blog是<a href="/2020/11/02/%E6%88%91%E7%9A%84Linux/">我与Linux的爱恨情仇</a>后续之作。</p><a id="more"></a><h2 id="我的Linxu软件"><a href="#我的Linxu软件" class="headerlink" title="我的Linxu软件"></a>我的Linxu软件</h2><h3 id="开发文档查看工具"><a href="#开发文档查看工具" class="headerlink" title="开发文档查看工具"></a>开发文档查看工具</h3><ul><li><p>Zeal</p></li><li><p>安装方式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pacman -S zeal</span><br><span class="line"><span class="comment">#如果打不开，提示是Qt的相关问题</span></span><br><span class="line"><span class="comment">#可以去github下载源代码，然后编译就可以用了</span></span><br></pre></td></tr></table></figure></li><li><p>代码仓库</p><blockquote><p><a href="https://github.com/zealdocs/zeal">https://github.com/zealdocs/zeal</a></p></blockquote></li><li><p>软件界面<br><img src="/img/zeal.png" alt="Zeal"></p></li></ul><h3 id="桌面程序开发"><a href="#桌面程序开发" class="headerlink" title="桌面程序开发"></a>桌面程序开发</h3><ul><li>Qt,KDE就是使用Qt开发的，我越来越喜欢Qt了。</li><li>安装方式<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pacman -S qtcreator</span><br></pre></td></tr></table></figure></li><li>软件界面<br><img src="/img/qt.png" alt="Qt Creator"></li></ul><h3 id="团队沟通工具"><a href="#团队沟通工具" class="headerlink" title="团队沟通工具"></a>团队沟通工具</h3><p>  我用过很多，就目前而言国内的都不好用。</p><ul><li>Microsoft Teams(非常好用，除了网络问题)</li><li>安装方式<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pacman -S teams-insiders</span><br><span class="line"><span class="comment">#软件仓库中，就是有insider版。</span></span><br><span class="line"><span class="comment">#官方网站可以下载正式版的</span></span><br></pre></td></tr></table></figure></li><li>软件界面<br><img src="/img/teams.png" alt="Microsoft Teams"></li></ul><h3 id="录屏推流软件"><a href="#录屏推流软件" class="headerlink" title="录屏推流软件"></a>录屏推流软件</h3><p>我为了用Linux开会，也是愁死我了。<br>最后，只能使用OBS进行推流共享屏幕了。</p><ul><li>OBS Studio</li><li>安装方式<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pacman -S obs-studio</span><br></pre></td></tr></table></figure></li><li>软件界面<br><img src="/img/obs.png" alt="OBS Studio"></li></ul><h3 id="RSS订阅软件"><a href="#RSS订阅软件" class="headerlink" title="RSS订阅软件"></a>RSS订阅软件</h3><p>这软件我是找了好久，以前还打算自己用Qt写一个。<br>这是我每天基本都是打开的软件。</p><ul><li>Akregator</li><li>安装方式<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pacman -S akregator</span><br></pre></td></tr></table></figure></li><li>软件界面<br><img src="/img/akregator.png" alt="Akregator"></li></ul><h3 id="远程控制软件"><a href="#远程控制软件" class="headerlink" title="远程控制软件"></a>远程控制软件</h3><p>我也是听我朋友说，才知道TeamViewer有全平台版本，就是目前功能不全。</p><ul><li>TeamViewer</li><li>安装方式<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pacman -S teamviewer</span><br></pre></td></tr></table></figure></li><li>软件界面<br><img src="/img/tv.png" alt="TeamViewer"></li></ul><h3 id="资源下载"><a href="#资源下载" class="headerlink" title="资源下载"></a>资源下载</h3><p>我以前写过一篇qBittorrent的博客</p><ul><li>qBittorrent enhanced editors (增强版，会自动更新tracker服务器列表)</li><li>Github<blockquote><p><a href="https://github.com/c0re100/qBittorrent-Enhanced-Edition">https://github.com/c0re100/qBittorrent-Enhanced-Edition</a></p></blockquote></li><li>软件界面<br><img src="/img/qbit.png" alt="qBittorrent"></li></ul><h3 id="网络仿真"><a href="#网络仿真" class="headerlink" title="网络仿真"></a>网络仿真</h3><ul><li>我在计算机网络实验课程，用来做实验的。</li><li>Cisco Packet Tracer</li><li>安装命令<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pacman -S packettracer</span><br></pre></td></tr></table></figure></li><li>软件界面<br><img src="/img/packetTracer.png" alt="Cisco Packet Tracer"></li></ul><p>这个故事就到这里吧🎊🎊🎊</p><p>Linux没有你想的那么好，但也没有你想的那么差。<br><img src="/img/desktop.png" alt="我的桌面"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天，我是来填坑的。前段时间挖了这个坑，今天就把它填上。&lt;/p&gt;
&lt;p&gt;这篇Blog是&lt;a href=&quot;/2020/11/02/%E6%88%91%E7%9A%84Linux/&quot;&gt;我与Linux的爱恨情仇&lt;/a&gt;后续之作。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux之路" scheme="http://yoursite.com/categories/Linux%E4%B9%8B%E8%B7%AF/"/>
    
    
    <category term="Arch" scheme="http://yoursite.com/tags/Arch/"/>
    
    <category term="Manjaro" scheme="http://yoursite.com/tags/Manjaro/"/>
    
    <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>EduCoder-Java面向对象之包装类</title>
    <link href="http://yoursite.com/2020/11/27/EduCoder-Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E5%8C%85%E8%A3%85%E7%B1%BB/"/>
    <id>http://yoursite.com/2020/11/27/EduCoder-Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E5%8C%85%E8%A3%85%E7%B1%BB/</id>
    <published>2020-11-27T11:20:48.000Z</published>
    <updated>2020-11-27T12:15:44.838Z</updated>
    
    <content type="html"><![CDATA[<p>我已经忘记了，上次更新博客是什么时候🤣。<br>电脑上也有不少的知识点碎片没有整理，也许是我比较懒。</p><a id="more"></a><p>这几天，学校出了教学事故。上了半个学期的Java Spring boot开发，<br>才知道同学没有学过Java，。🤪<br><del>我也就只能偷偷笑了，反正我也不喜欢Spring boot开发(为啥呢？？ 后期更新说明)</del><br>然后，学校就把Spring boot 的课程改成了Java(网课，Spring boot 也是一直上网课)。<br>第一节课就是配个环境，对于我Linux用户配java环境不存在的(<del>就是这么霸气</del>)。<br>不过，老师提供了在Educoder上的课程安排。</p><p>我就用了几天的课余时间刷了一下Java题目，回顾一下Java语言。</p><h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><ul><li><p>在JAVA中，八大基础数据类型（int,float,double…）是不具备对象的特征的，比如基本数据类型就不能调用方法，功能简单，为了让基本数据类型也具备对象的特征，就有了JAVA<code>包装类(Wrapper Classes)</code>。</p></li><li><p>基础数据类型是没有属性的，也是不能调用方法的。</p></li><li><p>包装类就是：将基本数据类型包装成对象，使其具有了对象的属性和方法。<br>这样就可以使用方法和属性了。</p></li></ul><h3 id="包装类作用"><a href="#包装类作用" class="headerlink" title="包装类作用"></a>包装类作用</h3><ul><li><p>将本类型与其他类型进行转换；</p></li><li><p>将字符串与本类型及包装类型相互转换。</p></li></ul><h3 id="包装类使用方式"><a href="#包装类使用方式" class="headerlink" title="包装类使用方式"></a>包装类使用方式</h3><ul><li><p>很简单把TA当成对象就可以了(<del>sorry,忘了你没有对象</del>)</p></li><li><p>代码如下:🍖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="keyword">new</span> Integer(<span class="number">100</span>);</span><br><span class="line">Integer j = <span class="number">100</span>;</span><br></pre></td></tr></table></figure><p>以上两种方式都可以。</p></li><li><p><code>基本数据类型</code>转换成<code>包装类</code>的过程叫做<code>装箱(boxing)</code>。</p></li><li><p><code>包装类</code>转换成<code>基本数据类型</code>的过程叫做<code>拆箱(unboxing)</code>。</p></li><li><p>代码如下：🍖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">Integer x= <span class="keyword">new</span> Integer(i);  <span class="comment">//手动装箱</span></span><br><span class="line">Integer y = i; <span class="comment">//自动装箱</span></span><br><span class="line"></span><br><span class="line">Integer j = <span class="keyword">new</span> Integer(<span class="number">9</span>);</span><br><span class="line">iint m = j.intValue(); <span class="comment">//手动拆箱</span></span><br><span class="line"><span class="keyword">int</span> n = j;<span class="comment">//自动拆箱</span></span><br></pre></td></tr></table></figure><p>装箱和拆箱可以分为<code>手动--</code>和<code>自动--(autoboxing)</code>。</p></li></ul><p><code>这里的手动(EduCoder上是这么说的)，我并没有找到官方的说法。</code></p><ul><li><p>官方说法🔗</p><blockquote><p><a href="(https://docs.oracle.com/javase/7/docs/technotes/guides/language/autoboxing.html)">Autoboxing<br>As any Java programmer knows, you can’t put an int (or other primitive value) into a collection. Collections can only hold object references, so you have to box primitive values into the appropriate wrapper class (which is Integer in the case of int). When you take the object out of the collection, you get the Integer that you put in; if you need an int, you must unbox the Integer using the intValue method. All of this boxing and unboxing is a pain, and clutters up your code. The autoboxing and unboxing feature automates the process, eliminating the pain and the clutter.</a></p></blockquote></li><li><p>Autoboxing 是为了简化使用Collection时，从基本类型到包转类型，使用结束后，又要从包装类型转化到基本类型的繁琐过程。</p></li></ul><h3 id="基础类型和包装类"><a href="#基础类型和包装类" class="headerlink" title="基础类型和包装类"></a>基础类型和包装类</h3><table><thead><tr><th>基本类型</th><th>对应的包装类型</th></tr></thead><tbody><tr><td>bye</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>char</td><td>Character</td></tr><tr><td>boolean</td><td>Boolean</td></tr></tbody></table><p>上图，就是两者的对应关系了。</p><p>说了一大堆，感觉没啥用呀。<del>其实我就是为了水一期博客😝</del></p><p>好吧，这里是为了后面Java <code>Collection</code>做准备，Collection 相当于C++里面的<code>STL</code>,今天就到这里吧！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我已经忘记了，上次更新博客是什么时候🤣。&lt;br&gt;电脑上也有不少的知识点碎片没有整理，也许是我比较懒。&lt;/p&gt;</summary>
    
    
    
    <category term="回归之路" scheme="http://yoursite.com/categories/%E5%9B%9E%E5%BD%92%E4%B9%8B%E8%B7%AF/"/>
    
    
    <category term="EduCoder" scheme="http://yoursite.com/tags/EduCoder/"/>
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>基本排序算法</title>
    <link href="http://yoursite.com/2020/11/22/%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2020/11/22/%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</id>
    <published>2020-11-22T12:18:22.000Z</published>
    <updated>2020-11-23T07:26:52.644Z</updated>
    
    <content type="html"><![CDATA[<p>半个月没写博客了，两个星期前结束了HMTL课程。然后就考完试了，终于不用上这么无聊的课程了。<br>博客有时间还是要坚持写的，今天就开始吧。</p><a id="more"></a><p>今天就来看看，下面这些基本算法吧！ </p><h2 id="Selection-Sort"><a href="#Selection-Sort" class="headerlink" title="Selection-Sort"></a>Selection-Sort</h2><ul><li>选择排序。</li><li>时间复杂度O(n^2)、空间复杂度O(1)。</li><li>采用双重遍历，内层遍历没次寻找[i,n)区间里的最小值<br>然后，与第i个元素进行交换( [0,i) 区间为有序序列)。</li><li>图解如下：<br><img src="/img/selection-sort.jpg" alt="Selection-Sort"></li><li>代码如下：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++)&#123;</span><br><span class="line">        <span class="comment">// 寻找[i, n)区间里的最小值</span></span><br><span class="line">        <span class="keyword">int</span> minIndex = i;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j = i + <span class="number">1</span> ; j &lt; n ; j ++ )</span><br><span class="line">            <span class="keyword">if</span>( arr[j] &lt; arr[minIndex] )</span><br><span class="line">                minIndex = j;</span><br><span class="line">        swap( arr[i] , arr[minIndex] );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Insertion-Sort"><a href="#Insertion-Sort" class="headerlink" title="Insertion-Sort"></a>Insertion-Sort</h2></li><li>插入排序。</li><li>时间复杂度O(n^2)、空间复杂度O(1);</li><li>采用双重遍历，单独看最左边的原始为有序(任意一个单独的元素都为有序序列)。选择该元素的下一元素，插入到前面的有序序列中，是该序列依旧有序。</li><li>图解如下：<br><img src="/img/insertion-sort.jpg" alt="Insertion-Sort"></li><li>代码如下：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(T arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n ; i ++ ) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 寻找元素arr[i]合适的插入位置</span></span><br><span class="line">        <span class="comment">//[0,i-1)区间为有序序列，[i-1,n) 为待遍历序列。</span></span><br><span class="line">       <span class="keyword">for</span>( <span class="keyword">int</span> j = i ; j &gt; <span class="number">0</span> ; j-- )</span><br><span class="line">           <span class="keyword">if</span>( arr[j] &lt; arr[j<span class="number">-1</span>] )</span><br><span class="line">               swap( arr[j] , arr[j<span class="number">-1</span>] );</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Bubble-Sort"><a href="#Bubble-Sort" class="headerlink" title="Bubble-Sort"></a>Bubble-Sort</h2></li><li>冒泡排序 (这个好熟悉呀)</li><li>时间复杂度O(n^2)、空间复杂度O(1);</li><li>采用双重遍历，每次内层需要寻找最大的元素，使该元素沉到数组尾部(有序序列的最前面)。</li><li>图解如下：<br><img src="/img/bubble-sort.jpg" alt="Bubble-Sort"></li><li>代码如下：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bubble</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span>; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span> ; ++j)</span><br><span class="line">            <span class="keyword">if</span>(nums[j]  &gt;  nums[j + <span class="number">1</span>])</span><br><span class="line">                swap(nums[j],nums[j+<span class="number">1</span>]); </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Shell-Sort"><a href="#Shell-Sort" class="headerlink" title="Shell-Sort"></a>Shell-Sort</h2></li><li>希尔排序 (日常见的比较少)。</li><li>时间复杂度O(n^1.3) 空间复杂度O(1)。</li><li>希尔排序又称缩小增量排序，基于插入排序。基本思想是划分多组分别进行插入排序。</li><li>图解如下：<br><img src="/img/shell-sort.jpg" alt="Shell-Sort"></li><li>代码如下:<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//增量gap，并逐步缩小增量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> gap = arr.<span class="built_in">size</span>() / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//从第gap个元素，逐个对其所在组进行直接插入排序操作</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; arr.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line">            <span class="keyword">while</span> (j - gap &gt;= <span class="number">0</span> &amp;&amp; arr[j] &lt; arr[j - gap])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//插入排序采用交换法</span></span><br><span class="line">                swap(arr, j, j - gap);</span><br><span class="line">                j -= gap;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>基本排序算法时间复杂度基本都是O(n^2)，shell-sort时间复杂度度也达不到O(n)。🙄</p><p>今天就到这里吧～～～ bye.💝</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;半个月没写博客了，两个星期前结束了HMTL课程。然后就考完试了，终于不用上这么无聊的课程了。&lt;br&gt;博客有时间还是要坚持写的，今天就开始吧。&lt;/p&gt;</summary>
    
    
    
    
    <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
    <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>STL容器分类</title>
    <link href="http://yoursite.com/2020/11/09/STL%E5%AE%B9%E5%99%A8%E5%88%86%E7%B1%BB/"/>
    <id>http://yoursite.com/2020/11/09/STL%E5%AE%B9%E5%99%A8%E5%88%86%E7%B1%BB/</id>
    <published>2020-11-09T08:51:16.000Z</published>
    <updated>2020-11-09T08:51:16.580Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux相关网络命令</title>
    <link href="http://yoursite.com/2020/11/08/Linux%E7%9B%B8%E5%85%B3%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2020/11/08/Linux%E7%9B%B8%E5%85%B3%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4/</id>
    <published>2020-11-08T12:36:23.000Z</published>
    <updated>2020-11-08T12:53:06.586Z</updated>
    
    <content type="html"><![CDATA[<p>搞了几天运动会，今天才意识到计算机网络的实验报告还没有写完。不过上实验课程的时候，我都把命令敲过了一篇(ping,ipconfig,arp,netstat)。<del>这些我以前就玩过，有点无聊</del></p><a id="more"></a><p>今天，我在linux下面敲这些命令的时候发现有些命令找不到。😭<br>我就查了一下🤔<del>热爱学习的我</del></p><h2 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h2><p>在Windows默认ping 4次。而在Linux下面需要用-c指定次数。</p><h2 id="ipconfig"><a href="#ipconfig" class="headerlink" title="ipconfig"></a>ipconfig</h2><p>可以使用ifconfig，不过有些版本的linux这个命令被取代了。需要是ip address show，就可以查看相关网络配置。</p><h2 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h2><p>地址解析协议，玩过kali局网攻击的话。就很熟悉啦！<br>这个命令在linux下面一样没有，代替命令是ip neighbor会列出 IP 对应的MAC地址。</p><h2 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h2><p>这个命令听说linux系统自带有，不过我的linux版本没有。只有默认的ss(Socket Statistics)命令。加入-t显示IP/TCP相关的信息</p><p>一个小小的命令记录。bye～～～</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;搞了几天运动会，今天才意识到计算机网络的实验报告还没有写完。不过上实验课程的时候，我都把命令敲过了一篇(ping,ipconfig,arp,netstat)。&lt;del&gt;这些我以前就玩过，有点无聊&lt;/del&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Linux之路" scheme="http://yoursite.com/categories/Linux%E4%B9%8B%E8%B7%AF/"/>
    
    
    <category term="Arch" scheme="http://yoursite.com/tags/Arch/"/>
    
    <category term="Manjaro" scheme="http://yoursite.com/tags/Manjaro/"/>
    
    <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>C++Lambda表达式</title>
    <link href="http://yoursite.com/2020/11/06/C-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/11/06/C-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2020-11-06T12:59:34.000Z</published>
    <updated>2020-11-06T13:19:13.578Z</updated>
    
    <content type="html"><![CDATA[<p>今天的每日一题，也是比较简单的！🎊<br>但我，查看官方题解时，我惊呆了。</p><a id="more"></a><p>我看到了如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sort(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), [&amp;](<span class="keyword">int</span> x, <span class="keyword">int</span> y) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bit</span>[x] &lt; <span class="built_in">bit</span>[y])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bit</span>[x] &gt; <span class="built_in">bit</span>[y])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x &lt; y;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我看了半天，没反应过来🤣，看完评论才知道是C++11 的新特性 Lambda表达式。</p><h2 id="Lambda表达式形式"><a href="#Lambda表达式形式" class="headerlink" title="Lambda表达式形式"></a>Lambda表达式形式</h2><blockquote><p>[外部变量访问说明符](参数列表)-&gt;返回值类型{</p><p>语句块</p><p>}</p></blockquote><ul><li>外部访问方式： =表示允许修改外部变量，&amp;不允许修改外部变量</li><li>参数列表：和普通函数一样</li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><ul><li>代码：<pre><code class="C++"><span class="keyword">int</span> a[<span class="number">4</span>] = {<span class="number">11</span>, <span class="number">2</span>, <span class="number">33</span>, <span class="number">4</span>};sort(a, a+<span class="number">4</span>, [=](<span class="keyword">int</span> x, <span class="keyword">int</span> y) -&gt; <span class="keyword">bool</span> {   <span class="keyword">return</span> x%<span class="number">10</span> &lt; y%<span class="number">10</span>;   } );for_each(a, a+<span class="number">4</span>, [=](<span class="keyword">int</span> x) {   <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">" "</span>;   } );</code></pre></li><li>结果： 11 2 33 4</li></ul><h2 id="外部变量"><a href="#外部变量" class="headerlink" title="外部变量"></a>外部变量</h2><ul><li>“外部变量访问方式说明符”还可以有更加复杂和灵活的用法。</li><li>[=, &amp;x, &amp;y]表示外部变量 x、y 的值可以被修改，其余外部变量不能被修改；</li><li>[&amp;, x, y]表示除 x、y 以外的外部变量，值都可以被修改。</li></ul><h2 id="Lambda表达式作用"><a href="#Lambda表达式作用" class="headerlink" title="Lambda表达式作用"></a>Lambda表达式作用</h2><ul><li><p>使用 STL 时，往往会大量用到函数对象，为此要编写很多函数对象类。有的函数对象类只用来定义了一个对象，而且这个对象也只使用了一次，编写这样的函数对象类就有点浪费。</p></li><li><p>说白了，就使用便捷👋</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天的每日一题，也是比较简单的！🎊&lt;br&gt;但我，查看官方题解时，我惊呆了。&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
    <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
    <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>我与Linux的爱恨情仇</title>
    <link href="http://yoursite.com/2020/11/02/%E6%88%91%E7%9A%84Linux/"/>
    <id>http://yoursite.com/2020/11/02/%E6%88%91%E7%9A%84Linux/</id>
    <published>2020-11-02T07:53:30.000Z</published>
    <updated>2020-11-27T13:28:06.788Z</updated>
    
    <content type="html"><![CDATA[<p>我与你第一次相遇，是在2016年。那个时候作为电脑小白的我，带着好奇心把你安装到了我电脑上，那个时候你叫Ubuntu16.04。💝</p><a id="more"></a><p>安装完成后，我失去是我的磁盘原有的所有数据🤔。我当时以为，你的安装方式和Windows是一样的。谁能想到你独吞我整个硬盘，使用你不到一天的时间，我就把Windows给重新安装上了。🤣</p><h2 id="我与Linux爱恨"><a href="#我与Linux爱恨" class="headerlink" title="我与Linux爱恨"></a>我与Linux爱恨</h2><p>后来，和你的见面方式都是在VMware里面了；你就没有单独存在于我的物理机里面。<br>在VMware里面，我尝试过很多的Linux系统。有CentOS、Redhat、Fedora；真正第一次认真敲入命令是在CentOS里面。那个时候，跟着教程一步一步的敲入命令。刚刚开始的时候，还经常敲错。😭</p><p>2018年，我遇到到一个IDE(Android Studio)，体会到什么叫编码两分钟，编译两小时(<del>其实是自己电脑太卡，联想G400</del>)的感觉。<br>每当我有空闲时间的时候，我都会打开浏览器。看看有没有什么可以优化编译的方法，的确通过修改Android Studio的一些配置可以加快编译。但是作用不是很大。🙄，还看到了很多关于Linux对硬件性能低的博客。</p><h2 id="我的Linux时代"><a href="#我的Linux时代" class="headerlink" title="我的Linux时代"></a>我的Linux时代</h2><p>2018年的冬天，我就在我的物理机里面安装Fedora系统。当时我还在我的VMware里面体验过，感觉不错。<br>可是，在实际中出现了几个问题。</p><ul><li>使用的人比较少，出了问题比较难解决。</li><li>我在安装51编译库的时候，发现编译工具的名称尽然不同。(<del>当时想骂人</del>)</li><li>对于国内用户QQ是非常重要的，Fedora安装QQ是比较困难的。</li></ul><p>用了不到一个星期。我就从Fedora，步入了Arch魔教的阵营(现在我新买的电脑上用Manjaro(基于arch开发的))。</p><p>从2018年到现在，我已经习惯了Linux的简洁和高效。<br>对于Linux，我喜欢一下几点 </p><ul><li>一切皆文件</li><li>拥有Root，拥有一切</li><li>一条命令，安装需要的软件。(next..next..next 不存在的)</li><li>我可以任意修改所有文件，达到我想要的效果。</li><li>我可以任意改动我的桌面布局，不需要安装任何额外的软件。</li><li>我可以切换不同的桌面环境。</li></ul><h2 id="我的Linux软件"><a href="#我的Linux软件" class="headerlink" title="我的Linux软件"></a>我的Linux软件</h2><p>下面说说，我日常使用哪些软件。</p><h3 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h3><ul><li>Google Chrome  (刚刚从chromuim切换过来)</li><li>安装方式<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pacman -S google-chrome</span><br></pre></td></tr></table></figure></li><li>软件界面<br><img src="/img/chrome.png" alt="Google Chrome"></li></ul><h3 id="编程工具"><a href="#编程工具" class="headerlink" title="编程工具"></a>编程工具</h3><h4 id="Android-开发"><a href="#Android-开发" class="headerlink" title="Android 开发"></a>Android 开发</h4><ul><li>Android Studio </li><li>安装方式<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pacman -S android-studio</span><br></pre></td></tr></table></figure></li><li>软件界面<br><img src="/img/android.png" alt="Android Studio"></li></ul><h4 id="Java开发"><a href="#Java开发" class="headerlink" title="Java开发"></a>Java开发</h4><ul><li>IntelliJ idea 社区版</li><li>安装方式<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pacman -S intellij-idea-community-edition</span><br></pre></td></tr></table></figure></li><li>软件界面<br><img src="/img/idea.png" alt="IntelliJ Idea"></li></ul><h4 id="C-开发"><a href="#C-开发" class="headerlink" title="C++开发"></a>C++开发</h4><ul><li>Visual Studio Code</li><li>这个编辑器结合插件非常好用，我写博客也是用这个</li><li>安装方式<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pacman -S visual-stduio-code-bin</span><br></pre></td></tr></table></figure></li><li>软件界面<br><img src="/img/vscode.png" alt="Visual Studio Code"></li></ul><h3 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h3><h4 id="VirtualBox"><a href="#VirtualBox" class="headerlink" title="VirtualBox"></a>VirtualBox</h4><ul><li>安装方式，看我以前写的如何安装Virtualbox的博客<h4 id="VMware（需要激活）"><a href="#VMware（需要激活）" class="headerlink" title="VMware（需要激活）"></a>VMware（需要激活）</h4></li><li>安装方式<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pacman -S vmware-workstation</span><br></pre></td></tr></table></figure>这个两个我都使用过，目前在使用vmware</li><li>软件界面<br><img src="/img/vmware.png" alt="VMware"></li></ul><h3 id="通讯"><a href="#通讯" class="headerlink" title="通讯"></a>通讯</h3><h4 id="QQ"><a href="#QQ" class="headerlink" title="QQ"></a>QQ</h4><ul><li>使用deepin的wine运行的TIM</li><li>安装方式<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pacman -S deepin.com.qq.office</span><br></pre></td></tr></table></figure></li><li>软件界面<br><img src="/img/tim.png" alt="QQ"></li></ul><h4 id="Evolution"><a href="#Evolution" class="headerlink" title="Evolution"></a>Evolution</h4><ul><li>这是一个电子邮箱客户端(主要用来给老师和学委发作业之类的)</li><li>安装方式<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pacman -S evolution</span><br></pre></td></tr></table></figure></li><li>软件界面<br><img src="/img/evolution.png" alt="Evolution"></li></ul><h3 id="AUR-助手工具"><a href="#AUR-助手工具" class="headerlink" title="AUR 助手工具"></a>AUR 助手工具</h3><ul><li>用来安装AUR(Arch User Repository)仓库的软件</li><li>安装方式<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pacman -S yay</span><br></pre></td></tr></table></figure></li><li>软件界面<br><img src="/img/yay.png" alt="YAY"></li></ul><h3 id="音乐"><a href="#音乐" class="headerlink" title="音乐"></a>音乐</h3><ul><li>落雪音乐助手，一款开源软件</li><li>安装方式,需要自己下载.pacman的包，然后安装<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pacman -U *.pacman</span><br></pre></td></tr></table></figure></li><li>直接下载Appimage后缀的，可以自己运行。</li><li>软件界面<br><img src="/img/lx.png" alt="落雪音乐助手"></li></ul><h3 id="office替代品"><a href="#office替代品" class="headerlink" title="office替代品"></a>office替代品</h3><ul><li>Micosoft office 的良好替代品</li><li>安装方式<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pacman -S wps-office</span><br></pre></td></tr></table></figure></li><li>软件界面<br><img src="/img/wps.png" alt="WPS"><br>今天就分享到这里吧，有些软件后续补上。🎊🎊</li></ul><p>希望，你也加入Linux</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我与你第一次相遇，是在2016年。那个时候作为电脑小白的我，带着好奇心把你安装到了我电脑上，那个时候你叫Ubuntu16.04。💝&lt;/p&gt;</summary>
    
    
    
    <category term="Linux之路" scheme="http://yoursite.com/categories/Linux%E4%B9%8B%E8%B7%AF/"/>
    
    
    <category term="Arch" scheme="http://yoursite.com/tags/Arch/"/>
    
    <category term="Manjaro" scheme="http://yoursite.com/tags/Manjaro/"/>
    
    <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>349.两个数组的交集</title>
    <link href="http://yoursite.com/2020/11/02/349-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/"/>
    <id>http://yoursite.com/2020/11/02/349-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/</id>
    <published>2020-11-02T07:07:19.000Z</published>
    <updated>2020-11-02T07:53:10.488Z</updated>
    
    <content type="html"><![CDATA[<p>今天的每日一题就很简单啦。🎊<br>今天就不废话了，直接上题目吧。</p><a id="more"></a><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>给定两个数组，编写一个函数来计算它们的交集。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><blockquote><p>输入：nums1 = [1,2,2,1], nums2 = [2,2]<br>输出：[2]</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul><li>最简单的方法，采用逐个比较。及nums1中的每个元素都与nums2中的每个元素进行比较，如果相等，这加入到容器中，再对容器进行去重就可以了。</li><li>代码如下<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">intersection</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums1.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums2.<span class="built_in">size</span>(); ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums1[i] == nums2[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    res.push_back(nums1[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator ite = unique(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        res.erase(ite, res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="更优解法"><a href="#更优解法" class="headerlink" title="更优解法"></a>更优解法</h2></li><li>官方解法<blockquote><p>如果两个数组是有序的，则可以使用双指针的方法得到两个数组的交集。</p><p>首先对两个数组进行排序，然后使用两个指针遍历两个数组。可以预见的是加入答案的数组的元素一定是递增的，为了保证加入元素的唯一性，我们需要额外记录变量 pre 表示上一次加入答案数组的元素。</p><p>初始时，两个指针分别指向两个数组的头部。每次比较两个指针指向的两个数组中的数字，如果两个数字不相等，则将指向较小数字的指针右移一位，如果两个数字相等，且该数字不等于 pre ，将该数字添加到答案并更新 pre 变量，同时将两个指针都右移一位。当至少有一个指针超出数组范围时，遍历结束。</p></blockquote></li></ul><p>今天题目就到这里吧！！ 这是我遇到比较简单的每日一题。🤪🤪🤪</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天的每日一题就很简单啦。🎊&lt;br&gt;今天就不废话了，直接上题目吧。&lt;/p&gt;</summary>
    
    
    
    <category term="修炼之路" scheme="http://yoursite.com/categories/%E4%BF%AE%E7%82%BC%E4%B9%8B%E8%B7%AF/"/>
    
    
    <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
    <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>381.O(1)插入删除和获取随机元</title>
    <link href="http://yoursite.com/2020/10/31/381-%E6%8F%92%E5%85%A5%E5%88%A0%E9%99%A4%E5%92%8C%E8%8E%B7%E5%8F%96%E9%9A%8F%E6%9C%BA%E5%85%83/"/>
    <id>http://yoursite.com/2020/10/31/381-%E6%8F%92%E5%85%A5%E5%88%A0%E9%99%A4%E5%92%8C%E8%8E%B7%E5%8F%96%E9%9A%8F%E6%9C%BA%E5%85%83/</id>
    <published>2020-10-31T12:20:10.000Z</published>
    <updated>2020-10-31T12:48:59.248Z</updated>
    
    <content type="html"><![CDATA[<p>我用了半天的时间，与上帝交换，只为换回你💝！<br>我午睡醒来，打开我的电脑。发现一块黑屏，只有一个鼠标，和左边的dock栏上的白色。<br>该来的总会来，这件事情还是发生！！</p><a id="more"></a><p>我的系统桌面KDE，终于不能用了。我花时间，把KDE换成了DDE(Deepin Desktop Environment)。<br>我也不知道什么原因，竟然不是很好用。有几个应用打不开，主要还是不适应DDE的风格。<br>我就又换回了KDE，安装过程倒是有些崎岖   。不过路边的风景也很美。</p><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>设计一个支持在平均 时间复杂度 O(1) 下， 执行以下操作的数据结构。</p><p>注意: 允许出现重复元素。</p><p>insert(val)：向集合中插入元素 val。<br>remove(val)：当 val 存在时，从集合中移除一个 val。<br>getRandom：从现有集合中随机获取一个元素。每个元素被返回的概率应该与其在集合中的数量呈线性相关。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><blockquote><p>// 初始化一个空的集合。</p><p>RandomizedCollection collection = new &gt; &gt; &gt; &gt; RandomizedCollection();</p><p>// 向集合中插入 1 。返回 true 表示集合不包含 1 。</p><p>collection.insert(1);</p><p>// 向集合中插入另一个 1 。返回 false 表示集合包含 1 。集合现在包含 [1,1] 。<br>collection.insert(1);</p><p>// 向集合中插入 2 ，返回 true 。集合现在包含 [1,1,2] 。</p><p>collection.insert(2);</p><p>// getRandom 应当有 2/3 的概率返回 1 ，1/3 的概率返回 2 。</p><p>collection.getRandom();</p><p>// 从集合中删除 1 ，返回 true 。集合现在包含 [1,2] 。</p><p>collection.remove(1);</p><p>// getRandom 应有相同概率返回 1 和 2 。</p><p>collection.getRandom();</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul><li>我的第一思路，还是用桶排序的方法，把需要插入的元素，插入到数组中。即array[val]++; （val为插入的元素）。遮掩插入和取出的时间复杂度都是O(1)，但是题目没有给出val的取值范围。如果动态变化数组，当val值大于array.size()时，需要移动数组，时间复杂度为O(n)。这显然有违背题目。😅</li><li>当我查看官方解法时，我发现我在STL上的盲区(<del>昨天说学，可是没学</del>)。</li><li>官方解法的思路是哈希表(C++中没有，需要自己实现。使用Map 和 Set就可以实现)。</li><li>代码如下：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomizedCollection</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;&gt; idx;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    RandomizedCollection() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        nums.push_back(val);</span><br><span class="line">        idx[val].insert(nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> idx[val].<span class="built_in">size</span>() == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes a value from the collection. Returns true if the collection contained the specified element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (idx.<span class="built_in">find</span>(val) == idx.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = *(idx[val].<span class="built_in">begin</span>());</span><br><span class="line">        nums[i] = nums.back();</span><br><span class="line">        idx[val].erase(i);</span><br><span class="line">        idx[nums[i]].erase(nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">            idx[nums[i]].insert(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (idx[val].<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            idx.erase(val);</span><br><span class="line">        &#125;</span><br><span class="line">        nums.pop_back();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get a random element from the collection. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nums[rand() % nums.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="更优解法"><a href="#更优解法" class="headerlink" title="更优解法"></a>更优解法</h2></li><li>这里涉及到我知识盲区😭😭😭，我就不写最优解法了。后期补上！！</li></ul><p>万圣节快乐，这是令人难忘的一天。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我用了半天的时间，与上帝交换，只为换回你💝！&lt;br&gt;我午睡醒来，打开我的电脑。发现一块黑屏，只有一个鼠标，和左边的dock栏上的白色。&lt;br&gt;该来的总会来，这件事情还是发生！！&lt;/p&gt;</summary>
    
    
    
    <category term="修炼之路" scheme="http://yoursite.com/categories/%E4%BF%AE%E7%82%BC%E4%B9%8B%E8%B7%AF/"/>
    
    
    <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
    <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>463.岛屿的周长</title>
    <link href="http://yoursite.com/2020/10/30/463-%E5%B2%9B%E5%B1%BF%E7%9A%84%E5%91%A8%E9%95%BF/"/>
    <id>http://yoursite.com/2020/10/30/463-%E5%B2%9B%E5%B1%BF%E7%9A%84%E5%91%A8%E9%95%BF/</id>
    <published>2020-10-30T09:02:25.000Z</published>
    <updated>2020-10-31T08:18:31.690Z</updated>
    
    <content type="html"><![CDATA[<p>在一个岛屿上生活，是我的梦想！😝</p><p>今天，leetcode给我这个机会。计算我岛屿的长度，但是他并没有给我这个岛。</p><a id="more"></a><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>给定一个包含 0 和 1 的二维网格地图，其中 1 表示陆地 0 表示水域。</p><p>网格中的格子水平和垂直方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。</p><p>岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><blockquote><p>输入:</p><p>[[0,1,0,0],</p><p>[1,1,1,0],</p><p>[0,1,0,0],</p><p> [1,1,0,0]]</p><p>输出: 16</p><p>解释: 它的周长是下面图片中的 16 个黄色的边：</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul><li>看到这题题目，我也没什么解题思路；就知道逐个去遍历，应该是可以解出来的。但是并没有清晰的编码思路。</li><li>对于一个陆地格子的每条边，它被算作岛屿的周长当且仅当这条边为网格的边界或者相邻的另一个格子为水域。 因此，我们可以遍历每个陆地格子，看其四个方向是否为边界或者水域，如果是，将这条边的贡献（即 11）加入答案 \textit{ans}ans 中即可。（官方解题思路）</li><li>官方提供的解题思路，就是遍历每一个正方形；然后看这个正方形的周围(右，下，左，上的遍历顺序，可以改变)时候有陆地或水域，如果有水域或者是网格的边缘，那周长就加1。</li><li>总时间复杂度为：O(4nm)=O(nm);空间复杂度：O(1)。</li><li>代码如下<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">islandPerimeter</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;grid)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].<span class="built_in">size</span>(); ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">int</span> tx = i + dx[k];</span><br><span class="line">                        <span class="keyword">int</span> ty = j + dy[k];</span><br><span class="line">                        <span class="keyword">if</span> (tx &lt; <span class="number">0</span> || tx &gt;= grid.<span class="built_in">size</span>() || ty &lt; <span class="number">0</span> || ty &gt;= grid[<span class="number">0</span>].<span class="built_in">size</span>() || !grid[tx][ty])</span><br><span class="line">                            cnt++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ans += cnt;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="更优解法"><a href="#更优解法" class="headerlink" title="更优解法"></a>更优解法</h2>这个就我点困难了(<del>这个题目，我也是看了官方的解释才懂的🤫</del>)，我后期补。最优解一定是有的！！</li></ul><p>对啦，祝大家万圣夜快乐🤪🤪🤪🤪</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在一个岛屿上生活，是我的梦想！😝&lt;/p&gt;
&lt;p&gt;今天，leetcode给我这个机会。计算我岛屿的长度，但是他并没有给我这个岛。&lt;/p&gt;</summary>
    
    
    
    <category term="修炼之路" scheme="http://yoursite.com/categories/%E4%BF%AE%E7%82%BC%E4%B9%8B%E8%B7%AF/"/>
    
    
    <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
    <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>1207.独一无二的出现次数</title>
    <link href="http://yoursite.com/2020/10/28/1207-%E7%8B%AC%E4%B8%80%E6%97%A0%E4%BA%8C%E7%9A%84%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0/"/>
    <id>http://yoursite.com/2020/10/28/1207-%E7%8B%AC%E4%B8%80%E6%97%A0%E4%BA%8C%E7%9A%84%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0/</id>
    <published>2020-10-28T11:42:05.000Z</published>
    <updated>2020-10-28T12:07:43.810Z</updated>
    
    <content type="html"><![CDATA[<p>今天，把个人博客的主题换了一个。没有以前那么好看了。但是访问速度提升了不少。以后，有时间的话。我还是打算美化一下，但是毕竟我不是搞前端的，个人博客对我而言就是拿来发发个人感想，记录个人生活的。<br>废话到这里🧑‍🔬，看题目吧～～～</p><a id="more"></a><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>给你一个整数数组 arr，请你帮忙统计数组中每个数的出现次数。</p><p>如果每个数的出现次数都是独一无二的，就返回 true；否则返回 false。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><blockquote><p>输入：arr = [1,2,2,1,1,3]</p><p>输出：true</p><p>解释：在该数组中，1 出现了 3 次，2 出现了 2 次，3 只出现了 1 次。没有两个数的出现次数相同。</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul><li><p>我看到这个题目，就想到了前一天，类似于桶排序的思路。<br>后面看到给出的数据范围，-1000&lt;= arr[i] &lt;= 1000，我就意识到了直接使用桶排序的思维是解决不了的(数组下标不能为负数)。😅</p></li><li><p>思考一会后，我想到了STL里面的Map（键值对的方式存储数据）。这里的键是一个泛型(这就可以解决直接使用数组，下标不能为负数的情况)，接着在使用桶排序的思想，对map里面的值进行统计。再判断统计数据的值是否大于1,如果大于一这出现了重复次数的数字。🎊🎊🎊🎊🎊(<del>撒花，掌声</del>)</p></li><li><p>时间复杂度约为O(3n),其实一般成为O(n);空间复杂度约为O(2n),也可以称作O(n)。</p></li><li><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">uniqueOccurrences</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;arr)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : arr)</span><br><span class="line">        &#123;</span><br><span class="line">            m[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">int</span> aux[<span class="number">1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : m)</span><br><span class="line">        &#123;</span><br><span class="line">            aux[i.second]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (aux[i] &gt; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id="更优解法"><a href="#更优解法" class="headerlink" title="更优解法"></a>更优解法</h2><p>无独有偶，在题目的评论区也有一个很有意思的解法。👋👋<br>作者是使用了STL库中的Map 和 Set。(当初我也有这想法，只是我对STL库不是用了解，<del>看来需要好好学习STL库呀</del>)</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">uniqueOccurrences</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.<span class="built_in">size</span>();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            m[arr[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;times;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> p:m)</span><br><span class="line">            times.insert(p.second);</span><br><span class="line">        <span class="keyword">return</span> times.<span class="built_in">size</span>()==m.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这段代码的帅气程度快要赶上我了（<del>不要脸</del>）🤞🤞🤞🎊🎊🎊</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天，把个人博客的主题换了一个。没有以前那么好看了。但是访问速度提升了不少。以后，有时间的话。我还是打算美化一下，但是毕竟我不是搞前端的，个人博客对我而言就是拿来发发个人感想，记录个人生活的。&lt;br&gt;废话到这里🧑‍🔬，看题目吧～～～&lt;/p&gt;</summary>
    
    
    
    <category term="修炼之路" scheme="http://yoursite.com/categories/%E4%BF%AE%E7%82%BC%E4%B9%8B%E8%B7%AF/"/>
    
    
    <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
    <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>1365.有多少小于当前数字的数字</title>
    <link href="http://yoursite.com/2020/10/26/1365-%E6%9C%89%E5%A4%9A%E5%B0%91%E5%B0%8F%E4%BA%8E%E5%BD%93%E5%89%8D%E6%95%B0%E5%AD%97%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>http://yoursite.com/2020/10/26/1365-%E6%9C%89%E5%A4%9A%E5%B0%91%E5%B0%8F%E4%BA%8E%E5%BD%93%E5%89%8D%E6%95%B0%E5%AD%97%E7%9A%84%E6%95%B0%E5%AD%97/</id>
    <published>2020-10-26T13:55:35.000Z</published>
    <updated>2020-10-28T12:09:21.143Z</updated>
    
    <content type="html"><![CDATA[<p>有几个月没有写博客，这段时间都是在刷leetcode去啦。今天刷完，才想起来我还有博客。🙃开启每日一题吧！ 加油🦤🦤🦤</p><a id="more"></a><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>给你一个数组 nums，对于其中每个元素 nums[i]，请你统计数组中比它小的所有数字的数目。<br>换而言之，对于每个 nums[i] 你必须计算出有效的 j 的数量，其中 j 满足 j != i 且 nums[j] &lt; nums[i] 。<br>以数组形式返回答案。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><blockquote><p>输入：nums = [8,1,2,2,3]</p><p>输出：[4,0,1,1,3]</p><p>解释：</p><p>对于 nums[0]=8 存在四个比它小的数字：（1，2，2 和 3）。 </p><p>对于 nums[1]=1 不存在比它小的数字。</p><p>对于 nums[2]=2 存在一个比它小的数字：（1）。 </p><p>对于 nums[3]=2 存在一个比它小的数字：（1）。 </p><p>对于 nums[4]=3 存在三个比它小的数字：（1，2 和 2）。</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul><li>第一想法，是对整个nums数组进行排序.nums[i]的元素就会有i个比它小的元素(包含重复的，不符合题意要求，去要出去重复的)。<br>但是，后来仔细一看题目。发现，这样会打破输入数组的序列。</li><li>第二想法，是通过两个索引遍历整个数组。即每个元素和其他元素做比较，如果nums[i] &gt; nums[j]，则计数加一。比较完成后再存入结果数组中。</li><li>时间复杂度是O(n^2),空间复杂度为O(n);</li><li>代码如下：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">smallerNumbersThanCurrent</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.<span class="built_in">size</span>(); ++j)</span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (nums.at(i) &gt; nums.at(j))</span><br><span class="line">                &#123;</span><br><span class="line">                    num++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id="更优解法"><a href="#更优解法" class="headerlink" title="更优解法"></a>更优解法</h2><p>当我提交完代后，我看了一下评论区。<br>可谓是藏龙卧虎呀！！</p><ul><li>整个代码设计的非常巧妙,采用类似于桶排序的思路</li><li>先生成最大数组的大小的长度(题目给出了测试数据集的范围)</li><li>然后，对整个nums数组进行计数</li><li>在计算第i个元素，前i个的数量(arr 数组元素越靠后，对应nums里的元素越大)</li><li>在通过nums数组，获取与nums对应的元素值，存入vector。</li><li>代码如下：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">smallerNumbersThanCurrent</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> arr[<span class="number">101</span>];</span><br><span class="line">        <span class="built_in">memset</span>(arr, <span class="number">0</span>, <span class="keyword">sizeof</span>(arr));</span><br><span class="line">        <span class="comment">// 初始化计数桶</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : nums) &#123;</span><br><span class="line">            arr[i] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 累加处理计数桶，使得 arr[i] 表示比 i 小的数字的个数</span></span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i ++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">            arr[i] = cnt;</span><br><span class="line">            cnt += temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">        <span class="comment">// 遍历 nums，取出对应桶 arr[i] 里的结果即可</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">            ret.push_back(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>可以基于这个代码进行下一步的优化，但是时间复杂度大致还是O(n)级别。<br>方法是提前结束循环。😝</li></ul><p>今天的每日一题就到这里吧🎊</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;有几个月没有写博客，这段时间都是在刷leetcode去啦。今天刷完，才想起来我还有博客。🙃开启每日一题吧！ 加油🦤🦤🦤&lt;/p&gt;</summary>
    
    
    
    <category term="修炼之路" scheme="http://yoursite.com/categories/%E4%BF%AE%E7%82%BC%E4%B9%8B%E8%B7%AF/"/>
    
    
    <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
    <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Konsole无法启动</title>
    <link href="http://yoursite.com/2020/08/30/Konsole%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8/"/>
    <id>http://yoursite.com/2020/08/30/Konsole%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8/</id>
    <published>2020-08-30T03:11:45.000Z</published>
    <updated>2020-10-26T14:32:37.098Z</updated>
    
    <content type="html"><![CDATA[<p>前几天，想实现打开终端自动显示系统相关信息。<br>于是我就在修改了 Konsole Profile 的 Command 加入了一个命令。<br>结果，konsole都打不开啦。</p><a id="more"></a><p>这就非常尴尬啦，需要改回Profile 需要先打开konsole 才行呀😝。<br>可是，现在就是打不开。</p><p>纵然寻他千百度 打开百度已掉进黑灯瞎火处。<br>这就是我不喜欢用百度的原因，啥都查不到。(啥都没有也敢叫百度呀！！)</p><p>“一切皆文件”,这条Linux哲学。在我脑海中呈现🤔。<br>我顿悟，我找到Konsole的配置文件，不久可以改回来啦吗？<br>根本就不需要图形界面的Profile呀！！</p><h2 id="Konsole-profile-配置文件"><a href="#Konsole-profile-配置文件" class="headerlink" title="Konsole profile 配置文件"></a>Konsole profile 配置文件</h2><ul><li>所在路径 ~/.locla/share/konsole/*.profile</li><li>修改Command 项里面参数(记得保存哦)</li><li>点击Konsole图标，就可以启动成功<br>这就ok啦</li></ul><blockquote><p>Note: 到这里Konsole 不能启动的问题就修复，下面完成我未尽的事业🤪</p></blockquote><h2 id="未尽事业🤣"><a href="#未尽事业🤣" class="headerlink" title="未尽事业🤣"></a>未尽事业🤣</h2><h3 id="新建一个文件"><a href="#新建一个文件" class="headerlink" title="新建一个文件"></a>新建一个文件</h3><ul><li>最后是.开头的隐藏文件</li><li>这个文件用来存放，终端启动需要自动执行的命令<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ touch .neofetchShow</span><br></pre></td></tr></table></figure></li></ul><h3 id="写入命令"><a href="#写入命令" class="headerlink" title="写入命令"></a>写入命令</h3><ul><li>把需要自动执行的命令，写入到文件中<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">'neofetch'</span> &gt;&gt; .neofetchShow</span><br></pre></td></tr></table></figure><blockquote><p>neofetch 命令需要自己安装</p></blockquote></li></ul><h3 id="修改shell配置文件"><a href="#修改shell配置文件" class="headerlink" title="修改shell配置文件"></a>修改shell配置文件</h3><ul><li>默认shell 的配置文件为～/.bashrc</li><li>zsh配置文件为~/.zshrc</li><li>将文件路径写入配置文件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.neofetchShow</span><br></pre></td></tr></table></figure></li><li>保存配置文件</li></ul><blockquote><p>Note: 以上上操作都在home目录下完成，如果配置失败了，请核对路径和需要启动的命令时候可以执行</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;前几天，想实现打开终端自动显示系统相关信息。&lt;br&gt;于是我就在修改了 Konsole Profile 的 Command 加入了一个命令。&lt;br&gt;结果，konsole都打不开啦。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux之路" scheme="http://yoursite.com/categories/Linux%E4%B9%8B%E8%B7%AF/"/>
    
    
    <category term="Arch" scheme="http://yoursite.com/tags/Arch/"/>
    
    <category term="Manjaro" scheme="http://yoursite.com/tags/Manjaro/"/>
    
    <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>永别ActiveWindowControl</title>
    <link href="http://yoursite.com/2020/08/20/%E6%B0%B8%E5%88%ABActiveWindowControl/"/>
    <id>http://yoursite.com/2020/08/20/%E6%B0%B8%E5%88%ABActiveWindowControl/</id>
    <published>2020-08-20T06:22:51.000Z</published>
    <updated>2020-10-26T14:33:18.382Z</updated>
    
    <content type="html"><![CDATA[<p>当初刚刚接触Ubuntu的时候,我就很喜欢Unity桌面的全局菜单整合功能,🎊<br>可以把窗口标题和全局菜单整合为一体.<br>这样就可以节省一行显示标题的空间.</p><a id="more"></a><p>可是后来,Ubuntu放弃啦Unity桌面,搞了Gnome桌面.👎<br>当初,其他衍生版搞Gnome桌面,他特立独行搞Unity现在有放弃.<br>这是我不喜欢Ubuntu的其中原因之一.</p><p>后来,在我的老电脑上,我已经转入了Arch魔教.<br>我是非常喜欢Arch的包管理器.这是非常Amazing.🤪</p><p>不过,现在在我的新电脑(Lenovo 小新13 Pro)已经使用Manjaro一段时间,<br>Manjaro是基于Arch开发的,Arch的一些优势基本上都有.<br>主要还是安装系统过程中,简便啦很多.</p><p>我使用的KDE桌面,是已经预装了全局菜单.不过还是不能实现Unity桌面的风格.<br>后来知道active Window Control 插件,可以实现这个功能,</p><p>我个人觉得这个东西不太友好,我几次配置都出现了桌面黑黑的(我也不知道是啥情况.).<br>而且,对于Window Title显示不太好,因为Title长度不一致,所以显示就有一些问题.<br>有强迫症的我,就能难忍受啦.😅</p><p>直到遇到了你,由<a href="https://github.com/psifidotos">psifidotos</a>开发的applet-window系列插件🤪<br>另外,提一下.这个位开发者处理Github issue 的速度是很快的.<br>由于我的无知(我对系统不熟悉),在Windos title 这个仓库中Open issue .没过多久他就回复我,<br>而且,非常友好的给出了解决我问题的方式.</p><h2 id="如何实现Unity桌面风格"><a href="#如何实现Unity桌面风格" class="headerlink" title="如何实现Unity桌面风格"></a>如何实现Unity桌面风格</h2><p>需要安装如下插件,目前这些都不在AUR仓库中,需要自己下载编译安装.</p><ul><li>applet-window-title</li><li>applet-window-buttons</li><li>applet-window-appmenu</li></ul><blockquote><p>Note: 编译过程,系统需要有cmake 和 extra-cmake-modules 环境 .  这两个可以直接安装.</p></blockquote><h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><h3 id="安装applet-window-title"><a href="#安装applet-window-title" class="headerlink" title="安装applet-window-title"></a>安装applet-window-title</h3><ul><li><p>克隆仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/psifidotos/applet-window-title.git</span><br></pre></td></tr></table></figure><p>该插件使用QML编写,可以直接装入.不需要编译</p></li><li><p>安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> applet-window-title</span><br><span class="line">plasmapkg2 -i .</span><br></pre></td></tr></table></figure></li></ul><p>至此,安装完成🤞</p><h3 id="安装applet-window-buttons"><a href="#安装applet-window-buttons" class="headerlink" title="安装applet-window-buttons"></a>安装applet-window-buttons</h3><ul><li>克隆仓库<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/psifidotos/applet-window-buttons.git</span><br></pre></td></tr></table></figure></li><li>编译安装<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> applet-window-buttons</span><br><span class="line">sh install.sh</span><br></pre></td></tr></table></figure>shell 脚本需要知道完成,编译和安装工作.</li></ul><blockquote><p>Note: 一定要安装cmake和 extra-cmake-modules . 不然会无法编译</p></blockquote><p>至此,安装完成🤞</p><h3 id="安装applet-windows-appmenu"><a href="#安装applet-windows-appmenu" class="headerlink" title="安装applet-windows-appmenu"></a>安装applet-windows-appmenu</h3><p>如果,系统已经预装了,全局菜单. 这个可以不安装.<br>我就是使用系统预装的全局菜单的😝</p><p>如果没有就看下吧!!</p><ul><li>克隆仓库<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/psifidotos/applet-window-appmenu.git</span><br></pre></td></tr></table></figure></li><li>编译安装<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> applet-window-appmenu</span><br><span class="line">sh install.sh</span><br></pre></td></tr></table></figure>同样,shell会搞定一切.开发者还是蛮贴心的哈<del>~</del>👋</li></ul><p>到这就全部安装完成啦.</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>安装完成,就可以愉快到需要的地方.添加插件啦.<br><img src="/img/min.png" alt="效果"><br><img src="/img/max.png" alt="效果"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;当初刚刚接触Ubuntu的时候,我就很喜欢Unity桌面的全局菜单整合功能,🎊&lt;br&gt;可以把窗口标题和全局菜单整合为一体.&lt;br&gt;这样就可以节省一行显示标题的空间.&lt;/p&gt;</summary>
    
    
    
    <category term="Linux之路" scheme="http://yoursite.com/categories/Linux%E4%B9%8B%E8%B7%AF/"/>
    
    
    <category term="Arch" scheme="http://yoursite.com/tags/Arch/"/>
    
    <category term="Manjaro" scheme="http://yoursite.com/tags/Manjaro/"/>
    
    <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux安装VirtualBox</title>
    <link href="http://yoursite.com/2020/08/14/Linux%E5%AE%89%E8%A3%85VirtualBox/"/>
    <id>http://yoursite.com/2020/08/14/Linux%E5%AE%89%E8%A3%85VirtualBox/</id>
    <published>2020-08-14T08:47:55.000Z</published>
    <updated>2020-10-31T12:50:24.248Z</updated>
    
    <content type="html"><![CDATA[<p>昨天，我下载好了kali镜像后.<br>今天,反手就是一个条命令把VirtualBox安装好了,<br>结果可想而知🤣</p><a id="more"></a><p>安装的VirtualBox可以运行,但是就是不能启动里面的虚拟系统.<br>这就很令我发愁,本来因为是BIOS没有开启虚拟化.<br>经过排查并不是这个原因.🤔<br>后来才知道,需要安装对应内核版本的安装包,才行</p><h2 id="确定Linux内核版本"><a href="#确定Linux内核版本" class="headerlink" title="确定Linux内核版本"></a>确定Linux内核版本</h2><ul><li>安装对应内核版本的安装,需要查询但前实习使用的内核.</li><li>使用uname -r 命令即可查询<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo uname -r</span><br><span class="line">5.6.19-2-MANJARO</span><br></pre></td></tr></table></figure>表示需要安装linux内核版本为5.6</li></ul><h2 id="安装VirtualBox"><a href="#安装VirtualBox" class="headerlink" title="安装VirtualBox"></a>安装VirtualBox</h2><p>需要安装VirtualBox和扩展包,以及内核模块</p><ul><li>安装VirtualBox<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pacman -S virtualbox</span><br></pre></td></tr></table></figure></li><li>安装VirtualBox扩展包<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pacman -S virtualbox-ext-oracle</span><br></pre></td></tr></table></figure></li><li>安装内核模块<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pacman -S linux56-virtualbox-host-modules</span><br></pre></td></tr></table></figure><blockquote><p>Note: 安装内核模块,一定要和系统内核是一致的版本.不然可能无法启动.</p></blockquote></li></ul><h2 id="载入vboxdr模块"><a href="#载入vboxdr模块" class="headerlink" title="载入vboxdr模块"></a>载入vboxdr模块</h2><ul><li>重启系统模块会自动载入.</li><li>手动使用命令载入<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo modprobe vboxdrv</span><br></pre></td></tr></table></figure>如果是其他衍生系统,大致安装步骤也和这个差不多.如果是初学者,注意包管理器的不同哦.🤞🤞🤞</li></ul><p>完成这些,就可以在Linux下面愉快的玩耍啦.🎊🎊🎊</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;昨天，我下载好了kali镜像后.&lt;br&gt;今天,反手就是一个条命令把VirtualBox安装好了,&lt;br&gt;结果可想而知🤣&lt;/p&gt;</summary>
    
    
    
    <category term="Linux之路" scheme="http://yoursite.com/categories/Linux%E4%B9%8B%E8%B7%AF/"/>
    
    
    <category term="Arch" scheme="http://yoursite.com/tags/Arch/"/>
    
    <category term="Manjaro" scheme="http://yoursite.com/tags/Manjaro/"/>
    
    <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>qBittorrent下载加速</title>
    <link href="http://yoursite.com/2020/08/13/qBittorrent%E4%B8%8B%E8%BD%BD%E5%8A%A0%E9%80%9F/"/>
    <id>http://yoursite.com/2020/08/13/qBittorrent%E4%B8%8B%E8%BD%BD%E5%8A%A0%E9%80%9F/</id>
    <published>2020-08-13T03:10:05.000Z</published>
    <updated>2020-10-26T14:32:57.732Z</updated>
    
    <content type="html"><![CDATA[<p>Linux 下面如何下载Bittorrent的资源呢🤔🤔？？<br>如果是在Windows下面,迅雷🐦一般是第一选择．</p><a id="more"></a><p>今天，我试图下载Kali Linux 镜像的时候，发现官方提供了，BitTorrent下载方式．<br>我就打算在我的Linux 下面尝试一下．结果下载速度非常快😝</p><h2 id="安装qBittorrent"><a href="#安装qBittorrent" class="headerlink" title="安装qBittorrent"></a>安装qBittorrent</h2><p>qBittorrent是一个跨平台的自由BitTorrent客户端，其图形用户界面是由Qt所写成的．</p><blockquote><p>下载链接：<a href="https://www.qbittorrent.org/download.php">https://www.qbittorrent.org/download.php</a></p></blockquote><p>等待下载完成后，就可以安装啦．</p><h3 id="Arch系列"><a href="#Arch系列" class="headerlink" title="Arch系列"></a>Arch系列</h3><p>如果是Arch Linux ，或者是基于Arch Linux 的系统</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S qbittorrent</span><br></pre></td></tr></table></figure><p>可以使用上述命令直接安装．</p><h2 id="加入Tracker-服务器"><a href="#加入Tracker-服务器" class="headerlink" title="加入Tracker 服务器"></a>加入Tracker 服务器</h2><p>Tracker服务器，主要目的是为了，提升下载速度.</p><p>由于tracker对BT下载起到客户端协调和调控的重要作用，所以一旦被封锁会严重影响BT下载，如2009年12月，中华人民共和国广电总局对BTchina一系列的tracker进行打击，因此也促使新BT客户端支持DHT网络实现无中心tracker，分布式资源分享的影响<br>需要了解更多Tracker服务器，可以自行搜索．</p><h2 id="qBittorrent-添加tracker服务器"><a href="#qBittorrent-添加tracker服务器" class="headerlink" title="qBittorrent 添加tracker服务器"></a>qBittorrent 添加tracker服务器</h2><p><a href="/img/tra.png">添加tracker服务器</a></p><ul><li>点击Preferences</li><li>找到Bittorent选项</li><li>勾选　automatically add thes trackers to new downloads 选项</li><li>粘贴tracker服务器列表，即可点击apply</li></ul><blockquote><p>Note: qBittorrent添加完成tracker服务器后需要，重新启动软件．</p></blockquote><h2 id="tracker服务器列表"><a href="#tracker服务器列表" class="headerlink" title="tracker服务器列表"></a>tracker服务器列表</h2><ul><li>Best Tracker list:<blockquote><p>　<a href="https://trackerslist.com/best.txt">https://trackerslist.com/best.txt</a></p></blockquote></li><li>All Tracker list:<blockquote><p><a href="https://trackerslist.com/all.txt">https://trackerslist.com/all.txt</a></p></blockquote></li><li>Http(s) Tracker list:<blockquote><p><a href="https://trackerslist.com/http.txt">https://trackerslist.com/http.txt</a></p></blockquote></li></ul><p>这些是我日程使用的Tracker服务器列表，这个仓库列表，已有人发布到github仓库中．<br>这里我就不给出仓库连接了，在我的收藏的仓库中可以找到😝</p><p>关于Bittorent 就分享到这里吧，DHT的中文全称是分布式哈希表(distributed has table 的缩写)，这可以避免中心tracker服务器的不能工作而导致这个系统的瘫痪．是一些天才的杰作．</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Linux 下面如何下载Bittorrent的资源呢🤔🤔？？&lt;br&gt;如果是在Windows下面,迅雷🐦一般是第一选择．&lt;/p&gt;</summary>
    
    
    
    <category term="Linux之路" scheme="http://yoursite.com/categories/Linux%E4%B9%8B%E8%B7%AF/"/>
    
    
    <category term="Arch" scheme="http://yoursite.com/tags/Arch/"/>
    
    <category term="Manjaro" scheme="http://yoursite.com/tags/Manjaro/"/>
    
    <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Shell之处理命名参数</title>
    <link href="http://yoursite.com/2020/08/09/Shell%E4%B9%8B%E5%A4%84%E7%90%86%E5%91%BD%E5%90%8D%E5%8F%82%E6%95%B0/"/>
    <id>http://yoursite.com/2020/08/09/Shell%E4%B9%8B%E5%A4%84%E7%90%86%E5%91%BD%E5%90%8D%E5%8F%82%E6%95%B0/</id>
    <published>2020-08-09T02:51:43.000Z</published>
    <updated>2020-10-26T14:33:03.102Z</updated>
    
    <content type="html"><![CDATA[<p>今天练习了一下shell脚本，之前简单的学习啦shell脚本的语法。😅<br>刷了<a href="https://www.hackerrank.com/dashboard">HackerRank</a>的题目以后，发现还是不能很好的驾驭shell这把神剑。</p><a id="more"></a><p>于是，我决定闭关修炼😝<br>修炼过程中，我发现啦很多武林绝学🌻。令我感到非常的Amazing。<br>下面就来看看吧！！！</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">deploy=<span class="literal">false</span></span><br><span class="line">uglify=<span class="literal">false</span></span><br><span class="line"><span class="keyword">while</span>(( <span class="variable">$#</span> &gt; 1 ));</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="keyword">case</span> <span class="variable">$1</span> <span class="keyword">in</span></span><br><span class="line">    --deploy) deploy=<span class="string">"<span class="variable">$2</span>"</span>;;</span><br><span class="line">    --uglify) uglify=<span class="string">"<span class="variable">$2</span>"</span>;;</span><br><span class="line">    *) <span class="built_in">break</span>;</span><br><span class="line">   <span class="keyword">esac</span>; <span class="built_in">shift</span> 2</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$deploy</span> &amp;&amp; <span class="built_in">echo</span> <span class="string">"will deploy... deploy = <span class="variable">$deploy</span>"</span></span><br><span class="line"><span class="variable">$uglify</span> &amp;&amp; <span class="built_in">echo</span> <span class="string">"will uglify... uglify = <span class="variable">$uglify</span>"</span></span><br></pre></td></tr></table></figure><blockquote><p>Note: 最后两行，与&amp;&amp;的运算方式有关</p></blockquote><ul><li>$# 参数个数<h2 id="运行方式"><a href="#运行方式" class="headerlink" title="运行方式"></a>运行方式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash script.sh --deploy <span class="literal">true</span> --uglify <span class="literal">false</span></span><br></pre></td></tr></table></figure>true 和fasle 为输入值<h2 id="特殊变量"><a href="#特殊变量" class="headerlink" title="特殊变量"></a>特殊变量</h2><table><thead><tr><th>变量</th><th>含义</th></tr></thead><tbody><tr><td>$0</td><td>当前脚本的文件名</td></tr><tr><td>$n</td><td>传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例</td></tr><tr><td>$#</td><td>传递给脚本或函数的参数个数。</td></tr><tr><td>$*</td><td>传递给脚本或函数的所有参数。</td></tr><tr><td>$@</td><td>传递给脚本或函数的所有参数。被双引号(“ “)包含时，与 $* 稍有不同</td></tr><tr><td>$?</td><td>上个命令的退出状态，或函数的返回值。</td></tr><tr><td>$$</td><td>当前Shell进程ID。对于 Shell 脚本，就是这些脚本所在的进程ID。</td></tr></tbody></table></li></ul><h2 id="和-的区别"><a href="#和-的区别" class="headerlink" title="$@和$*的区别"></a>$@和$*的区别</h2><ul><li>不被双引号(“ “)包含时，都以”$1” “$2” … “$n” 的形式输出所有参数。</li><li>被双引号(“ “)包含时，</li><li><ul><li>“$*” 会将所有的参数作为一个整体，以”$1 $2 … $n”的形式输出所有参数；</li></ul></li><li><ul><li>“$@” 会将各个参数分开，以”$1” “$2” … “$n” 的形式输出所有参数(带换行输出)。</li></ul></li></ul><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"print each param from \$*"</span></span><br><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> $*</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"<span class="variable">$var</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"print each param from \$@"</span></span><br><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> <span class="variable">$@</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"<span class="variable">$var</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"print each param from \"\$*\""</span></span><br><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> <span class="string">"$*"</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"<span class="variable">$var</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"print each param from \"\$@\""</span></span><br><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> <span class="string">"<span class="variable">$@</span>"</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"<span class="variable">$var</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>今天，就先到这里吧!! </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天练习了一下shell脚本，之前简单的学习啦shell脚本的语法。😅&lt;br&gt;刷了&lt;a href=&quot;https://www.hackerrank.com/dashboard&quot;&gt;HackerRank&lt;/a&gt;的题目以后，发现还是不能很好的驾驭shell这把神剑。&lt;/p&gt;</summary>
    
    
    
    <category term="脚本" scheme="http://yoursite.com/categories/%E8%84%9A%E6%9C%AC/"/>
    
    
    <category term="Arch" scheme="http://yoursite.com/tags/Arch/"/>
    
    <category term="Manjaro" scheme="http://yoursite.com/tags/Manjaro/"/>
    
    <category term="Shell" scheme="http://yoursite.com/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>List和Tuple</title>
    <link href="http://yoursite.com/2020/08/02/List%E5%92%8CTuple/"/>
    <id>http://yoursite.com/2020/08/02/List%E5%92%8CTuple/</id>
    <published>2020-08-02T02:05:56.000Z</published>
    <updated>2020-10-26T14:32:45.595Z</updated>
    
    <content type="html"><![CDATA[<p>之前写了，学习了基本数据类型。今天就该学习List了</p><a id="more"></a><h2 id="List（列表）"><a href="#List（列表）" class="headerlink" title="List（列表）"></a>List（列表）</h2><p>List是Python 内置的一种数据类型。<br>他是一种有序的集合，可以随时添加和删除其中的元素</p><h3 id="创建列表"><a href="#创建列表" class="headerlink" title="创建列表"></a>创建列表</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name = [<span class="string">'Linux'</span>,<span class="string">'arch'</span>,<span class="string">'kernel'</span>,<span class="string">'manjaro'</span>]</span><br></pre></td></tr></table></figure><ul><li>列表元素不一定是相同的元素。</li><li>使用print可以直接打印。</li></ul><h3 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h3><ul><li>通过索引来访问<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(name[<span class="number">2</span>])</span><br></pre></td></tr></table></figure></li><li>通过方括号的形式来截取列表中的元素<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(name[<span class="number">0</span>:<span class="number">2</span>]) <span class="comment">#左闭右开</span></span><br></pre></td></tr></table></figure></li><li>左索引缺省为0<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(name[:<span class="number">2</span>])</span><br></pre></td></tr></table></figure></li><li>右索引缺省为列表最后一个<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(name[<span class="number">1</span>:])</span><br></pre></td></tr></table></figure></li></ul><h3 id="更新元素"><a href="#更新元素" class="headerlink" title="更新元素"></a>更新元素</h3><p>对索引直接赋值，就可以</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name[<span class="number">2</span>]=<span class="string">'archkernel'</span></span><br></pre></td></tr></table></figure><h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><p>使用append()方法来添加</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name.append(<span class="string">'ubuntu'</span>) <span class="comment">#元素添加到列表末尾</span></span><br></pre></td></tr></table></figure><h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p>使用del语句来删除列表的元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">del</span> name[<span class="number">2</span>] <span class="comment">#删除位置的以后索引的元素自动先前填充</span></span><br></pre></td></tr></table></figure><h3 id="List运算符"><a href="#List运算符" class="headerlink" title="List运算符"></a>List运算符</h3><table><thead><tr><th>Python 表达式</th><th align="left">结果</th><th>描述</th></tr></thead><tbody><tr><td>len([1, 2, 3])</td><td align="left">3</td><td>计算元素个数</td></tr><tr><td>[1, 2, 3] + [4, 5, 6]</td><td align="left">[1, 2, 3, 4, 5, 6]</td><td>组合</td></tr><tr><td>[‘Hi!’] * 4</td><td align="left">[‘Hi!’, ‘Hi!’, ‘Hi!’, ‘Hi!’]</td><td>复制</td></tr><tr><td>3 in [1, 2, 3]</td><td align="left">True</td><td>元素是否存在于列表中</td></tr><tr><td>for x in [1, 2, 3]: print x,</td><td align="left">1 2 3</td><td>迭代</td></tr></tbody></table><h3 id="List函数"><a href="#List函数" class="headerlink" title="List函数"></a>List函数</h3><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>max(list)</td><td>返回列表元素最大值</td></tr><tr><td>min(list)</td><td>返回列表元素最小值</td></tr><tr><td>list(seq)</td><td>将元组转换为列表</td></tr><tr><td>list.append(obj)</td><td>在列表末尾添加新的对象</td></tr><tr><td>list.count(obj)</td><td>统计某个元素在列表中出现的次数</td></tr><tr><td>list.extend(seq)</td><td>在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）</td></tr><tr><td>list.index(obj)</td><td>从列表中找出某个值第一个匹配项的索引位置”</td></tr><tr><td>list.insert(index, obj)</td><td>将对象插入列表</td></tr><tr><td>list.pop(obj=list[-1])</td><td>移除列表中的一个元素（默认最后一个元素），并且返回该元素的值</td></tr><tr><td>list.remove(obj)</td><td>移除列表中的一个元素（参数是列表中元素），并且不返回任何值}</td></tr><tr><td>list.reverse()</td><td>反向列表中元素</td></tr><tr><td>list.sort([func])</td><td>对原列表进行排序</td></tr></tbody></table><h2 id="Tuple-元组"><a href="#Tuple-元组" class="headerlink" title="Tuple (元组)"></a>Tuple (元组)</h2><p>tuple一旦初始化就不能修改。</p><h3 id="创建元组"><a href="#创建元组" class="headerlink" title="创建元组"></a>创建元组</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tuple=(<span class="string">'Linux'</span>,<span class="string">'arch'</span>,<span class="string">'kernel'</span>,<span class="string">'manjaro'</span>)</span><br></pre></td></tr></table></figure><p>创建空元组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tuple=()</span><br></pre></td></tr></table></figure><blockquote><p>Note: 创建元组中只包含一个元素时，需要在元素后面添加逗号。避免产生歧义。</p></blockquote><h3 id="访问元组"><a href="#访问元组" class="headerlink" title="访问元组"></a>访问元组</h3><p>访问方式和List一样👋</p><h3 id="修改元组"><a href="#修改元组" class="headerlink" title="修改元组"></a>修改元组</h3><p>可以对元组进行连接组合，而打到修改元组内容的🤗。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">list1=[<span class="number">123</span>,<span class="number">456</span>]</span><br><span class="line">tuple1=(<span class="string">'两点水'</span>,<span class="string">'twowater'</span>,<span class="string">'liangdianshui'</span>,list1)</span><br><span class="line">print(tuple1)</span><br><span class="line">list1[<span class="number">0</span>]=<span class="number">789</span></span><br><span class="line">list1[<span class="number">1</span>]=<span class="number">100</span></span><br><span class="line">print(tuple1)</span><br></pre></td></tr></table></figure><p>这样就可通过修改List，而达到修改Tuple的目的。</p><blockquote><p>Note: Tuple一开始指向list，修改list的内容，并没有改变别指向。</p></blockquote><h3 id="删除元组"><a href="#删除元组" class="headerlink" title="删除元组"></a>删除元组</h3><p>与List一致，使用del语句。但是不能单独删除单个元素，因为不可变。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">del</span> tuple</span><br></pre></td></tr></table></figure><h3 id="元组运算符"><a href="#元组运算符" class="headerlink" title="元组运算符"></a>元组运算符</h3><p>元组之间可以使用 + 号和 * 号进行运算。这就意味着他们可以组合和复制，运算后会生成一个新的元组。</p><table><thead><tr><th>Python表达式</th><th>结果</th><th>描述</th></tr></thead><tbody><tr><td>len((1, 2, 3))</td><td>3</td><td>计算元素个数</td></tr><tr><td>(1, 2, 3) + (4, 5, 6)</td><td>(1, 2, 3, 4, 5, 6)</td><td>连接</td></tr><tr><td>(‘Hi!’,) * 4</td><td>(‘Hi!’, ‘Hi!’, ‘Hi!’, ‘Hi!’)</td><td>复制</td></tr><tr><td>3 in (1, 2, 3)</td><td>True</td><td>元素是否存在</td></tr><tr><td>for x in (1, 2, 3): print(x)</td><td>1 2 3</td><td>迭代</td></tr></tbody></table><h3 id="元组内置函数"><a href="#元组内置函数" class="headerlink" title="元组内置函数"></a>元组内置函数</h3><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>len(tuple)</td><td>计算元组元素个数</td></tr><tr><td>max(tuple)</td><td>返回元组中元素最大值</td></tr><tr><td>min(tuple)</td><td>返回元组中元素最小值</td></tr><tr><td>tuple(seq)</td><td>将列表转换为元组</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前写了，学习了基本数据类型。今天就该学习List了&lt;/p&gt;</summary>
    
    
    
    <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
    <category term="编程语言" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="脚本" scheme="http://yoursite.com/tags/%E8%84%9A%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>Manjaro连接隐藏WIFI</title>
    <link href="http://yoursite.com/2020/07/30/Manjaro%E8%BF%9E%E6%8E%A5%E9%9A%90%E8%97%8FWIFI/"/>
    <id>http://yoursite.com/2020/07/30/Manjaro%E8%BF%9E%E6%8E%A5%E9%9A%90%E8%97%8FWIFI/</id>
    <published>2020-07-30T14:17:57.000Z</published>
    <updated>2020-10-26T14:32:49.182Z</updated>
    
    <content type="html"><![CDATA[<p>今天远行，但是高铁晚点啦几分钟。我又很饿🤗。我就非常的不开心。<br>现在我已经到达了，目的地。<br>于是乎我开启了我的电脑，想要上上网～～～</p><a id="more"></a><p>可是wifi是隐藏的，也就是说没有广播SSID。这对于我来说，是一个大问题。<br>因为我以前就遇到啦这个问题，但是我利用啦曲线救国。我就直接改了路由器的设置，开启啦SSID广播。<br>不过，这个我懒得捣腾啦。🤣</p><p>我决定好好，看看官方的Wiki了。<br>巧了官方还针给出啦，连接隐藏wifi的方案！！！<br>不过，填写SSID的时候需要加入单引号，才能连接成功，不然会提示SSID找不到</p><blockquote><p><a href="https://wiki.archlinux.org/index.php/NetworkManager_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">https://wiki.archlinux.org/index.php/NetworkManager_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)</a></p></blockquote><p>官方wiki都很详细，我就不多说啦。我只记录官方没有说明的一些细节部分。🤪<br>今天就到这里吧！！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天远行，但是高铁晚点啦几分钟。我又很饿🤗。我就非常的不开心。&lt;br&gt;现在我已经到达了，目的地。&lt;br&gt;于是乎我开启了我的电脑，想要上上网～～～&lt;/p&gt;</summary>
    
    
    
    <category term="Linux之路" scheme="http://yoursite.com/categories/Linux%E4%B9%8B%E8%B7%AF/"/>
    
    
    <category term="Arch" scheme="http://yoursite.com/tags/Arch/"/>
    
    <category term="Manjaro" scheme="http://yoursite.com/tags/Manjaro/"/>
    
    <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
</feed>
