<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jankin&#39;s Blog</title>
  
  
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-11-23T07:26:52.644Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Jankin Huang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>基本排序算法</title>
    <link href="http://yoursite.com/2020/11/22/%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2020/11/22/%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</id>
    <published>2020-11-22T12:18:22.000Z</published>
    <updated>2020-11-23T07:26:52.644Z</updated>
    
    <content type="html"><![CDATA[<p>半个月没写博客了，两个星期前结束了HMTL课程。然后就考完试了，终于不用上这么无聊的课程了。<br>博客有时间还是要坚持写的，今天就开始吧。</p><a id="more"></a><p>今天就来看看，下面这些基本算法吧！ </p><h2 id="Selection-Sort"><a href="#Selection-Sort" class="headerlink" title="Selection-Sort"></a>Selection-Sort</h2><ul><li>选择排序。</li><li>时间复杂度O(n^2)、空间复杂度O(1)。</li><li>采用双重遍历，内层遍历没次寻找[i,n)区间里的最小值<br>然后，与第i个元素进行交换( [0,i) 区间为有序序列)。</li><li>图解如下：<br><img src="/img/selection-sort.jpg" alt="Selection-Sort"></li><li>代码如下：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++)&#123;</span><br><span class="line">        <span class="comment">// 寻找[i, n)区间里的最小值</span></span><br><span class="line">        <span class="keyword">int</span> minIndex = i;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j = i + <span class="number">1</span> ; j &lt; n ; j ++ )</span><br><span class="line">            <span class="keyword">if</span>( arr[j] &lt; arr[minIndex] )</span><br><span class="line">                minIndex = j;</span><br><span class="line">        swap( arr[i] , arr[minIndex] );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Insertion-Sort"><a href="#Insertion-Sort" class="headerlink" title="Insertion-Sort"></a>Insertion-Sort</h2></li><li>插入排序。</li><li>时间复杂度O(n^2)、空间复杂度O(1);</li><li>采用双重遍历，单独看最左边的原始为有序(任意一个单独的元素都为有序序列)。选择该元素的下一元素，插入到前面的有序序列中，是该序列依旧有序。</li><li>图解如下：<br><img src="/img/insertion-sort.jpg" alt="Insertion-Sort"></li><li>代码如下：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(T arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n ; i ++ ) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 寻找元素arr[i]合适的插入位置</span></span><br><span class="line">        <span class="comment">//[0,i-1)区间为有序序列，[i-1,n) 为待遍历序列。</span></span><br><span class="line">       <span class="keyword">for</span>( <span class="keyword">int</span> j = i ; j &gt; <span class="number">0</span> ; j-- )</span><br><span class="line">           <span class="keyword">if</span>( arr[j] &lt; arr[j<span class="number">-1</span>] )</span><br><span class="line">               swap( arr[j] , arr[j<span class="number">-1</span>] );</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Bubble-Sort"><a href="#Bubble-Sort" class="headerlink" title="Bubble-Sort"></a>Bubble-Sort</h2></li><li>冒泡排序 (这个好熟悉呀)</li><li>时间复杂度O(n^2)、空间复杂度O(1);</li><li>采用双重遍历，每次内层需要寻找最大的元素，使该元素沉到数组尾部(有序序列的最前面)。</li><li>图解如下：<br><img src="/img/bubble-sort.jpg" alt="Bubble-Sort"></li><li>代码如下：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bubble</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span>; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span> ; ++j)</span><br><span class="line">            <span class="keyword">if</span>(nums[j]  &gt;  nums[j + <span class="number">1</span>])</span><br><span class="line">                swap(nums[j],nums[j+<span class="number">1</span>]); </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Shell-Sort"><a href="#Shell-Sort" class="headerlink" title="Shell-Sort"></a>Shell-Sort</h2></li><li>希尔排序 (日常见的比较少)。</li><li>时间复杂度O(n^1.3) 空间复杂度O(1)。</li><li>希尔排序又称缩小增量排序，基于插入排序。基本思想是划分多组分别进行插入排序。</li><li>图解如下：<br><img src="/img/shell-sort.jpg" alt="Shell-Sort"></li><li>代码如下:<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//增量gap，并逐步缩小增量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> gap = arr.<span class="built_in">size</span>() / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//从第gap个元素，逐个对其所在组进行直接插入排序操作</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; arr.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line">            <span class="keyword">while</span> (j - gap &gt;= <span class="number">0</span> &amp;&amp; arr[j] &lt; arr[j - gap])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//插入排序采用交换法</span></span><br><span class="line">                swap(arr, j, j - gap);</span><br><span class="line">                j -= gap;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>基本排序算法时间复杂度基本都是O(n^2)，shell-sort时间复杂度度也达不到O(n)。🙄</p><p>今天就到这里吧～～～ bye.💝</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;半个月没写博客了，两个星期前结束了HMTL课程。然后就考完试了，终于不用上这么无聊的课程了。&lt;br&gt;博客有时间还是要坚持写的，今天就开始吧。&lt;/p&gt;</summary>
    
    
    
    
    <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
    <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>STL容器分类</title>
    <link href="http://yoursite.com/2020/11/09/STL%E5%AE%B9%E5%99%A8%E5%88%86%E7%B1%BB/"/>
    <id>http://yoursite.com/2020/11/09/STL%E5%AE%B9%E5%99%A8%E5%88%86%E7%B1%BB/</id>
    <published>2020-11-09T08:51:16.000Z</published>
    <updated>2020-11-09T08:51:16.580Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux相关网络命令</title>
    <link href="http://yoursite.com/2020/11/08/Linux%E7%9B%B8%E5%85%B3%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2020/11/08/Linux%E7%9B%B8%E5%85%B3%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4/</id>
    <published>2020-11-08T12:36:23.000Z</published>
    <updated>2020-11-08T12:53:06.586Z</updated>
    
    <content type="html"><![CDATA[<p>搞了几天运动会，今天才意识到计算机网络的实验报告还没有写完。不过上实验课程的时候，我都把命令敲过了一篇(ping,ipconfig,arp,netstat)。<del>这些我以前就玩过，有点无聊</del></p><a id="more"></a><p>今天，我在linux下面敲这些命令的时候发现有些命令找不到。😭<br>我就查了一下🤔<del>热爱学习的我</del></p><h2 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h2><p>在Windows默认ping 4次。而在Linux下面需要用-c指定次数。</p><h2 id="ipconfig"><a href="#ipconfig" class="headerlink" title="ipconfig"></a>ipconfig</h2><p>可以使用ifconfig，不过有些版本的linux这个命令被取代了。需要是ip address show，就可以查看相关网络配置。</p><h2 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h2><p>地址解析协议，玩过kali局网攻击的话。就很熟悉啦！<br>这个命令在linux下面一样没有，代替命令是ip neighbor会列出 IP 对应的MAC地址。</p><h2 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h2><p>这个命令听说linux系统自带有，不过我的linux版本没有。只有默认的ss(Socket Statistics)命令。加入-t显示IP/TCP相关的信息</p><p>一个小小的命令记录。bye～～～</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;搞了几天运动会，今天才意识到计算机网络的实验报告还没有写完。不过上实验课程的时候，我都把命令敲过了一篇(ping,ipconfig,arp,netstat)。&lt;del&gt;这些我以前就玩过，有点无聊&lt;/del&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Linux之路" scheme="http://yoursite.com/categories/Linux%E4%B9%8B%E8%B7%AF/"/>
    
    
    <category term="Arch" scheme="http://yoursite.com/tags/Arch/"/>
    
    <category term="Manjaro" scheme="http://yoursite.com/tags/Manjaro/"/>
    
    <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>C++Lambda表达式</title>
    <link href="http://yoursite.com/2020/11/06/C-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/11/06/C-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2020-11-06T12:59:34.000Z</published>
    <updated>2020-11-06T13:19:13.578Z</updated>
    
    <content type="html"><![CDATA[<p>今天的每日一题，也是比较简单的！🎊<br>但我，查看官方题解时，我惊呆了。</p><a id="more"></a><p>我看到了如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sort(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), [&amp;](<span class="keyword">int</span> x, <span class="keyword">int</span> y) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bit</span>[x] &lt; <span class="built_in">bit</span>[y])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bit</span>[x] &gt; <span class="built_in">bit</span>[y])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x &lt; y;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我看了半天，没反应过来🤣，看完评论才知道是C++11 的新特性 Lambda表达式。</p><h2 id="Lambda表达式形式"><a href="#Lambda表达式形式" class="headerlink" title="Lambda表达式形式"></a>Lambda表达式形式</h2><blockquote><p>[外部变量访问说明符](参数列表)-&gt;返回值类型{</p><p>语句块</p><p>}</p></blockquote><ul><li>外部访问方式： =表示允许修改外部变量，&amp;不允许修改外部变量</li><li>参数列表：和普通函数一样</li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><ul><li>代码：<pre><code class="C++"><span class="keyword">int</span> a[<span class="number">4</span>] = {<span class="number">11</span>, <span class="number">2</span>, <span class="number">33</span>, <span class="number">4</span>};sort(a, a+<span class="number">4</span>, [=](<span class="keyword">int</span> x, <span class="keyword">int</span> y) -&gt; <span class="keyword">bool</span> {   <span class="keyword">return</span> x%<span class="number">10</span> &lt; y%<span class="number">10</span>;   } );for_each(a, a+<span class="number">4</span>, [=](<span class="keyword">int</span> x) {   <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">" "</span>;   } );</code></pre></li><li>结果： 11 2 33 4</li></ul><h2 id="外部变量"><a href="#外部变量" class="headerlink" title="外部变量"></a>外部变量</h2><ul><li>“外部变量访问方式说明符”还可以有更加复杂和灵活的用法。</li><li>[=, &amp;x, &amp;y]表示外部变量 x、y 的值可以被修改，其余外部变量不能被修改；</li><li>[&amp;, x, y]表示除 x、y 以外的外部变量，值都可以被修改。</li></ul><h2 id="Lambda表达式作用"><a href="#Lambda表达式作用" class="headerlink" title="Lambda表达式作用"></a>Lambda表达式作用</h2><ul><li><p>使用 STL 时，往往会大量用到函数对象，为此要编写很多函数对象类。有的函数对象类只用来定义了一个对象，而且这个对象也只使用了一次，编写这样的函数对象类就有点浪费。</p></li><li><p>说白了，就使用便捷👋</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天的每日一题，也是比较简单的！🎊&lt;br&gt;但我，查看官方题解时，我惊呆了。&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
    <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
    <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>我与Linux的爱恨情仇</title>
    <link href="http://yoursite.com/2020/11/02/%E6%88%91%E7%9A%84Linux/"/>
    <id>http://yoursite.com/2020/11/02/%E6%88%91%E7%9A%84Linux/</id>
    <published>2020-11-02T07:53:30.000Z</published>
    <updated>2020-11-02T08:59:59.145Z</updated>
    
    <content type="html"><![CDATA[<p>我与你第一次相遇，是在2016年。那个时候作为电脑小白的我，带着好奇心把你安装到了我电脑上，那个时候你叫Ubuntu16.04。💝</p><a id="more"></a><p>安装完成后，我失去是我的磁盘原有的所有数据🤔。我当时以为，你的安装方式和Windows是一样的。谁能想到你独吞我整个硬盘，使用你不到一天的时间，我就把Windows给重新安装上了。🤣</p><h2 id="我与Linux爱恨"><a href="#我与Linux爱恨" class="headerlink" title="我与Linux爱恨"></a>我与Linux爱恨</h2><p>后来，和你的见面方式都是在VMware里面了；你就没有单独存在于我的物理机里面。<br>在VMware里面，我尝试过很多的Linux系统。有CentOS、Redhat、Fedora；真正第一次认真敲入命令是在CentOS里面。那个时候，跟着教程一步一步的敲入命令。刚刚开始的时候，还经常敲错。😭</p><p>2018年，我遇到到一个IDE(Android Studio)，体会到什么叫编码两分钟，编译两小时(<del>其实是自己电脑太卡，联想G400</del>)的感觉。<br>每当我有空闲时间的时候，我都会打开浏览器。看看有没有什么可以优化编译的方法，的确通过修改Android Studio的一些配置可以加快编译。但是作用不是很大。🙄，还看到了很多关于Linux对硬件性能低的博客。</p><h2 id="我的Linux时代"><a href="#我的Linux时代" class="headerlink" title="我的Linux时代"></a>我的Linux时代</h2><p>2018年的冬天，我就在我的物理机里面安装Fedora系统。当时我还在我的VMware里面体验过，感觉不错。<br>可是，在实际中出现了几个问题。</p><ul><li>使用的人比较少，出了问题比较难解决。</li><li>我在安装51编译库的时候，发现编译工具的名称尽然不同。(<del>当时想骂人</del>)</li><li>对于国内用户QQ是非常重要的，Fedora安装QQ是比较困难的。</li></ul><p>用了不到一个星期。我就从Fedora，步入了Arch魔教的阵营(现在我新买的电脑上用Manjaro(基于arch开发的))。</p><p>从2018年到现在，我已经习惯了Linux的简洁和高效。<br>对于Linux，我喜欢一下几点 </p><ul><li>一切皆文件</li><li>拥有Root，拥有一切</li><li>一条命令，安装需要的软件。(next..next..next 不存在的)</li><li>我可以任意修改所有文件，达到我想要的效果。</li><li>我可以任意改动我的桌面布局，不需要安装任何额外的软件。</li><li>我可以切换不同的桌面环境。</li></ul><h2 id="我的Linux软件"><a href="#我的Linux软件" class="headerlink" title="我的Linux软件"></a>我的Linux软件</h2><p>下面说说，我日常使用哪些软件。</p><h3 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h3><ul><li>Micosoft Edge  (刚刚从chromuim切换过来)</li><li>安装方式<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 目前没有人打包到AUR仓库，需要自己下载.deb包，然后转化。在安装</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="编程工具"><a href="#编程工具" class="headerlink" title="编程工具"></a>编程工具</h3><h4 id="Android-开发"><a href="#Android-开发" class="headerlink" title="Android 开发"></a>Android 开发</h4><ul><li>Android Studio </li><li>安装方式<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pacman -S android-studio</span><br></pre></td></tr></table></figure></li></ul><h4 id="Java开发"><a href="#Java开发" class="headerlink" title="Java开发"></a>Java开发</h4><ul><li>IntelliJ idea 社区版</li><li>安装方式<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pacman -S intellij-idea-community-edition</span><br></pre></td></tr></table></figure></li></ul><h4 id="C-开发"><a href="#C-开发" class="headerlink" title="C++开发"></a>C++开发</h4><ul><li>Visual Studio Code</li><li>这个编辑器结合插件非常好用，我写博客也是用这个</li><li>安装方式<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pacman -S visual-stduio-code-bin</span><br></pre></td></tr></table></figure></li></ul><h3 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h3><h4 id="VirtualBox"><a href="#VirtualBox" class="headerlink" title="VirtualBox"></a>VirtualBox</h4><ul><li>安装方式，看我以前写的如何安装Virtualbox的博客<h4 id="VMware（需要激活）"><a href="#VMware（需要激活）" class="headerlink" title="VMware（需要激活）"></a>VMware（需要激活）</h4></li><li>安装方式<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pacman -S vmware-workstation</span><br></pre></td></tr></table></figure>这个两个我都使用过，目前在使用vmware</li></ul><h3 id="通讯"><a href="#通讯" class="headerlink" title="通讯"></a>通讯</h3><h4 id="QQ"><a href="#QQ" class="headerlink" title="QQ"></a>QQ</h4><ul><li>使用deepin的wine运行的TIM</li><li>安装方式<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pacman -S deepin.com.qq.office</span><br></pre></td></tr></table></figure><h4 id="Evolution"><a href="#Evolution" class="headerlink" title="Evolution"></a>Evolution</h4></li><li>这是一个电子邮箱客户端(主要用来给老师和学委发作业之类的)</li><li>安装方式<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pacman -S evolution</span><br></pre></td></tr></table></figure></li></ul><h3 id="AUR-助手工具"><a href="#AUR-助手工具" class="headerlink" title="AUR 助手工具"></a>AUR 助手工具</h3><ul><li>用来安装AUR(Arch User Repository)仓库的软件</li><li>安装方式<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pacman -S yay</span><br></pre></td></tr></table></figure></li></ul><h3 id="音乐"><a href="#音乐" class="headerlink" title="音乐"></a>音乐</h3><ul><li>落雪音乐助手，一款开源软件</li><li>安装方式,需要自己下载.pacman的包，然后安装<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pacman -U *.pacman</span><br></pre></td></tr></table></figure></li><li>直接下载Appimage后缀的，可以自己运行。</li></ul><h3 id="office替代品"><a href="#office替代品" class="headerlink" title="office替代品"></a>office替代品</h3><ul><li>Micosoft office 的良好替代品</li><li>安装方式<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pacman -S wps-office</span><br></pre></td></tr></table></figure>今天就分享到这里吧，有些软件后续补上。🎊🎊</li></ul><p>希望，你也加入Linux</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我与你第一次相遇，是在2016年。那个时候作为电脑小白的我，带着好奇心把你安装到了我电脑上，那个时候你叫Ubuntu16.04。💝&lt;/p&gt;</summary>
    
    
    
    <category term="Linux之路" scheme="http://yoursite.com/categories/Linux%E4%B9%8B%E8%B7%AF/"/>
    
    
    <category term="Arch" scheme="http://yoursite.com/tags/Arch/"/>
    
    <category term="Manjaro" scheme="http://yoursite.com/tags/Manjaro/"/>
    
    <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>349.两个数组的交集</title>
    <link href="http://yoursite.com/2020/11/02/349-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/"/>
    <id>http://yoursite.com/2020/11/02/349-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/</id>
    <published>2020-11-02T07:07:19.000Z</published>
    <updated>2020-11-02T07:53:10.488Z</updated>
    
    <content type="html"><![CDATA[<p>今天的每日一题就很简单啦。🎊<br>今天就不废话了，直接上题目吧。</p><a id="more"></a><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>给定两个数组，编写一个函数来计算它们的交集。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><blockquote><p>输入：nums1 = [1,2,2,1], nums2 = [2,2]<br>输出：[2]</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul><li>最简单的方法，采用逐个比较。及nums1中的每个元素都与nums2中的每个元素进行比较，如果相等，这加入到容器中，再对容器进行去重就可以了。</li><li>代码如下<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">intersection</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums1.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums2.<span class="built_in">size</span>(); ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums1[i] == nums2[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    res.push_back(nums1[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator ite = unique(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        res.erase(ite, res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="更优解法"><a href="#更优解法" class="headerlink" title="更优解法"></a>更优解法</h2></li><li>官方解法<blockquote><p>如果两个数组是有序的，则可以使用双指针的方法得到两个数组的交集。</p><p>首先对两个数组进行排序，然后使用两个指针遍历两个数组。可以预见的是加入答案的数组的元素一定是递增的，为了保证加入元素的唯一性，我们需要额外记录变量 pre 表示上一次加入答案数组的元素。</p><p>初始时，两个指针分别指向两个数组的头部。每次比较两个指针指向的两个数组中的数字，如果两个数字不相等，则将指向较小数字的指针右移一位，如果两个数字相等，且该数字不等于 pre ，将该数字添加到答案并更新 pre 变量，同时将两个指针都右移一位。当至少有一个指针超出数组范围时，遍历结束。</p></blockquote></li></ul><p>今天题目就到这里吧！！ 这是我遇到比较简单的每日一题。🤪🤪🤪</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天的每日一题就很简单啦。🎊&lt;br&gt;今天就不废话了，直接上题目吧。&lt;/p&gt;</summary>
    
    
    
    <category term="修炼之路" scheme="http://yoursite.com/categories/%E4%BF%AE%E7%82%BC%E4%B9%8B%E8%B7%AF/"/>
    
    
    <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
    <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>381.O(1)插入删除和获取随机元</title>
    <link href="http://yoursite.com/2020/10/31/381-%E6%8F%92%E5%85%A5%E5%88%A0%E9%99%A4%E5%92%8C%E8%8E%B7%E5%8F%96%E9%9A%8F%E6%9C%BA%E5%85%83/"/>
    <id>http://yoursite.com/2020/10/31/381-%E6%8F%92%E5%85%A5%E5%88%A0%E9%99%A4%E5%92%8C%E8%8E%B7%E5%8F%96%E9%9A%8F%E6%9C%BA%E5%85%83/</id>
    <published>2020-10-31T12:20:10.000Z</published>
    <updated>2020-10-31T12:48:59.248Z</updated>
    
    <content type="html"><![CDATA[<p>我用了半天的时间，与上帝交换，只为换回你💝！<br>我午睡醒来，打开我的电脑。发现一块黑屏，只有一个鼠标，和左边的dock栏上的白色。<br>该来的总会来，这件事情还是发生！！</p><a id="more"></a><p>我的系统桌面KDE，终于不能用了。我花时间，把KDE换成了DDE(Deepin Desktop Environment)。<br>我也不知道什么原因，竟然不是很好用。有几个应用打不开，主要还是不适应DDE的风格。<br>我就又换回了KDE，安装过程倒是有些崎岖   。不过路边的风景也很美。</p><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>设计一个支持在平均 时间复杂度 O(1) 下， 执行以下操作的数据结构。</p><p>注意: 允许出现重复元素。</p><p>insert(val)：向集合中插入元素 val。<br>remove(val)：当 val 存在时，从集合中移除一个 val。<br>getRandom：从现有集合中随机获取一个元素。每个元素被返回的概率应该与其在集合中的数量呈线性相关。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><blockquote><p>// 初始化一个空的集合。</p><p>RandomizedCollection collection = new &gt; &gt; &gt; &gt; RandomizedCollection();</p><p>// 向集合中插入 1 。返回 true 表示集合不包含 1 。</p><p>collection.insert(1);</p><p>// 向集合中插入另一个 1 。返回 false 表示集合包含 1 。集合现在包含 [1,1] 。<br>collection.insert(1);</p><p>// 向集合中插入 2 ，返回 true 。集合现在包含 [1,1,2] 。</p><p>collection.insert(2);</p><p>// getRandom 应当有 2/3 的概率返回 1 ，1/3 的概率返回 2 。</p><p>collection.getRandom();</p><p>// 从集合中删除 1 ，返回 true 。集合现在包含 [1,2] 。</p><p>collection.remove(1);</p><p>// getRandom 应有相同概率返回 1 和 2 。</p><p>collection.getRandom();</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul><li>我的第一思路，还是用桶排序的方法，把需要插入的元素，插入到数组中。即array[val]++; （val为插入的元素）。遮掩插入和取出的时间复杂度都是O(1)，但是题目没有给出val的取值范围。如果动态变化数组，当val值大于array.size()时，需要移动数组，时间复杂度为O(n)。这显然有违背题目。😅</li><li>当我查看官方解法时，我发现我在STL上的盲区(<del>昨天说学，可是没学</del>)。</li><li>官方解法的思路是哈希表(C++中没有，需要自己实现。使用Map 和 Set就可以实现)。</li><li>代码如下：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomizedCollection</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;&gt; idx;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    RandomizedCollection() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        nums.push_back(val);</span><br><span class="line">        idx[val].insert(nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> idx[val].<span class="built_in">size</span>() == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes a value from the collection. Returns true if the collection contained the specified element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (idx.<span class="built_in">find</span>(val) == idx.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = *(idx[val].<span class="built_in">begin</span>());</span><br><span class="line">        nums[i] = nums.back();</span><br><span class="line">        idx[val].erase(i);</span><br><span class="line">        idx[nums[i]].erase(nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">            idx[nums[i]].insert(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (idx[val].<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            idx.erase(val);</span><br><span class="line">        &#125;</span><br><span class="line">        nums.pop_back();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get a random element from the collection. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nums[rand() % nums.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="更优解法"><a href="#更优解法" class="headerlink" title="更优解法"></a>更优解法</h2></li><li>这里涉及到我知识盲区😭😭😭，我就不写最优解法了。后期补上！！</li></ul><p>万圣节快乐，这是令人难忘的一天。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我用了半天的时间，与上帝交换，只为换回你💝！&lt;br&gt;我午睡醒来，打开我的电脑。发现一块黑屏，只有一个鼠标，和左边的dock栏上的白色。&lt;br&gt;该来的总会来，这件事情还是发生！！&lt;/p&gt;</summary>
    
    
    
    <category term="修炼之路" scheme="http://yoursite.com/categories/%E4%BF%AE%E7%82%BC%E4%B9%8B%E8%B7%AF/"/>
    
    
    <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
    <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>463.岛屿的周长</title>
    <link href="http://yoursite.com/2020/10/30/463-%E5%B2%9B%E5%B1%BF%E7%9A%84%E5%91%A8%E9%95%BF/"/>
    <id>http://yoursite.com/2020/10/30/463-%E5%B2%9B%E5%B1%BF%E7%9A%84%E5%91%A8%E9%95%BF/</id>
    <published>2020-10-30T09:02:25.000Z</published>
    <updated>2020-10-31T08:18:31.690Z</updated>
    
    <content type="html"><![CDATA[<p>在一个岛屿上生活，是我的梦想！😝</p><p>今天，leetcode给我这个机会。计算我岛屿的长度，但是他并没有给我这个岛。</p><a id="more"></a><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>给定一个包含 0 和 1 的二维网格地图，其中 1 表示陆地 0 表示水域。</p><p>网格中的格子水平和垂直方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。</p><p>岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><blockquote><p>输入:</p><p>[[0,1,0,0],</p><p>[1,1,1,0],</p><p>[0,1,0,0],</p><p> [1,1,0,0]]</p><p>输出: 16</p><p>解释: 它的周长是下面图片中的 16 个黄色的边：</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul><li>看到这题题目，我也没什么解题思路；就知道逐个去遍历，应该是可以解出来的。但是并没有清晰的编码思路。</li><li>对于一个陆地格子的每条边，它被算作岛屿的周长当且仅当这条边为网格的边界或者相邻的另一个格子为水域。 因此，我们可以遍历每个陆地格子，看其四个方向是否为边界或者水域，如果是，将这条边的贡献（即 11）加入答案 \textit{ans}ans 中即可。（官方解题思路）</li><li>官方提供的解题思路，就是遍历每一个正方形；然后看这个正方形的周围(右，下，左，上的遍历顺序，可以改变)时候有陆地或水域，如果有水域或者是网格的边缘，那周长就加1。</li><li>总时间复杂度为：O(4nm)=O(nm);空间复杂度：O(1)。</li><li>代码如下<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">islandPerimeter</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;grid)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].<span class="built_in">size</span>(); ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">int</span> tx = i + dx[k];</span><br><span class="line">                        <span class="keyword">int</span> ty = j + dy[k];</span><br><span class="line">                        <span class="keyword">if</span> (tx &lt; <span class="number">0</span> || tx &gt;= grid.<span class="built_in">size</span>() || ty &lt; <span class="number">0</span> || ty &gt;= grid[<span class="number">0</span>].<span class="built_in">size</span>() || !grid[tx][ty])</span><br><span class="line">                            cnt++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ans += cnt;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="更优解法"><a href="#更优解法" class="headerlink" title="更优解法"></a>更优解法</h2>这个就我点困难了(<del>这个题目，我也是看了官方的解释才懂的🤫</del>)，我后期补。最优解一定是有的！！</li></ul><p>对啦，祝大家万圣夜快乐🤪🤪🤪🤪</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在一个岛屿上生活，是我的梦想！😝&lt;/p&gt;
&lt;p&gt;今天，leetcode给我这个机会。计算我岛屿的长度，但是他并没有给我这个岛。&lt;/p&gt;</summary>
    
    
    
    <category term="修炼之路" scheme="http://yoursite.com/categories/%E4%BF%AE%E7%82%BC%E4%B9%8B%E8%B7%AF/"/>
    
    
    <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
    <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>1207.独一无二的出现次数</title>
    <link href="http://yoursite.com/2020/10/28/1207-%E7%8B%AC%E4%B8%80%E6%97%A0%E4%BA%8C%E7%9A%84%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0/"/>
    <id>http://yoursite.com/2020/10/28/1207-%E7%8B%AC%E4%B8%80%E6%97%A0%E4%BA%8C%E7%9A%84%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0/</id>
    <published>2020-10-28T11:42:05.000Z</published>
    <updated>2020-10-28T12:07:43.810Z</updated>
    
    <content type="html"><![CDATA[<p>今天，把个人博客的主题换了一个。没有以前那么好看了。但是访问速度提升了不少。以后，有时间的话。我还是打算美化一下，但是毕竟我不是搞前端的，个人博客对我而言就是拿来发发个人感想，记录个人生活的。<br>废话到这里🧑‍🔬，看题目吧～～～</p><a id="more"></a><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>给你一个整数数组 arr，请你帮忙统计数组中每个数的出现次数。</p><p>如果每个数的出现次数都是独一无二的，就返回 true；否则返回 false。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><blockquote><p>输入：arr = [1,2,2,1,1,3]</p><p>输出：true</p><p>解释：在该数组中，1 出现了 3 次，2 出现了 2 次，3 只出现了 1 次。没有两个数的出现次数相同。</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul><li><p>我看到这个题目，就想到了前一天，类似于桶排序的思路。<br>后面看到给出的数据范围，-1000&lt;= arr[i] &lt;= 1000，我就意识到了直接使用桶排序的思维是解决不了的(数组下标不能为负数)。😅</p></li><li><p>思考一会后，我想到了STL里面的Map（键值对的方式存储数据）。这里的键是一个泛型(这就可以解决直接使用数组，下标不能为负数的情况)，接着在使用桶排序的思想，对map里面的值进行统计。再判断统计数据的值是否大于1,如果大于一这出现了重复次数的数字。🎊🎊🎊🎊🎊(<del>撒花，掌声</del>)</p></li><li><p>时间复杂度约为O(3n),其实一般成为O(n);空间复杂度约为O(2n),也可以称作O(n)。</p></li><li><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">uniqueOccurrences</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;arr)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : arr)</span><br><span class="line">        &#123;</span><br><span class="line">            m[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">int</span> aux[<span class="number">1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : m)</span><br><span class="line">        &#123;</span><br><span class="line">            aux[i.second]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (aux[i] &gt; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id="更优解法"><a href="#更优解法" class="headerlink" title="更优解法"></a>更优解法</h2><p>无独有偶，在题目的评论区也有一个很有意思的解法。👋👋<br>作者是使用了STL库中的Map 和 Set。(当初我也有这想法，只是我对STL库不是用了解，<del>看来需要好好学习STL库呀</del>)</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">uniqueOccurrences</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.<span class="built_in">size</span>();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            m[arr[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;times;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> p:m)</span><br><span class="line">            times.insert(p.second);</span><br><span class="line">        <span class="keyword">return</span> times.<span class="built_in">size</span>()==m.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这段代码的帅气程度快要赶上我了（<del>不要脸</del>）🤞🤞🤞🎊🎊🎊</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天，把个人博客的主题换了一个。没有以前那么好看了。但是访问速度提升了不少。以后，有时间的话。我还是打算美化一下，但是毕竟我不是搞前端的，个人博客对我而言就是拿来发发个人感想，记录个人生活的。&lt;br&gt;废话到这里🧑‍🔬，看题目吧～～～&lt;/p&gt;</summary>
    
    
    
    <category term="修炼之路" scheme="http://yoursite.com/categories/%E4%BF%AE%E7%82%BC%E4%B9%8B%E8%B7%AF/"/>
    
    
    <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
    <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>1365.有多少小于当前数字的数字</title>
    <link href="http://yoursite.com/2020/10/26/1365-%E6%9C%89%E5%A4%9A%E5%B0%91%E5%B0%8F%E4%BA%8E%E5%BD%93%E5%89%8D%E6%95%B0%E5%AD%97%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>http://yoursite.com/2020/10/26/1365-%E6%9C%89%E5%A4%9A%E5%B0%91%E5%B0%8F%E4%BA%8E%E5%BD%93%E5%89%8D%E6%95%B0%E5%AD%97%E7%9A%84%E6%95%B0%E5%AD%97/</id>
    <published>2020-10-26T13:55:35.000Z</published>
    <updated>2020-10-28T12:09:21.143Z</updated>
    
    <content type="html"><![CDATA[<p>有几个月没有写博客，这段时间都是在刷leetcode去啦。今天刷完，才想起来我还有博客。🙃开启每日一题吧！ 加油🦤🦤🦤</p><a id="more"></a><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>给你一个数组 nums，对于其中每个元素 nums[i]，请你统计数组中比它小的所有数字的数目。<br>换而言之，对于每个 nums[i] 你必须计算出有效的 j 的数量，其中 j 满足 j != i 且 nums[j] &lt; nums[i] 。<br>以数组形式返回答案。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><blockquote><p>输入：nums = [8,1,2,2,3]</p><p>输出：[4,0,1,1,3]</p><p>解释：</p><p>对于 nums[0]=8 存在四个比它小的数字：（1，2，2 和 3）。 </p><p>对于 nums[1]=1 不存在比它小的数字。</p><p>对于 nums[2]=2 存在一个比它小的数字：（1）。 </p><p>对于 nums[3]=2 存在一个比它小的数字：（1）。 </p><p>对于 nums[4]=3 存在三个比它小的数字：（1，2 和 2）。</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul><li>第一想法，是对整个nums数组进行排序.nums[i]的元素就会有i个比它小的元素(包含重复的，不符合题意要求，去要出去重复的)。<br>但是，后来仔细一看题目。发现，这样会打破输入数组的序列。</li><li>第二想法，是通过两个索引遍历整个数组。即每个元素和其他元素做比较，如果nums[i] &gt; nums[j]，则计数加一。比较完成后再存入结果数组中。</li><li>时间复杂度是O(n^2),空间复杂度为O(n);</li><li>代码如下：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">smallerNumbersThanCurrent</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.<span class="built_in">size</span>(); ++j)</span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (nums.at(i) &gt; nums.at(j))</span><br><span class="line">                &#123;</span><br><span class="line">                    num++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id="更优解法"><a href="#更优解法" class="headerlink" title="更优解法"></a>更优解法</h2><p>当我提交完代后，我看了一下评论区。<br>可谓是藏龙卧虎呀！！</p><ul><li>整个代码设计的非常巧妙,采用类似于桶排序的思路</li><li>先生成最大数组的大小的长度(题目给出了测试数据集的范围)</li><li>然后，对整个nums数组进行计数</li><li>在计算第i个元素，前i个的数量(arr 数组元素越靠后，对应nums里的元素越大)</li><li>在通过nums数组，获取与nums对应的元素值，存入vector。</li><li>代码如下：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">smallerNumbersThanCurrent</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> arr[<span class="number">101</span>];</span><br><span class="line">        <span class="built_in">memset</span>(arr, <span class="number">0</span>, <span class="keyword">sizeof</span>(arr));</span><br><span class="line">        <span class="comment">// 初始化计数桶</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : nums) &#123;</span><br><span class="line">            arr[i] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 累加处理计数桶，使得 arr[i] 表示比 i 小的数字的个数</span></span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i ++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">            arr[i] = cnt;</span><br><span class="line">            cnt += temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">        <span class="comment">// 遍历 nums，取出对应桶 arr[i] 里的结果即可</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">            ret.push_back(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>可以基于这个代码进行下一步的优化，但是时间复杂度大致还是O(n)级别。<br>方法是提前结束循环。😝</li></ul><p>今天的每日一题就到这里吧🎊</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;有几个月没有写博客，这段时间都是在刷leetcode去啦。今天刷完，才想起来我还有博客。🙃开启每日一题吧！ 加油🦤🦤🦤&lt;/p&gt;</summary>
    
    
    
    <category term="修炼之路" scheme="http://yoursite.com/categories/%E4%BF%AE%E7%82%BC%E4%B9%8B%E8%B7%AF/"/>
    
    
    <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
    <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Konsole无法启动</title>
    <link href="http://yoursite.com/2020/08/30/Konsole%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8/"/>
    <id>http://yoursite.com/2020/08/30/Konsole%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8/</id>
    <published>2020-08-30T03:11:45.000Z</published>
    <updated>2020-10-26T14:32:37.098Z</updated>
    
    <content type="html"><![CDATA[<p>前几天，想实现打开终端自动显示系统相关信息。<br>于是我就在修改了 Konsole Profile 的 Command 加入了一个命令。<br>结果，konsole都打不开啦。</p><a id="more"></a><p>这就非常尴尬啦，需要改回Profile 需要先打开konsole 才行呀😝。<br>可是，现在就是打不开。</p><p>纵然寻他千百度 打开百度已掉进黑灯瞎火处。<br>这就是我不喜欢用百度的原因，啥都查不到。(啥都没有也敢叫百度呀！！)</p><p>“一切皆文件”,这条Linux哲学。在我脑海中呈现🤔。<br>我顿悟，我找到Konsole的配置文件，不久可以改回来啦吗？<br>根本就不需要图形界面的Profile呀！！</p><h2 id="Konsole-profile-配置文件"><a href="#Konsole-profile-配置文件" class="headerlink" title="Konsole profile 配置文件"></a>Konsole profile 配置文件</h2><ul><li>所在路径 ~/.locla/share/konsole/*.profile</li><li>修改Command 项里面参数(记得保存哦)</li><li>点击Konsole图标，就可以启动成功<br>这就ok啦</li></ul><blockquote><p>Note: 到这里Konsole 不能启动的问题就修复，下面完成我未尽的事业🤪</p></blockquote><h2 id="未尽事业🤣"><a href="#未尽事业🤣" class="headerlink" title="未尽事业🤣"></a>未尽事业🤣</h2><h3 id="新建一个文件"><a href="#新建一个文件" class="headerlink" title="新建一个文件"></a>新建一个文件</h3><ul><li>最后是.开头的隐藏文件</li><li>这个文件用来存放，终端启动需要自动执行的命令<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ touch .neofetchShow</span><br></pre></td></tr></table></figure></li></ul><h3 id="写入命令"><a href="#写入命令" class="headerlink" title="写入命令"></a>写入命令</h3><ul><li>把需要自动执行的命令，写入到文件中<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">'neofetch'</span> &gt;&gt; .neofetchShow</span><br></pre></td></tr></table></figure><blockquote><p>neofetch 命令需要自己安装</p></blockquote></li></ul><h3 id="修改shell配置文件"><a href="#修改shell配置文件" class="headerlink" title="修改shell配置文件"></a>修改shell配置文件</h3><ul><li>默认shell 的配置文件为～/.bashrc</li><li>zsh配置文件为~/.zshrc</li><li>将文件路径写入配置文件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.neofetchShow</span><br></pre></td></tr></table></figure></li><li>保存配置文件</li></ul><blockquote><p>Note: 以上上操作都在home目录下完成，如果配置失败了，请核对路径和需要启动的命令时候可以执行</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;前几天，想实现打开终端自动显示系统相关信息。&lt;br&gt;于是我就在修改了 Konsole Profile 的 Command 加入了一个命令。&lt;br&gt;结果，konsole都打不开啦。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux之路" scheme="http://yoursite.com/categories/Linux%E4%B9%8B%E8%B7%AF/"/>
    
    
    <category term="Arch" scheme="http://yoursite.com/tags/Arch/"/>
    
    <category term="Manjaro" scheme="http://yoursite.com/tags/Manjaro/"/>
    
    <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>永别ActiveWindowControl</title>
    <link href="http://yoursite.com/2020/08/20/%E6%B0%B8%E5%88%ABActiveWindowControl/"/>
    <id>http://yoursite.com/2020/08/20/%E6%B0%B8%E5%88%ABActiveWindowControl/</id>
    <published>2020-08-20T06:22:51.000Z</published>
    <updated>2020-10-26T14:33:18.382Z</updated>
    
    <content type="html"><![CDATA[<p>当初刚刚接触Ubuntu的时候,我就很喜欢Unity桌面的全局菜单整合功能,🎊<br>可以把窗口标题和全局菜单整合为一体.<br>这样就可以节省一行显示标题的空间.</p><a id="more"></a><p>可是后来,Ubuntu放弃啦Unity桌面,搞了Gnome桌面.👎<br>当初,其他衍生版搞Gnome桌面,他特立独行搞Unity现在有放弃.<br>这是我不喜欢Ubuntu的其中原因之一.</p><p>后来,在我的老电脑上,我已经转入了Arch魔教.<br>我是非常喜欢Arch的包管理器.这是非常Amazing.🤪</p><p>不过,现在在我的新电脑(Lenovo 小新13 Pro)已经使用Manjaro一段时间,<br>Manjaro是基于Arch开发的,Arch的一些优势基本上都有.<br>主要还是安装系统过程中,简便啦很多.</p><p>我使用的KDE桌面,是已经预装了全局菜单.不过还是不能实现Unity桌面的风格.<br>后来知道active Window Control 插件,可以实现这个功能,</p><p>我个人觉得这个东西不太友好,我几次配置都出现了桌面黑黑的(我也不知道是啥情况.).<br>而且,对于Window Title显示不太好,因为Title长度不一致,所以显示就有一些问题.<br>有强迫症的我,就能难忍受啦.😅</p><p>直到遇到了你,由<a href="https://github.com/psifidotos">psifidotos</a>开发的applet-window系列插件🤪<br>另外,提一下.这个位开发者处理Github issue 的速度是很快的.<br>由于我的无知(我对系统不熟悉),在Windos title 这个仓库中Open issue .没过多久他就回复我,<br>而且,非常友好的给出了解决我问题的方式.</p><h2 id="如何实现Unity桌面风格"><a href="#如何实现Unity桌面风格" class="headerlink" title="如何实现Unity桌面风格"></a>如何实现Unity桌面风格</h2><p>需要安装如下插件,目前这些都不在AUR仓库中,需要自己下载编译安装.</p><ul><li>applet-window-title</li><li>applet-window-buttons</li><li>applet-window-appmenu</li></ul><blockquote><p>Note: 编译过程,系统需要有cmake 和 extra-cmake-modules 环境 .  这两个可以直接安装.</p></blockquote><h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><h3 id="安装applet-window-title"><a href="#安装applet-window-title" class="headerlink" title="安装applet-window-title"></a>安装applet-window-title</h3><ul><li><p>克隆仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/psifidotos/applet-window-title.git</span><br></pre></td></tr></table></figure><p>该插件使用QML编写,可以直接装入.不需要编译</p></li><li><p>安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> applet-window-title</span><br><span class="line">plasmapkg2 -i .</span><br></pre></td></tr></table></figure></li></ul><p>至此,安装完成🤞</p><h3 id="安装applet-window-buttons"><a href="#安装applet-window-buttons" class="headerlink" title="安装applet-window-buttons"></a>安装applet-window-buttons</h3><ul><li>克隆仓库<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/psifidotos/applet-window-buttons.git</span><br></pre></td></tr></table></figure></li><li>编译安装<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> applet-window-buttons</span><br><span class="line">sh install.sh</span><br></pre></td></tr></table></figure>shell 脚本需要知道完成,编译和安装工作.</li></ul><blockquote><p>Note: 一定要安装cmake和 extra-cmake-modules . 不然会无法编译</p></blockquote><p>至此,安装完成🤞</p><h3 id="安装applet-windows-appmenu"><a href="#安装applet-windows-appmenu" class="headerlink" title="安装applet-windows-appmenu"></a>安装applet-windows-appmenu</h3><p>如果,系统已经预装了,全局菜单. 这个可以不安装.<br>我就是使用系统预装的全局菜单的😝</p><p>如果没有就看下吧!!</p><ul><li>克隆仓库<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/psifidotos/applet-window-appmenu.git</span><br></pre></td></tr></table></figure></li><li>编译安装<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> applet-window-appmenu</span><br><span class="line">sh install.sh</span><br></pre></td></tr></table></figure>同样,shell会搞定一切.开发者还是蛮贴心的哈<del>~</del>👋</li></ul><p>到这就全部安装完成啦.</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>安装完成,就可以愉快到需要的地方.添加插件啦.<br><img src="/img/min.png" alt="效果"><br><img src="/img/max.png" alt="效果"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;当初刚刚接触Ubuntu的时候,我就很喜欢Unity桌面的全局菜单整合功能,🎊&lt;br&gt;可以把窗口标题和全局菜单整合为一体.&lt;br&gt;这样就可以节省一行显示标题的空间.&lt;/p&gt;</summary>
    
    
    
    <category term="Linux之路" scheme="http://yoursite.com/categories/Linux%E4%B9%8B%E8%B7%AF/"/>
    
    
    <category term="Arch" scheme="http://yoursite.com/tags/Arch/"/>
    
    <category term="Manjaro" scheme="http://yoursite.com/tags/Manjaro/"/>
    
    <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux安装VirtualBox</title>
    <link href="http://yoursite.com/2020/08/14/Linux%E5%AE%89%E8%A3%85VirtualBox/"/>
    <id>http://yoursite.com/2020/08/14/Linux%E5%AE%89%E8%A3%85VirtualBox/</id>
    <published>2020-08-14T08:47:55.000Z</published>
    <updated>2020-10-31T12:50:24.248Z</updated>
    
    <content type="html"><![CDATA[<p>昨天，我下载好了kali镜像后.<br>今天,反手就是一个条命令把VirtualBox安装好了,<br>结果可想而知🤣</p><a id="more"></a><p>安装的VirtualBox可以运行,但是就是不能启动里面的虚拟系统.<br>这就很令我发愁,本来因为是BIOS没有开启虚拟化.<br>经过排查并不是这个原因.🤔<br>后来才知道,需要安装对应内核版本的安装包,才行</p><h2 id="确定Linux内核版本"><a href="#确定Linux内核版本" class="headerlink" title="确定Linux内核版本"></a>确定Linux内核版本</h2><ul><li>安装对应内核版本的安装,需要查询但前实习使用的内核.</li><li>使用uname -r 命令即可查询<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo uname -r</span><br><span class="line">5.6.19-2-MANJARO</span><br></pre></td></tr></table></figure>表示需要安装linux内核版本为5.6</li></ul><h2 id="安装VirtualBox"><a href="#安装VirtualBox" class="headerlink" title="安装VirtualBox"></a>安装VirtualBox</h2><p>需要安装VirtualBox和扩展包,以及内核模块</p><ul><li>安装VirtualBox<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pacman -S virtualbox</span><br></pre></td></tr></table></figure></li><li>安装VirtualBox扩展包<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pacman -S virtualbox-ext-oracle</span><br></pre></td></tr></table></figure></li><li>安装内核模块<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pacman -S linux56-virtualbox-host-modules</span><br></pre></td></tr></table></figure><blockquote><p>Note: 安装内核模块,一定要和系统内核是一致的版本.不然可能无法启动.</p></blockquote></li></ul><h2 id="载入vboxdr模块"><a href="#载入vboxdr模块" class="headerlink" title="载入vboxdr模块"></a>载入vboxdr模块</h2><ul><li>重启系统模块会自动载入.</li><li>手动使用命令载入<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo modprobe vboxdrv</span><br></pre></td></tr></table></figure>如果是其他衍生系统,大致安装步骤也和这个差不多.如果是初学者,注意包管理器的不同哦.🤞🤞🤞</li></ul><p>完成这些,就可以在Linux下面愉快的玩耍啦.🎊🎊🎊</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;昨天，我下载好了kali镜像后.&lt;br&gt;今天,反手就是一个条命令把VirtualBox安装好了,&lt;br&gt;结果可想而知🤣&lt;/p&gt;</summary>
    
    
    
    <category term="Linux之路" scheme="http://yoursite.com/categories/Linux%E4%B9%8B%E8%B7%AF/"/>
    
    
    <category term="Arch" scheme="http://yoursite.com/tags/Arch/"/>
    
    <category term="Manjaro" scheme="http://yoursite.com/tags/Manjaro/"/>
    
    <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>qBittorrent下载加速</title>
    <link href="http://yoursite.com/2020/08/13/qBittorrent%E4%B8%8B%E8%BD%BD%E5%8A%A0%E9%80%9F/"/>
    <id>http://yoursite.com/2020/08/13/qBittorrent%E4%B8%8B%E8%BD%BD%E5%8A%A0%E9%80%9F/</id>
    <published>2020-08-13T03:10:05.000Z</published>
    <updated>2020-10-26T14:32:57.732Z</updated>
    
    <content type="html"><![CDATA[<p>Linux 下面如何下载Bittorrent的资源呢🤔🤔？？<br>如果是在Windows下面,迅雷🐦一般是第一选择．</p><a id="more"></a><p>今天，我试图下载Kali Linux 镜像的时候，发现官方提供了，BitTorrent下载方式．<br>我就打算在我的Linux 下面尝试一下．结果下载速度非常快😝</p><h2 id="安装qBittorrent"><a href="#安装qBittorrent" class="headerlink" title="安装qBittorrent"></a>安装qBittorrent</h2><p>qBittorrent是一个跨平台的自由BitTorrent客户端，其图形用户界面是由Qt所写成的．</p><blockquote><p>下载链接：<a href="https://www.qbittorrent.org/download.php">https://www.qbittorrent.org/download.php</a></p></blockquote><p>等待下载完成后，就可以安装啦．</p><h3 id="Arch系列"><a href="#Arch系列" class="headerlink" title="Arch系列"></a>Arch系列</h3><p>如果是Arch Linux ，或者是基于Arch Linux 的系统</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S qbittorrent</span><br></pre></td></tr></table></figure><p>可以使用上述命令直接安装．</p><h2 id="加入Tracker-服务器"><a href="#加入Tracker-服务器" class="headerlink" title="加入Tracker 服务器"></a>加入Tracker 服务器</h2><p>Tracker服务器，主要目的是为了，提升下载速度.</p><p>由于tracker对BT下载起到客户端协调和调控的重要作用，所以一旦被封锁会严重影响BT下载，如2009年12月，中华人民共和国广电总局对BTchina一系列的tracker进行打击，因此也促使新BT客户端支持DHT网络实现无中心tracker，分布式资源分享的影响<br>需要了解更多Tracker服务器，可以自行搜索．</p><h2 id="qBittorrent-添加tracker服务器"><a href="#qBittorrent-添加tracker服务器" class="headerlink" title="qBittorrent 添加tracker服务器"></a>qBittorrent 添加tracker服务器</h2><p><a href="/img/tra.png">添加tracker服务器</a></p><ul><li>点击Preferences</li><li>找到Bittorent选项</li><li>勾选　automatically add thes trackers to new downloads 选项</li><li>粘贴tracker服务器列表，即可点击apply</li></ul><blockquote><p>Note: qBittorrent添加完成tracker服务器后需要，重新启动软件．</p></blockquote><h2 id="tracker服务器列表"><a href="#tracker服务器列表" class="headerlink" title="tracker服务器列表"></a>tracker服务器列表</h2><ul><li>Best Tracker list:<blockquote><p>　<a href="https://trackerslist.com/best.txt">https://trackerslist.com/best.txt</a></p></blockquote></li><li>All Tracker list:<blockquote><p><a href="https://trackerslist.com/all.txt">https://trackerslist.com/all.txt</a></p></blockquote></li><li>Http(s) Tracker list:<blockquote><p><a href="https://trackerslist.com/http.txt">https://trackerslist.com/http.txt</a></p></blockquote></li></ul><p>这些是我日程使用的Tracker服务器列表，这个仓库列表，已有人发布到github仓库中．<br>这里我就不给出仓库连接了，在我的收藏的仓库中可以找到😝</p><p>关于Bittorent 就分享到这里吧，DHT的中文全称是分布式哈希表(distributed has table 的缩写)，这可以避免中心tracker服务器的不能工作而导致这个系统的瘫痪．是一些天才的杰作．</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Linux 下面如何下载Bittorrent的资源呢🤔🤔？？&lt;br&gt;如果是在Windows下面,迅雷🐦一般是第一选择．&lt;/p&gt;</summary>
    
    
    
    <category term="Linux之路" scheme="http://yoursite.com/categories/Linux%E4%B9%8B%E8%B7%AF/"/>
    
    
    <category term="Arch" scheme="http://yoursite.com/tags/Arch/"/>
    
    <category term="Manjaro" scheme="http://yoursite.com/tags/Manjaro/"/>
    
    <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Shell之处理命名参数</title>
    <link href="http://yoursite.com/2020/08/09/Shell%E4%B9%8B%E5%A4%84%E7%90%86%E5%91%BD%E5%90%8D%E5%8F%82%E6%95%B0/"/>
    <id>http://yoursite.com/2020/08/09/Shell%E4%B9%8B%E5%A4%84%E7%90%86%E5%91%BD%E5%90%8D%E5%8F%82%E6%95%B0/</id>
    <published>2020-08-09T02:51:43.000Z</published>
    <updated>2020-10-26T14:33:03.102Z</updated>
    
    <content type="html"><![CDATA[<p>今天练习了一下shell脚本，之前简单的学习啦shell脚本的语法。😅<br>刷了<a href="https://www.hackerrank.com/dashboard">HackerRank</a>的题目以后，发现还是不能很好的驾驭shell这把神剑。</p><a id="more"></a><p>于是，我决定闭关修炼😝<br>修炼过程中，我发现啦很多武林绝学🌻。令我感到非常的Amazing。<br>下面就来看看吧！！！</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">deploy=<span class="literal">false</span></span><br><span class="line">uglify=<span class="literal">false</span></span><br><span class="line"><span class="keyword">while</span>(( <span class="variable">$#</span> &gt; 1 ));</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="keyword">case</span> <span class="variable">$1</span> <span class="keyword">in</span></span><br><span class="line">    --deploy) deploy=<span class="string">"<span class="variable">$2</span>"</span>;;</span><br><span class="line">    --uglify) uglify=<span class="string">"<span class="variable">$2</span>"</span>;;</span><br><span class="line">    *) <span class="built_in">break</span>;</span><br><span class="line">   <span class="keyword">esac</span>; <span class="built_in">shift</span> 2</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$deploy</span> &amp;&amp; <span class="built_in">echo</span> <span class="string">"will deploy... deploy = <span class="variable">$deploy</span>"</span></span><br><span class="line"><span class="variable">$uglify</span> &amp;&amp; <span class="built_in">echo</span> <span class="string">"will uglify... uglify = <span class="variable">$uglify</span>"</span></span><br></pre></td></tr></table></figure><blockquote><p>Note: 最后两行，与&amp;&amp;的运算方式有关</p></blockquote><ul><li>$# 参数个数<h2 id="运行方式"><a href="#运行方式" class="headerlink" title="运行方式"></a>运行方式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash script.sh --deploy <span class="literal">true</span> --uglify <span class="literal">false</span></span><br></pre></td></tr></table></figure>true 和fasle 为输入值<h2 id="特殊变量"><a href="#特殊变量" class="headerlink" title="特殊变量"></a>特殊变量</h2><table><thead><tr><th>变量</th><th>含义</th></tr></thead><tbody><tr><td>$0</td><td>当前脚本的文件名</td></tr><tr><td>$n</td><td>传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例</td></tr><tr><td>$#</td><td>传递给脚本或函数的参数个数。</td></tr><tr><td>$*</td><td>传递给脚本或函数的所有参数。</td></tr><tr><td>$@</td><td>传递给脚本或函数的所有参数。被双引号(“ “)包含时，与 $* 稍有不同</td></tr><tr><td>$?</td><td>上个命令的退出状态，或函数的返回值。</td></tr><tr><td>$$</td><td>当前Shell进程ID。对于 Shell 脚本，就是这些脚本所在的进程ID。</td></tr></tbody></table></li></ul><h2 id="和-的区别"><a href="#和-的区别" class="headerlink" title="$@和$*的区别"></a>$@和$*的区别</h2><ul><li>不被双引号(“ “)包含时，都以”$1” “$2” … “$n” 的形式输出所有参数。</li><li>被双引号(“ “)包含时，</li><li><ul><li>“$*” 会将所有的参数作为一个整体，以”$1 $2 … $n”的形式输出所有参数；</li></ul></li><li><ul><li>“$@” 会将各个参数分开，以”$1” “$2” … “$n” 的形式输出所有参数(带换行输出)。</li></ul></li></ul><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"print each param from \$*"</span></span><br><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> $*</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"<span class="variable">$var</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"print each param from \$@"</span></span><br><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> <span class="variable">$@</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"<span class="variable">$var</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"print each param from \"\$*\""</span></span><br><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> <span class="string">"$*"</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"<span class="variable">$var</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"print each param from \"\$@\""</span></span><br><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> <span class="string">"<span class="variable">$@</span>"</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"<span class="variable">$var</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>今天，就先到这里吧!! </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天练习了一下shell脚本，之前简单的学习啦shell脚本的语法。😅&lt;br&gt;刷了&lt;a href=&quot;https://www.hackerrank.com/dashboard&quot;&gt;HackerRank&lt;/a&gt;的题目以后，发现还是不能很好的驾驭shell这把神剑。&lt;/p&gt;</summary>
    
    
    
    <category term="脚本" scheme="http://yoursite.com/categories/%E8%84%9A%E6%9C%AC/"/>
    
    
    <category term="Arch" scheme="http://yoursite.com/tags/Arch/"/>
    
    <category term="Manjaro" scheme="http://yoursite.com/tags/Manjaro/"/>
    
    <category term="Shell" scheme="http://yoursite.com/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>List和Tuple</title>
    <link href="http://yoursite.com/2020/08/02/List%E5%92%8CTuple/"/>
    <id>http://yoursite.com/2020/08/02/List%E5%92%8CTuple/</id>
    <published>2020-08-02T02:05:56.000Z</published>
    <updated>2020-10-26T14:32:45.595Z</updated>
    
    <content type="html"><![CDATA[<p>之前写了，学习了基本数据类型。今天就该学习List了</p><a id="more"></a><h2 id="List（列表）"><a href="#List（列表）" class="headerlink" title="List（列表）"></a>List（列表）</h2><p>List是Python 内置的一种数据类型。<br>他是一种有序的集合，可以随时添加和删除其中的元素</p><h3 id="创建列表"><a href="#创建列表" class="headerlink" title="创建列表"></a>创建列表</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name = [<span class="string">'Linux'</span>,<span class="string">'arch'</span>,<span class="string">'kernel'</span>,<span class="string">'manjaro'</span>]</span><br></pre></td></tr></table></figure><ul><li>列表元素不一定是相同的元素。</li><li>使用print可以直接打印。</li></ul><h3 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h3><ul><li>通过索引来访问<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(name[<span class="number">2</span>])</span><br></pre></td></tr></table></figure></li><li>通过方括号的形式来截取列表中的元素<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(name[<span class="number">0</span>:<span class="number">2</span>]) <span class="comment">#左闭右开</span></span><br></pre></td></tr></table></figure></li><li>左索引缺省为0<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(name[:<span class="number">2</span>])</span><br></pre></td></tr></table></figure></li><li>右索引缺省为列表最后一个<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(name[<span class="number">1</span>:])</span><br></pre></td></tr></table></figure></li></ul><h3 id="更新元素"><a href="#更新元素" class="headerlink" title="更新元素"></a>更新元素</h3><p>对索引直接赋值，就可以</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name[<span class="number">2</span>]=<span class="string">'archkernel'</span></span><br></pre></td></tr></table></figure><h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><p>使用append()方法来添加</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name.append(<span class="string">'ubuntu'</span>) <span class="comment">#元素添加到列表末尾</span></span><br></pre></td></tr></table></figure><h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p>使用del语句来删除列表的元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">del</span> name[<span class="number">2</span>] <span class="comment">#删除位置的以后索引的元素自动先前填充</span></span><br></pre></td></tr></table></figure><h3 id="List运算符"><a href="#List运算符" class="headerlink" title="List运算符"></a>List运算符</h3><table><thead><tr><th>Python 表达式</th><th align="left">结果</th><th>描述</th></tr></thead><tbody><tr><td>len([1, 2, 3])</td><td align="left">3</td><td>计算元素个数</td></tr><tr><td>[1, 2, 3] + [4, 5, 6]</td><td align="left">[1, 2, 3, 4, 5, 6]</td><td>组合</td></tr><tr><td>[‘Hi!’] * 4</td><td align="left">[‘Hi!’, ‘Hi!’, ‘Hi!’, ‘Hi!’]</td><td>复制</td></tr><tr><td>3 in [1, 2, 3]</td><td align="left">True</td><td>元素是否存在于列表中</td></tr><tr><td>for x in [1, 2, 3]: print x,</td><td align="left">1 2 3</td><td>迭代</td></tr></tbody></table><h3 id="List函数"><a href="#List函数" class="headerlink" title="List函数"></a>List函数</h3><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>max(list)</td><td>返回列表元素最大值</td></tr><tr><td>min(list)</td><td>返回列表元素最小值</td></tr><tr><td>list(seq)</td><td>将元组转换为列表</td></tr><tr><td>list.append(obj)</td><td>在列表末尾添加新的对象</td></tr><tr><td>list.count(obj)</td><td>统计某个元素在列表中出现的次数</td></tr><tr><td>list.extend(seq)</td><td>在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）</td></tr><tr><td>list.index(obj)</td><td>从列表中找出某个值第一个匹配项的索引位置”</td></tr><tr><td>list.insert(index, obj)</td><td>将对象插入列表</td></tr><tr><td>list.pop(obj=list[-1])</td><td>移除列表中的一个元素（默认最后一个元素），并且返回该元素的值</td></tr><tr><td>list.remove(obj)</td><td>移除列表中的一个元素（参数是列表中元素），并且不返回任何值}</td></tr><tr><td>list.reverse()</td><td>反向列表中元素</td></tr><tr><td>list.sort([func])</td><td>对原列表进行排序</td></tr></tbody></table><h2 id="Tuple-元组"><a href="#Tuple-元组" class="headerlink" title="Tuple (元组)"></a>Tuple (元组)</h2><p>tuple一旦初始化就不能修改。</p><h3 id="创建元组"><a href="#创建元组" class="headerlink" title="创建元组"></a>创建元组</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tuple=(<span class="string">'Linux'</span>,<span class="string">'arch'</span>,<span class="string">'kernel'</span>,<span class="string">'manjaro'</span>)</span><br></pre></td></tr></table></figure><p>创建空元组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tuple=()</span><br></pre></td></tr></table></figure><blockquote><p>Note: 创建元组中只包含一个元素时，需要在元素后面添加逗号。避免产生歧义。</p></blockquote><h3 id="访问元组"><a href="#访问元组" class="headerlink" title="访问元组"></a>访问元组</h3><p>访问方式和List一样👋</p><h3 id="修改元组"><a href="#修改元组" class="headerlink" title="修改元组"></a>修改元组</h3><p>可以对元组进行连接组合，而打到修改元组内容的🤗。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">list1=[<span class="number">123</span>,<span class="number">456</span>]</span><br><span class="line">tuple1=(<span class="string">'两点水'</span>,<span class="string">'twowater'</span>,<span class="string">'liangdianshui'</span>,list1)</span><br><span class="line">print(tuple1)</span><br><span class="line">list1[<span class="number">0</span>]=<span class="number">789</span></span><br><span class="line">list1[<span class="number">1</span>]=<span class="number">100</span></span><br><span class="line">print(tuple1)</span><br></pre></td></tr></table></figure><p>这样就可通过修改List，而达到修改Tuple的目的。</p><blockquote><p>Note: Tuple一开始指向list，修改list的内容，并没有改变别指向。</p></blockquote><h3 id="删除元组"><a href="#删除元组" class="headerlink" title="删除元组"></a>删除元组</h3><p>与List一致，使用del语句。但是不能单独删除单个元素，因为不可变。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">del</span> tuple</span><br></pre></td></tr></table></figure><h3 id="元组运算符"><a href="#元组运算符" class="headerlink" title="元组运算符"></a>元组运算符</h3><p>元组之间可以使用 + 号和 * 号进行运算。这就意味着他们可以组合和复制，运算后会生成一个新的元组。</p><table><thead><tr><th>Python表达式</th><th>结果</th><th>描述</th></tr></thead><tbody><tr><td>len((1, 2, 3))</td><td>3</td><td>计算元素个数</td></tr><tr><td>(1, 2, 3) + (4, 5, 6)</td><td>(1, 2, 3, 4, 5, 6)</td><td>连接</td></tr><tr><td>(‘Hi!’,) * 4</td><td>(‘Hi!’, ‘Hi!’, ‘Hi!’, ‘Hi!’)</td><td>复制</td></tr><tr><td>3 in (1, 2, 3)</td><td>True</td><td>元素是否存在</td></tr><tr><td>for x in (1, 2, 3): print(x)</td><td>1 2 3</td><td>迭代</td></tr></tbody></table><h3 id="元组内置函数"><a href="#元组内置函数" class="headerlink" title="元组内置函数"></a>元组内置函数</h3><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>len(tuple)</td><td>计算元组元素个数</td></tr><tr><td>max(tuple)</td><td>返回元组中元素最大值</td></tr><tr><td>min(tuple)</td><td>返回元组中元素最小值</td></tr><tr><td>tuple(seq)</td><td>将列表转换为元组</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前写了，学习了基本数据类型。今天就该学习List了&lt;/p&gt;</summary>
    
    
    
    <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
    <category term="编程语言" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="脚本" scheme="http://yoursite.com/tags/%E8%84%9A%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>Manjaro连接隐藏WIFI</title>
    <link href="http://yoursite.com/2020/07/30/Manjaro%E8%BF%9E%E6%8E%A5%E9%9A%90%E8%97%8FWIFI/"/>
    <id>http://yoursite.com/2020/07/30/Manjaro%E8%BF%9E%E6%8E%A5%E9%9A%90%E8%97%8FWIFI/</id>
    <published>2020-07-30T14:17:57.000Z</published>
    <updated>2020-10-26T14:32:49.182Z</updated>
    
    <content type="html"><![CDATA[<p>今天远行，但是高铁晚点啦几分钟。我又很饿🤗。我就非常的不开心。<br>现在我已经到达了，目的地。<br>于是乎我开启了我的电脑，想要上上网～～～</p><a id="more"></a><p>可是wifi是隐藏的，也就是说没有广播SSID。这对于我来说，是一个大问题。<br>因为我以前就遇到啦这个问题，但是我利用啦曲线救国。我就直接改了路由器的设置，开启啦SSID广播。<br>不过，这个我懒得捣腾啦。🤣</p><p>我决定好好，看看官方的Wiki了。<br>巧了官方还针给出啦，连接隐藏wifi的方案！！！<br>不过，填写SSID的时候需要加入单引号，才能连接成功，不然会提示SSID找不到</p><blockquote><p><a href="https://wiki.archlinux.org/index.php/NetworkManager_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">https://wiki.archlinux.org/index.php/NetworkManager_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)</a></p></blockquote><p>官方wiki都很详细，我就不多说啦。我只记录官方没有说明的一些细节部分。🤪<br>今天就到这里吧！！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天远行，但是高铁晚点啦几分钟。我又很饿🤗。我就非常的不开心。&lt;br&gt;现在我已经到达了，目的地。&lt;br&gt;于是乎我开启了我的电脑，想要上上网～～～&lt;/p&gt;</summary>
    
    
    
    <category term="Linux之路" scheme="http://yoursite.com/categories/Linux%E4%B9%8B%E8%B7%AF/"/>
    
    
    <category term="Arch" scheme="http://yoursite.com/tags/Arch/"/>
    
    <category term="Manjaro" scheme="http://yoursite.com/tags/Manjaro/"/>
    
    <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>备考过程及我的方法</title>
    <link href="http://yoursite.com/2020/07/28/%E5%A4%87%E8%80%83%E8%BF%87%E7%A8%8B%E5%8F%8A%E6%88%91%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2020/07/28/%E5%A4%87%E8%80%83%E8%BF%87%E7%A8%8B%E5%8F%8A%E6%88%91%E7%9A%84%E6%96%B9%E6%B3%95/</id>
    <published>2020-07-27T23:55:49.000Z</published>
    <updated>2020-10-26T14:33:13.465Z</updated>
    
    <content type="html"><![CDATA[<p>考试也结束啦，结果还不错🤪。<br>下面我就记录分享一下，我以往的学习方式及备考过程。</p><a id="more"></a><h1 id="我的自学观点"><a href="#我的自学观点" class="headerlink" title="我的自学观点"></a>我的自学观点</h1><h2 id="我是一个方法论者"><a href="#我是一个方法论者" class="headerlink" title="我是一个方法论者"></a>我是一个方法论者</h2><p>面对一切东西都有其方式与方式，无论是与人打交道，还是学习一个新的工具，或者是谈恋爱都有方法。<br>相比于努力，我更喜欢高效率。当然，我也不是那种非常勤奋的人🙈。<br>在我面对一个新的事物，并学习它的时候。我通常是先去了解大体的框架，然后基于这个框架逐步去细化，直至每一个需要学习的知识点都掌握。<br>这是我以往的学习方法，看上去是非常像软件工程中逐步求精的过程。</p><h2 id="他人建议的参考"><a href="#他人建议的参考" class="headerlink" title="他人建议的参考"></a>他人建议的参考</h2><p>在自学过程中，常常身边会有一群学习的伙伴，或者是老师。他们往往会提供一些建议与学习的资料。</p><h3 id="如何对待这些人的建议的呢？"><a href="#如何对待这些人的建议的呢？" class="headerlink" title="如何对待这些人的建议的呢？"></a>如何对待这些人的建议的呢？</h3><p>对于给我建议的人，我必然是表示感谢。但是这并不意味着需要完全接受他们的建议，而摒弃原有自己的学习方式与计划。</p><p>比如： 有个同学推荐你去做一套英语试卷，他说他就是写完这套试卷就把英语成绩提升去。<br>他就推荐你去做这套试卷。然后你很都不能写出来。而且最后英语成绩也没有提高。反而是浪费啦自己的时间。<br>原因就是两个对英语的掌握情况不一致导致的。<br>一个人英语刚刚入门，另一词汇量足够，语法不太好。<br>使用同一个学习方式，同一个学习进度。必然是得不到两人都能把英语成绩提高的目标</p><h2 id="自学阶段的定位"><a href="#自学阶段的定位" class="headerlink" title="自学阶段的定位"></a>自学阶段的定位</h2><p>要在实际中回答上一个问题，在自学过程中自我定位是必然的。<br>当自己知道了，自己目前自学所在的阶段。才能搞清楚哪些内容是需要自己目前学的，哪些是后阶段要学的，哪些是习题是目前需要做的。</p><h3 id="如何定位"><a href="#如何定位" class="headerlink" title="如何定位"></a>如何定位</h3><p>想要确定自己处于哪一个自学阶段，就需要对整个自学过程的框架有大体的认识(这就是我为什么先会去了解大体的框架)。</p><p>大体框架知道啦，处于哪一个学习阶段就很简单啦。<br>后续就可对该阶段进行学习，其学习方法可以当做学一个新的东西，继续套用上述方式。</p><p>比如：我现在的目标是学习英语。<br>我发现英语就是由词汇和语法组成。且需要一定词汇才能学习语法。<br>基于以上这个框架。我就可以得出，我的第一个学习阶段是记忆单词，提升自己的词汇量。<br>而对于记忆单词，又有记忆单词的方法(比如谐音，词根词缀，记忆单词时候阅读一些英语文章，起到复习着用这写都是记忆单词的方法)。<br>单有了一定的基础后，我就可以渐渐学习语法的基础知识了。<br>但我们学习了语法，对于语法这个子集有可以进一步展开学习。<br>即语法就由时态、语态、句型等等组成。</p><p>在整个过程，会发现我基于英文就是由词汇和语法组法的框架会逐步细化，<br>渐渐变成英语就是由词汇和语法(时态语态、句型、从句等)的框架。<br>当我们逐步去学习这个框架的子集，就等价于学习了具体每个知识点。</p><blockquote><p>Note:以上是我的学习方法，不仅仅用于考试。我日常学习新的编译语言也是使用这个方法。</p></blockquote><h1 id="备考过程"><a href="#备考过程" class="headerlink" title="备考过程"></a>备考过程</h1><p>以前不久的专生本考试为例。一共考3个科目(大学英语、高等数学、C语言)<br>虽然这个才考了213分，专业排名第3名。</p><h2 id="备考决策"><a href="#备考决策" class="headerlink" title="备考决策"></a>备考决策</h2><p>对于考试科目，肯定有自己善长，有自己薄弱的。<br>我的备考策略分为</p><h3 id="发考纲前"><a href="#发考纲前" class="headerlink" title="发考纲前"></a>发考纲前</h3><p>在这个阶段，可以学习基础知识，先把基础夯实。</p><ul><li>英语可以先记忆单词，学习语法</li><li>数学先从理解的角度记忆公式，巩固基本概念的理解</li><li>专业也要从基础学起，我的C语言，我是把一些基本概念复习了一遍<blockquote><p>Note: 这个阶段，可以看一些视频教程。如果看资料难以写理解的话。</p></blockquote><h3 id="发考纲后"><a href="#发考纲后" class="headerlink" title="发考纲后"></a>发考纲后</h3>考纲一般是在考前两个月发(湖南省是这样，一般学校老师会说)<br>在这个阶段就要系统的刷题了。无论是自己善长的还是薄弱的都要去系统的刷一些题目。<br>刷题就是看病，检查有病就要治疗。<br>不要盲目的刷题，当检查错题时分析自己写错的原因。<h3 id="考前1个月了"><a href="#考前1个月了" class="headerlink" title="考前1个月了"></a>考前1个月了</h3>有些科目还是没有入门，那就减少该科的学习时间。<br>我就在考前2两个星期基本上看英语的时间很少(尽管有人跟我说英语很拉分，当我并没有花大量时间)，<br>重点都在数学和专业知识点的梳理上啦。<br>考前一个月，就是做一些基本题目。和看以前写过的习题。然后，总结自己不清晰的知识点。</li></ul><h2 id="考纲分析"><a href="#考纲分析" class="headerlink" title="考纲分析"></a>考纲分析</h2><p>学校发布考纲后，一定要认证阅读考纲。<br>可以重考纲中，去分析哪些知识是自己不会的。<br>重点看考纲的 “识记”、“了解”、“掌握”、“应用”这写关键字。<br>还有整体知识点的占比。比重大的必然考的多，基础的也考得多。</p><blockquote><p>Note: 考纲结合复习资料，在目录标志自己没有掌握的知识点</p></blockquote><h2 id="难题分析"><a href="#难题分析" class="headerlink" title="难题分析"></a>难题分析</h2><p>在练习过程，往往会有一些题目困住自己。<br>这个时候，我们需要分析自己是由于什么样的原因，而不能解答。</p><h3 id="知识遗漏"><a href="#知识遗漏" class="headerlink" title="知识遗漏"></a>知识遗漏</h3><p>对于这类题目，需要去查阅知识点才能解答。<br>那么需要把这个知识，自己去识记下来。<br>我是拿了一个小本子记录📑。</p><h3 id="粗心大意"><a href="#粗心大意" class="headerlink" title="粗心大意"></a>粗心大意</h3><p>这类题目，往往是自己马虎，对于题目的知识点都掌握啦。<br>或者题目在玩文字游戏。<br>这个类问题，往往和人有关。有些人重小就仔细。<br>我就是一个马虎的人，我是在写题目的时候，保持注意力集中和环境安静(把电子设备都关了)。<br>做题目的时候，不去想别的事情</p><h3 id="思维困难"><a href="#思维困难" class="headerlink" title="思维困难"></a>思维困难</h3><p>这种题目，就是咋都想不到，解题的方法。<br>我有一次，在计算极限的时候，就没有想到需要对(1 - a^3) 进行展开，再化简。<br>这个问题，我也会记录在小本子上📑。下次做题的时候，就会试着向这个方向思考。<br>对于思维困难，必须要多做题目才行。</p><h1 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h1><p>备考一定明确，考试范围。</p><p>备考要制定自己的计划，复习的整体计划。每日计划也可以制定(我没有制定，我一般只有整体计划)</p><p>考前，要梳理知识点。不要在意别人过多的决定和眼光(备考心态也要注意)</p><p>有了目标、计划就去完成。大家加油🤞🤞</p><blockquote><p>要搞清楚自己人生的剧本——不是你父母的续集，不是你子女的前传，更不是你朋友的外篇。<br>                                         –尼采</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;考试也结束啦，结果还不错🤪。&lt;br&gt;下面我就记录分享一下，我以往的学习方式及备考过程。&lt;/p&gt;</summary>
    
    
    
    <category term="日常" scheme="http://yoursite.com/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
    <category term="学习方法" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    
    <category term="备考方法" scheme="http://yoursite.com/tags/%E5%A4%87%E8%80%83%E6%96%B9%E6%B3%95/"/>
    
    <category term="自学方法" scheme="http://yoursite.com/tags/%E8%87%AA%E5%AD%A6%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Python之基本数据类型</title>
    <link href="http://yoursite.com/2020/07/27/Python%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>http://yoursite.com/2020/07/27/Python%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</id>
    <published>2020-07-27T08:35:49.000Z</published>
    <updated>2020-10-26T14:32:52.905Z</updated>
    
    <content type="html"><![CDATA[<p>我回来啦！！　回到我的家乡🎊<br>今天拿到啦毕业证书，没想到里面还有一张优秀毕业设计证书🤣<br>可是好简陋，我一脸嫌弃😏</p><a id="more"></a><p>闲言少叙，下面就开写进入Python的世界吧～～～🐍</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串英文 string ，是 python 中随处可见的数据类型。</p><p>字符串的识别也非常的简单，就是用「引号」括起来的<br>引号包括单引号 ‘ ‘ ，双引号 “ “ 和 三引号 ‘’’ ‘’’ ，比如 ‘abc’ ，”123” 等等。</p><h5 id="Note-为啥有这么多引号呢？-一个不行吗？🤔"><a href="#Note-为啥有这么多引号呢？-一个不行吗？🤔" class="headerlink" title="Note: 为啥有这么多引号呢？　一个不行吗？🤔"></a>Note: 为啥有这么多引号呢？　一个不行吗？🤔</h5><p>原因其实很简单</p><ul><li>单引号： 引用的字符串中不能有单引号「·用双引号」</li><li>双引号： 引用的字符串中不能有双引号「·用三引号」</li></ul><p>其实这里可以直接转义字符<br>比如单引号，你可以使用 \‘ 来表示，双引号可以使用 \“ 来表示。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">'Hello Python'</span>)</span><br><span class="line">print(<span class="string">"Hllo 'Python'"</span>)</span><br><span class="line">print(<span class="string">'''Hello "Python"'''</span>)</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hello Python</span><br><span class="line">Hllo <span class="string">'Python'</span></span><br><span class="line">Hello <span class="string">"Python"</span></span><br></pre></td></tr></table></figure><h2 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h2><p>整数英文为 integer 。<br>这里不多说,和C非常相似。我们直接看代码🤪</p><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int1  = <span class="number">1</span></span><br><span class="line">int2 = <span class="number">100</span></span><br><span class="line">int3 = <span class="number">-100</span></span><br><span class="line">int4 = <span class="number">1</span> / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">print(int1)</span><br><span class="line">print(int2)</span><br><span class="line">print(int3)</span><br><span class="line">print(int4)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">100</span><br><span class="line">-100</span><br><span class="line">0.5</span><br></pre></td></tr></table></figure><h5 id="Note：-1／２-会得到０-5-int4会自动提升为float类型。-１-2-才会得到０"><a href="#Note：-1／２-会得到０-5-int4会自动提升为float类型。-１-2-才会得到０" class="headerlink" title="Note：　1／２　会得到０.5 int4会自动提升为float类型。　１//2 才会得到０"></a>Note：　1／２　会得到０.5 int4会自动提升为float类型。　１//2 才会得到０</h5><h2 id="Python运算符"><a href="#Python运算符" class="headerlink" title="Python运算符"></a>Python运算符</h2><p>＋ 、- 、* 我就不列举啦，太简单和日常一样</p><table><thead><tr><th align="left">运算符</th><th align="left">表示</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">／</td><td align="left">除</td><td align="left">１／２　输出结果０.５</td></tr><tr><td align="left">％</td><td align="left">取模</td><td align="left">5%2 输出结果１</td></tr><tr><td align="left">**</td><td align="left">幂</td><td align="left">2**3 为２的３次方</td></tr><tr><td align="left">//</td><td align="left">取整</td><td align="left">11//2 输出结果　５</td></tr></tbody></table><h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2><p>浮点数的英文名是 float ，是指带小数的数字。<br>对浮点数的表达本身是不精确的。保存在计算机中的是二进制数，二进制对有些数字不能准确表达，只能非常接近这个数。</p><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="number">0.55</span>+<span class="number">0.41</span>)</span><br><span class="line">print(<span class="number">0.55</span>+<span class="number">0.4</span>)</span><br><span class="line">print(<span class="number">0.55</span>+<span class="number">0.411</span>)</span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0.96</span><br><span class="line">0.9500000000000001</span><br><span class="line">0.9610000000000001</span><br></pre></td></tr></table></figure><p>#####Note: 浮点数不能准确表达，对浮点数做运算和比较大小的时候要小心。</p><h2 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h2><p>一个布尔值只有True、False两种值「注意大写开头」🤫<br>布尔值可以用and、or、not运算。</p><ul><li><p>and 运算是与运算，只有所有都为 True，and 运算结果才是 True。</p></li><li><p>or 运算是或运算，只要其中有一个为 True，or 运算结果就是 True。</p></li><li><p>not 运算是非运算，它是一个单目运算符，把 True 变成 False，False 变成 True。</p></li></ul><p>这里很多语言都是一致的🤫,其实就是布尔代数🙃</p><h2 id="空值"><a href="#空值" class="headerlink" title="空值"></a>空值</h2><p>Python 使用Node「开头大写」来表示</p><h2 id="编码问题"><a href="#编码问题" class="headerlink" title="编码问题"></a>编码问题</h2><blockquote><p>我们都知道计算机只能处理数字，如果要处理文本，就必须先把文本转换为数字才能处理。最早的计算机在设计时采用8个比特（bit）作为一个字节（byte），所以，一个字节能表示的最大的整数就是255（二进制11111111=十进制255），0 - 255被用来表示大小写英文字母、数字和一些符号，这个编码表被称为ASCII编码，比如大写字母 A 的编码是 65，小写字母 z 的编码是 122。      </p><p>如果要表示中文，显然一个字节是不够的，至少需要两个字节，而且还不能和 ASCII 编码冲突，所以，中国制定了 GB2312 编码，用来把中文编进去。类似的，日文和韩文等其他语言也有这个问题。为了统一所有文字的编码，Unicode 应运而生。</p><p>Unicode 把所有语言都统一到一套编码里，这样就不会再有乱码问题了。Unicode 通常用两个字节表示一个字符，原有的英文编码从单字节变成双字节，只需要把高字节全部填为 0 就可以。</p><p>因为 Python 的诞生比 Unicode 标准发布的时间还要早，所以最早的Python 只支持 ASCII 编码，普通的字符串 ‘ABC’ 在 Python 内部都是 ASCII 编码的。&gt;Python 在后来添加了对 Unicode 的支持，以 Unicode 表示的字符串用u’…’表示。不过在最新的 Python 3 版本中，字符串是以 Unicode 编码的，也就是说，Python 的字符串支持多语言。就像上面的例子一样，我的代码中没有加u’…’，也能正常显示。</p><p>不过由于 Python 源代码也是一个文本文件，所以，当你的源代码中包含中文的时候，在保存源代码时，就需要务必指定保存为 UTF-8 编码。当Python 解释器读取源代码时，为了让它按 UTF-8 编码读取，我们通常在文件开头写上这两行：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3 </span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br></pre></td></tr></table></figure><blockquote><p>第一行注释是为了告诉 Linux/OS X 系统，这是一个 Python 可执行程序，Windows 系统会忽略这个注释；第二行注释是为了告诉 Python 解释器，按照 UTF-8 编码读取源代码，否则，你在源代码中写的中文输出可能会有乱码。</p><p>申明了 UTF-8 编码并不意味着你的 .py 文件就是 UTF-8 编码的，必须并且要确保文本编辑器正在使用 UTF-8 without BOM 编码</p></blockquote><p>今天就先到这里吧～～ </p><p>加油，加油🧑‍🔬</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我回来啦！！　回到我的家乡🎊&lt;br&gt;今天拿到啦毕业证书，没想到里面还有一张优秀毕业设计证书🤣&lt;br&gt;可是好简陋，我一脸嫌弃😏&lt;/p&gt;</summary>
    
    
    
    <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
    <category term="编程语言" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="脚本" scheme="http://yoursite.com/tags/%E8%84%9A%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>Linux使用QQ与微信</title>
    <link href="http://yoursite.com/2020/07/21/%E4%BD%BF%E7%94%A8QQ%E4%B8%8E%E5%BE%AE%E4%BF%A1/"/>
    <id>http://yoursite.com/2020/07/21/%E4%BD%BF%E7%94%A8QQ%E4%B8%8E%E5%BE%AE%E4%BF%A1/</id>
    <published>2020-07-21T07:41:41.000Z</published>
    <updated>2020-10-26T14:33:09.382Z</updated>
    
    <content type="html"><![CDATA[<p>对于一般Linux用户，QQ，微信。是经常需要使用的东西。🙃<br>不过对于我这种，神一般的Linux用户而言。QQ啥的就不是很需要啦。🤣<br>“有事给我发电子邮件”，这是我常说的。</p><a id="more"></a><p>QQ的确用的很少，但还是要记录一下QQ、微信安装和配置的！！</p><h2 id="QQ-for-Linux"><a href="#QQ-for-Linux" class="headerlink" title="QQ for Linux"></a>QQ for Linux</h2><p>这是首选Linux 下面的QQ解决方案。<br>这个东西，在愚人节过后更新啦，我也是很佩服。但是依旧是秦始皇年代的界面风格🤪<br>这个QQ毕竟可以流畅的使用，虽然有时崩溃。<br><img src="/img/linux11.jpg" alt="QQ for Linux"><br>###　安装<br>安装方式都是很简单，官方都有。<br>如果Arch ,Manjaro 就使用下面这条命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S qq-linux</span><br></pre></td></tr></table></figure><p><a href="https://im.qq.com/linuxqq/index.html">https://im.qq.com/linuxqq/index.html</a></p><h2 id="Deepin-QQ与Deepin-Wechat"><a href="#Deepin-QQ与Deepin-Wechat" class="headerlink" title="Deepin-QQ与Deepin-Wechat"></a>Deepin-QQ与Deepin-Wechat</h2><p>需要完整的QQ、Wechat体验，可以安装Deepin应用，在Manjaro中，由于有AUR源、Archlinuxcn源的加持，安装过程是非常方便的。<br>安装微信，只需在AUR中找到并安装deepin-wine-wechat；安装QQ，只需在AUR中找到并安装deepin-wine-tim或者deepin-wine-qq即可。<br>安装软件包后，打开软件，按照提示完成进一步的安装配置之后就可使用。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><h4 id="TIM"><a href="#TIM" class="headerlink" title="TIM"></a>TIM</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -S deepin-wine-tim</span><br></pre></td></tr></table></figure><h4 id="QQ"><a href="#QQ" class="headerlink" title="QQ"></a>QQ</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -S deepin-wine-qq</span><br></pre></td></tr></table></figure><h4 id="wechat"><a href="#wechat" class="headerlink" title="wechat"></a>wechat</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -S deepin-wine-wechat</span><br></pre></td></tr></table></figure><h3 id="DPI"><a href="#DPI" class="headerlink" title="DPI"></a>DPI</h3><p>安装完成后，会发现字体比较小，使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WINEPREFIX=~/.deepinwine/Deepin-QQ deepin-wine winecfg <span class="comment">#修改QQ的DPI</span></span><br><span class="line">WINEPREFIX=~/.deepinwine/Deepin-TIM deepin-wine winecfg <span class="comment">#修改TIM的DPI</span></span><br></pre></td></tr></table></figure><p>则可以调整DPI了<br><img src="/img/dpi.jpg" alt="DPI调整"><br>对于微信，可以使用网页版，也可以去Github下载高手封装好了的网页版微信，就不用打开浏览器登入微信啦</p><h3 id="无法显示图片"><a href="#无法显示图片" class="headerlink" title="无法显示图片"></a>无法显示图片</h3><p>聊天图片与头像无法显示，或者始终处于加载中，是因为QQ的图片解析与ipv6不兼容，需要关闭ipv6。<br>在终端使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo sysctl -w net.ipv6.conf.all.disable_ipv6=1</span><br><span class="line">sudo sysctl -w net.ipv6.conf.default.disable_ipv6=1</span><br><span class="line">sudo sysctl -w net.ipv6.conf.lo.disable_ipv6=1</span><br></pre></td></tr></table></figure><h6 id="Note：以上命令在深度Deepin-Linux系统下有效，其他Linux发行版可参考。我也没测试。我的安装好就能用🤣"><a href="#Note：以上命令在深度Deepin-Linux系统下有效，其他Linux发行版可参考。我也没测试。我的安装好就能用🤣" class="headerlink" title="Note：以上命令在深度Deepin Linux系统下有效，其他Linux发行版可参考。我也没测试。我的安装好就能用🤣"></a>Note：以上命令在深度Deepin Linux系统下有效，其他Linux发行版可参考。我也没测试。我的安装好就能用🤣</h6>]]></content>
    
    
    <summary type="html">&lt;p&gt;对于一般Linux用户，QQ，微信。是经常需要使用的东西。🙃&lt;br&gt;不过对于我这种，神一般的Linux用户而言。QQ啥的就不是很需要啦。🤣&lt;br&gt;“有事给我发电子邮件”，这是我常说的。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux之路" scheme="http://yoursite.com/categories/Linux%E4%B9%8B%E8%B7%AF/"/>
    
    
    <category term="Arch" scheme="http://yoursite.com/tags/Arch/"/>
    
    <category term="Manjaro" scheme="http://yoursite.com/tags/Manjaro/"/>
    
    <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
</feed>
