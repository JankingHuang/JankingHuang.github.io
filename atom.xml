<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jankin&#39;s Blog</title>
  
  
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-02-24T10:14:51.664Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Jankin Huang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>STL之Vectors</title>
    <link href="http://yoursite.com/2021/02/24/STL%E4%B9%8BVectors/"/>
    <id>http://yoursite.com/2021/02/24/STL%E4%B9%8BVectors/</id>
    <published>2021-02-24T07:42:15.000Z</published>
    <updated>2021-02-24T10:14:51.664Z</updated>
    
    <content type="html"><![CDATA[<p>Vector包含存储为数组的连续元素。访问向量的成员、添加元素可以在常数时间内完成，<br>而查找特定值或将元素插入向量需要线性时间。</p><a id="more"></a><h2 id="Vector-构造函数"><a href="#Vector-构造函数" class="headerlink" title="Vector 构造函数"></a>Vector 构造函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>();</span><br><span class="line"><span class="built_in">vector</span>( <span class="keyword">const</span> <span class="built_in">vector</span>&amp; c );</span><br><span class="line"><span class="built_in">vector</span>( size_type num, <span class="keyword">const</span> TYPE&amp; val = TYPE() );</span><br><span class="line"><span class="built_in">vector</span>( input_iterator start, input_iterator <span class="built_in">end</span> );</span><br></pre></td></tr></table></figure><ul><li>默认构造函数没有参数，创建一个新的实例对象vector。</li><li>第二个构造函数，是默认复制构造函数，创建<code>c</code>的副本。</li><li>第三个构造函数，创建一个具有<code>num</code>大小的空间，如果指定<code>val</code>的值。则<code>num</code>空间中默认初始值为<code>val。</code></li><li>最后一个构造函数，创建一个vector，并初始化值为<code>start</code>到<code>end</code>的元素值。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">       v.push_back(i);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// v 包含 0,1,2,3,4,5,6,7,8,9,10;</span></span><br><span class="line">   <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter1 = v.<span class="built_in">begin</span>();</span><br><span class="line">   iter1 += <span class="number">2</span>;  <span class="comment">//iter1 指向v中值为3的元素</span></span><br><span class="line">   <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter2 = v.<span class="built_in">end</span>();</span><br><span class="line">   iter2 -= <span class="number">3</span>; <span class="comment">//iter2 指向v中值为7的元素</span></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(iter1,iter2)</span></span>;<span class="comment">//[iter1,iter2) 赋值给a</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">auto</span> i: a)&#123;</span><br><span class="line">       <span class="built_in">cout</span> &lt;&lt; <span class="string">"res out:"</span>&lt;&lt;i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// res out : 2 3 4 5 6</span></span><br></pre></td></tr></table></figure><p><strong>所有这些构造函数都以线性时间运行，除了第一个以常数时间运行。</strong></p><h2 id="Vector-运算符重载"><a href="#Vector-运算符重载" class="headerlink" title="Vector 运算符重载"></a>Vector 运算符重载</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">TYPE&amp; <span class="keyword">operator</span>[]( size_type index );</span><br><span class="line"><span class="keyword">const</span> TYPE&amp; <span class="keyword">operator</span>[]( size_type index ) <span class="keyword">const</span>;</span><br><span class="line"><span class="built_in">vector</span> <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="built_in">vector</span>&amp; c2);</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> <span class="built_in">vector</span>&amp; c1, <span class="keyword">const</span> <span class="built_in">vector</span>&amp; c2);</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> <span class="built_in">vector</span>&amp; c1, <span class="keyword">const</span> <span class="built_in">vector</span>&amp; c2);</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> <span class="built_in">vector</span>&amp; c1, <span class="keyword">const</span> <span class="built_in">vector</span>&amp; c2);</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&gt;(<span class="keyword">const</span> <span class="built_in">vector</span>&amp; c1, <span class="keyword">const</span> <span class="built_in">vector</span>&amp; c2);</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;=(<span class="keyword">const</span> <span class="built_in">vector</span>&amp; c1, <span class="keyword">const</span> <span class="built_in">vector</span>&amp; c2);</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&gt;=(<span class="keyword">const</span> <span class="built_in">vector</span>&amp; c1, <span class="keyword">const</span> <span class="built_in">vector</span>&amp; c2)</span><br></pre></td></tr></table></figure><p><strong><code>const TYPE&amp; operator[]</code> 操作是以常数时间，其他都是线性时间</strong></p><h2 id="Vector-函数"><a href="#Vector-函数" class="headerlink" title="Vector 函数"></a>Vector 函数</h2><h3 id="assign"><a href="#assign" class="headerlink" title="assign"></a>assign</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">assign</span><span class="params">( size_type num, <span class="keyword">const</span> TYPE&amp; val )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">assign</span><span class="params">( input_iterator start, input_iterator <span class="built_in">end</span> )</span></span>;</span><br></pre></td></tr></table></figure><p>将<code>vector</code> 赋值为<code>num</code>个<code>val</code>; 或者<code>vector</code>赋值为从<code>start</code>到<code>end</code>的元素</p><p><strong>此函数将破坏向量的先前内容。</strong></p><h3 id="at"><a href="#at" class="headerlink" title="at"></a>at</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TYPE&amp; <span class="title">at</span><span class="params">( size_type loc )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> TYPE&amp; <span class="title">at</span><span class="params">( size_type loc )</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure><p>返回索引为<code>loc</code>的向量中元素的引用。 <code>at()</code>函数比<code>[]</code>运算符更安全，因为它不会让您引用向量的边界。</p><h3 id="back"><a href="#back" class="headerlink" title="back"></a>back</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TYPE&amp; <span class="title">back</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> TYPE&amp; <span class="title">back</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure><p>返回<code>vector</code>中最后一个元素的引用</p><h3 id="begin"><a href="#begin" class="headerlink" title="begin"></a>begin</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure><p>返回一个迭代器指向<code>vector</code>的首个元素，常数时间。</p><h3 id="capacity"><a href="#capacity" class="headerlink" title="capacity"></a>capacity</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">size_type <span class="title">capacity</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure><p>返回<code>vector</code>的容量，然后可以通过reserve() 重新定制大小。</p><blockquote><p>C ++容器旨在动态增加大小。这使程序员摆脱了不必担心在容器中存储任意数量的元素。然而，有时程序员可以通过提示来提高程序性能向编译器询问程序将使用的容器的大小。</p></blockquote><h3 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>删除<code>vector</code>所有元素，常数时间。</p><h3 id="empty"><a href="#empty" class="headerlink" title="empty"></a>empty</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure><p>判断<code>vector</code>是否为空。</p><h3 id="end"><a href="#end" class="headerlink" title="end"></a>end</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure><p>返回一个迭代器指向<code>vector</code>的追后一个元素的下一个位置。</p><h3 id="eras"><a href="#eras" class="headerlink" title="eras"></a>eras</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">( iterator loc )</span></span>;</span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">( iterator start, iterator <span class="built_in">end</span> )</span></span>;</span><br></pre></td></tr></table></figure><p>擦除一个元素或[start,end)个元素。返回擦除的最后一个元素。</p><h3 id="front"><a href="#front" class="headerlink" title="front"></a>front</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TYPE&amp; <span class="title">front</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> TYPE&amp; <span class="title">front</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure><p>返回第一元素。</p><h3 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">( iterator loc, <span class="keyword">const</span> TYPE&amp; val )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">( iterator loc, size_type num, <span class="keyword">const</span> TYPE&amp; val )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">( iterator loc, input_iterator start, input_iterator <span class="built_in">end</span> )</span></span>;</span><br></pre></td></tr></table></figure><ul><li>插入<code>val</code>在<code>loc</code>之后，放回插入元素位置的迭代器。</li><li>插入<code>num</code>个<code>val</code> 在<code>loc</code>之后。</li><li>插入<code>[start,end)</code> 区间内的元素，在<code>loc</code>之后。</li></ul><h3 id="max-size"><a href="#max-size" class="headerlink" title="max_size"></a>max_size</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure><p>返回<code>vector</code>在更多内存的情况下，允许分配的最大值。</p><p><strong>需要与<code>size()</code>和<code>capacity()</code>区分</strong></p><h3 id="pop-back"><a href="#pop-back" class="headerlink" title="pop_back"></a>pop_back</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>删除最后一个元素。</p><h3 id="push-back"><a href="#push-back" class="headerlink" title="push_back"></a>push_back</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">( <span class="keyword">const</span> TYPE&amp; val )</span></span>;</span><br></pre></td></tr></table></figure><p>添加一个元素到<code>vector</code>尾部。</p><h3 id="rbegin"><a href="#rbegin" class="headerlink" title="rbegin"></a>rbegin</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">reverse_iterator <span class="title">rbegin</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">const_reverse_iterator <span class="title">rbegin</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure><p>返回一个迭代器指向<code>vector</code>末尾的下一个元素。</p><h3 id="rend"><a href="#rend" class="headerlink" title="rend"></a>rend</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">reverse_iterator <span class="title">rend</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">const_reverse_iterator <span class="title">rend</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure><p>返回一个迭代器指向<code>vector</code>第一个元素。</p><h3 id="reserve"><a href="#reserve" class="headerlink" title="reserve"></a>reserve</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reserve</span><span class="params">( size_type <span class="built_in">size</span> )</span></span></span><br></pre></td></tr></table></figure><p>设置<code>vector</code>的容量最小大为<code>size</code>。</p><h3 id="resize"><a href="#resize" class="headerlink" title="resize"></a>resize</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">( size_type num, <span class="keyword">const</span> TYPE&amp; val = TYPE() )</span></span>;</span><br></pre></td></tr></table></figure><p>改变<code>vector</code>的大小，如果指定<code>val</code> 则新增的空间初始化为<code>val</code>。</p><h3 id="size"><a href="#size" class="headerlink" title="size"></a>size</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure><p>返回<code>vector</code>中元素的个数。</p><h3 id="swap"><a href="#swap" class="headerlink" title="swap"></a>swap</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">( container&amp; from )</span></span>;</span><br></pre></td></tr></table></figure><p>将<code>vector</code>的内容与<code>from</code>的内容进行交换，常数时间。</p><p>Vector 的介绍就先到这里吧，加油！！！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Vector包含存储为数组的连续元素。访问向量的成员、添加元素可以在常数时间内完成，&lt;br&gt;而查找特定值或将元素插入向量需要线性时间。&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
    <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="STL" scheme="http://yoursite.com/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>C++资源管理(堆、栈、RAII)</title>
    <link href="http://yoursite.com/2021/02/03/C-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86-%E5%A0%86%E3%80%81%E6%A0%88%E3%80%81RAII/"/>
    <id>http://yoursite.com/2021/02/03/C-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86-%E5%A0%86%E3%80%81%E6%A0%88%E3%80%81RAII/</id>
    <published>2021-02-03T04:27:54.000Z</published>
    <updated>2021-02-03T04:27:54.662Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux编写C51程序</title>
    <link href="http://yoursite.com/2021/01/19/Linux%E7%BC%96%E5%86%99C51%E7%A8%8B%E5%BA%8F/"/>
    <id>http://yoursite.com/2021/01/19/Linux%E7%BC%96%E5%86%99C51%E7%A8%8B%E5%BA%8F/</id>
    <published>2021-01-19T04:46:27.000Z</published>
    <updated>2021-01-20T04:45:42.606Z</updated>
    
    <content type="html"><![CDATA[<p>近期，在读<code>计算机程序设计艺术</code>这个书。之前尝试和很多次，在前面章节就没有咋看懂。很多人都说这是计算机界中的<code>圣经</code>。有时间闲下来读一些书，对于我来说是一件比较休闲的事情。平时基本上面对电子屏幕，我不想我的世界里离不开它。所以在很多娱乐的时候，我都选择一些跟电子设备不太相关的活动。ok,近期Blog更新也会比较慢。Let’s go 🎊</p><a id="more"></a><p>今天的正题是，如何在Linux搭建开发C51的开发环境。因为我手上一直有一块C51的开发板。<br><img src="/img/C51.jpg" alt="C51开发板"></p><h2 id="安装SDCC-Small-Device-C-Compiler"><a href="#安装SDCC-Small-Device-C-Compiler" class="headerlink" title="安装SDCC(Small Device C Compiler)"></a>安装SDCC(Small Device C Compiler)</h2><ul><li><a href="http://sdcc.sourceforge.net/">官方介绍</a></li></ul><blockquote><p>SDCC is a retargettable, optimizing Standard C (ANSI C89, ISO C99, ISO C11) compiler suite that targets the Intel MCS51 based microprocessors (8031, 8032, 8051, 8052, etc.), Maxim (formerly Dallas) DS80C390 variants, Freescale (formerly Motorola) HC08 based (hc08, s08), Zilog Z80 based MCUs (z80, z180, gbz80, Rabbit 2000/3000, Rabbit 3000A, TLCS-90), Padauk (pdk14, pdk15) and STMicroelectronics STM8. Work is in progress on supporting the Padauk (pdk13), Microchip PIC16 and PIC18 targets. It can be retargeted for other microprocessors.</p></blockquote><ul><li><p>sdcc 使用编译C51代码的。</p></li><li><p>Arch系列安装命令</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pacman -S sdcc  <span class="comment"># 安装sdcc</span></span><br></pre></td></tr></table></figure><ul><li><p>其他衍生版可以查看自己的软件仓库，或者自行下载</p></li><li><p><a href="http://sdcc.sourceforge.net/snap.php#Linux">下载地址</a></p></li></ul><h2 id="安装stcflash"><a href="#安装stcflash" class="headerlink" title="安装stcflash"></a>安装stcflash</h2><ul><li><p>使用Python编写，用于烧入sdcc生成的二进制文件</p></li><li><p>源码开源在Github</p></li><li><p>Arch系列安装命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yay -S stcflash-git <span class="comment"># 安装stcflash 在用户仓库中。</span></span><br></pre></td></tr></table></figure></li><li><p>其他衍生版可以查看自己的软件仓库，或者自行下载。解压皆可使用。</p></li></ul><p><code>注意：</code> 如果需要在终端如何地方打开，需要把<code>stcflash.py</code> 复制到<code>usr/bin/</code>目录下面。</p><ul><li><a href="https://github.com/laborer/stcflash">stcflash 更多使用说明</a></li></ul><h2 id="编写C51代码"><a href="#编写C51代码" class="headerlink" title="编写C51代码"></a>编写C51代码</h2><ul><li>需要包含<code>&lt;mcs51/&gt;8051.h&gt;头文件</code>。</li><li>引脚的定义为<code>P1_0</code>表示为<code>P1 io 口的第一个引脚</code> 。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;mcs51/8051.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> a,b;</span><br><span class="line">    <span class="keyword">for</span>(a=t; a &gt;<span class="number">0</span>;a--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(b=<span class="number">100</span>;b&gt;<span class="number">0</span>;b--);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P1_0 = <span class="number">0</span>;<span class="comment">//相当于keil c51 定义 P1^0</span></span><br><span class="line">        <span class="built_in">delay</span>(<span class="number">1000</span>);</span><br><span class="line">        P1_0 = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">delay</span>(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><ul><li>使用sdcc进行编译,生成.ihx 文件。</li><li>编译命令。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sdcc main.c -o main.ihx  <span class="comment"># -o 指定文件名</span></span><br></pre></td></tr></table></figure>如果语法正确，就能编译成功。否则请检查语法。🤞</li></ul><h2 id="转化"><a href="#转化" class="headerlink" title="转化"></a>转化</h2><ul><li>stcflash 烧入的文件是<code>.hex</code>。 我们需要转化<code>.hpx 为 .hex</code>。</li><li>转化命令<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ packihx main.ihx &gt; main.hex</span><br></pre></td></tr></table></figure></li></ul><h2 id="写入程序"><a href="#写入程序" class="headerlink" title="写入程序"></a>写入程序</h2><ul><li>利用stcflash 向开发版烧入<code>.hex</code>程序。</li><li>写入命令<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ stcflash main.hex</span><br></pre></td></tr></table></figure><h3 id="扩展命令"><a href="#扩展命令" class="headerlink" title="扩展命令"></a>扩展命令</h3><table><thead><tr><th>命令</th><th>作用</th><th>示例</th></tr></thead><tbody><tr><td>–port</td><td>指定写串口</td><td><code>$ stcflash --port  /dev/ttyUSB1</code></td></tr><tr><td>-lowbaud 1200</td><td>指定波特率</td><td><code>stacflash -lowbaud 1200</code></td></tr></tbody></table></li></ul><p>更多配置信息 阅读<a href="https://github.com/laborer/stcflash">Github</a></p><h2 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h2><ul><li>该动画<code>不</code>包含<code>sdcc</code>和<code>stcflash</code>的配置过程。</li><li>仅包含代码<code>编写</code>、<code>编译</code>、<code>转化</code>、<code>写入</code>等过程。<br><img src="/img/c51.gif" alt="代码编写及烧入演示"></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;近期，在读&lt;code&gt;计算机程序设计艺术&lt;/code&gt;这个书。之前尝试和很多次，在前面章节就没有咋看懂。很多人都说这是计算机界中的&lt;code&gt;圣经&lt;/code&gt;。有时间闲下来读一些书，对于我来说是一件比较休闲的事情。平时基本上面对电子屏幕，我不想我的世界里离不开它。所以在很多娱乐的时候，我都选择一些跟电子设备不太相关的活动。ok,近期Blog更新也会比较慢。Let’s go 🎊&lt;/p&gt;</summary>
    
    
    
    <category term="嵌入式开发" scheme="http://yoursite.com/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
    <category term="Development Environment" scheme="http://yoursite.com/tags/Development-Environment/"/>
    
    <category term="C51" scheme="http://yoursite.com/tags/C51/"/>
    
  </entry>
  
  <entry>
    <title>Emulator与主机软件socket通信</title>
    <link href="http://yoursite.com/2021/01/06/Emulator%E4%B8%8E%E4%B8%BB%E6%9C%BA%E8%BD%AF%E4%BB%B6socket%E9%80%9A%E4%BF%A1/"/>
    <id>http://yoursite.com/2021/01/06/Emulator%E4%B8%8E%E4%B8%BB%E6%9C%BA%E8%BD%AF%E4%BB%B6socket%E9%80%9A%E4%BF%A1/</id>
    <published>2021-01-06T02:20:02.000Z</published>
    <updated>2021-01-20T04:46:40.293Z</updated>
    
    <content type="html"><![CDATA[<p>我已经记不清楚，有多久没有更新博客。🙈<br>今天，我就研究了一下。<code>Android Emulator</code> 与 <code>主机</code>之间的网络通信。<br>以前使用的方法都是然emulator 和 主机连接同一个网络。要是没有外部网络的时候呢？</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在Android Developer 网站看了半天，只看到了下面这个<code>表</code>和<code>两个模拟器</code>如何通信</p><table><thead><tr><th>网络地址</th><th>说明</th></tr></thead><tbody><tr><td>10.0.2.1</td><td>路由器/网关地址</td></tr><tr><td>10.0.2.2</td><td>主机回环接口的特殊别名（即，开发计算机上的 127.0.0.1）</td></tr><tr><td>10.0.2.3</td><td>第一个 DNS 服务器</td></tr><tr><td>10.0.2.4 / 10.0.2.5 / 10.0.2.6</td><td>可选的第二个、第三个和第四个 DNS 服务器（如果有）</td></tr><tr><td>10.0.2.15</td><td>模拟设备网络/以太网接口</td></tr><tr><td>127.0.0.1</td><td>模拟设备回环接口</td></tr></tbody></table><p><a href="https://developer.android.com/studio/run/emulator-networking">表来源：emulator-networking</a></p><p>在看了老半天文档后，我就得出一个结果。我是不是语文不好！！<br>后来，我只能改用英文关键字进行搜索了。看到了一篇名为<code>ADB port forwarding and reversing</code> 。看完我就知道了，我的语文没问题。</p><p><a href="https://blog.usejournal.com/adb-port-forwarding-and-reversing-d2bc71835d43">文章来源：ADB port forwarding and reversing</a></p><h2 id="Android-Debug-Bridge-ADB"><a href="#Android-Debug-Bridge-ADB" class="headerlink" title="Android Debug Bridge(ADB)"></a>Android Debug Bridge(ADB)</h2><blockquote><p>Android调试桥（adb）是一种多功能的命令行工具，可让您与设备进行通信。adb命令可促进各种设备操作，例如安装和调试应用程序，并且提供对Unix shell的访问，您可以使用Unix shell在设备上运行各种命令。它是一个客户端服务器程序，包含三个组件：</p><p>客户端，发送命令。客户端在您的开发计算机上运行。您可以通过发出adb命令从命令行终端调用客户端。</p><p>守护程序（adbd），它在设备上运行命令。守护程序在每个设备上作为后台进程运行。</p><p>服务器，用于管理客户端和守护程序之间的通信。服务器在开发计算机上作为后台进程运行。</p></blockquote><p>整个过程，只会用到端口转发</p><blockquote><p>端口转发（即隧道传输）是一种幕后过程，该过程是拦截前往计算机IP /端口组合的数据流量并将其重定向到其他IP和/或端口的。在目标计算机（主机）上运行的程序通常会导致重定向，但有时也可以是中间硬件组件，例如路由器，代理服务器或防火墙。</p></blockquote><h2 id="端口转发"><a href="#端口转发" class="headerlink" title="端口转发"></a>端口转发</h2><ul><li>使用<code>forward</code>命令设置任意端口转发，该转发将特定主机端口上的请求转发到设备上的其他端口。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb forward tcp:6100 tcp:7100</span><br><span class="line"><span class="comment">#设置将主机端口6100转发到模拟器端口7100</span></span><br></pre></td></tr></table></figure><ul><li>使用<code>reverse</code>命令进行反向转发</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb reverse tcp:3000 tcp:3001</span><br><span class="line"><span class="comment"># 模拟器的端口3000重定向到计算机的端口30001</span></span><br></pre></td></tr></table></figure><h2 id="相关参数"><a href="#相关参数" class="headerlink" title="相关参数"></a>相关参数</h2><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>forward/reverser –list</td><td>list all forward socket connections</td></tr><tr><td>forward/reverser –remove LOCAL</td><td>remove specific forward socket connection</td></tr><tr><td>forward/reverser –remove-all</td><td>remove all forward socket connections</td></tr></tbody></table><p>今天，就到这里。终于把这个坑给填上了🎊🎊🎊</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我已经记不清楚，有多久没有更新博客。🙈&lt;br&gt;今天，我就研究了一下。&lt;code&gt;Android Emulator&lt;/code&gt; 与 &lt;code&gt;主机&lt;/code&gt;之间的网络通信。&lt;br&gt;以前使用的方法都是然emulator 和 主机连接同一个网络。要是没有外部网络的时候呢？&lt;/p&gt;</summary>
    
    
    
    <category term="嵌入式开发" scheme="http://yoursite.com/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
    <category term="Socket" scheme="http://yoursite.com/tags/Socket/"/>
    
    <category term="TCP" scheme="http://yoursite.com/tags/TCP/"/>
    
    <category term="UDP" scheme="http://yoursite.com/tags/UDP/"/>
    
    <category term="Development Environment" scheme="http://yoursite.com/tags/Development-Environment/"/>
    
  </entry>
  
  <entry>
    <title>我的Linux桌面环境</title>
    <link href="http://yoursite.com/2020/11/27/%E6%88%91%E7%9A%84Linux%E6%A1%8C%E9%9D%A2%E7%8E%AF%E5%A2%83/"/>
    <id>http://yoursite.com/2020/11/27/%E6%88%91%E7%9A%84Linux%E6%A1%8C%E9%9D%A2%E7%8E%AF%E5%A2%83/</id>
    <published>2020-11-27T12:17:43.000Z</published>
    <updated>2020-11-27T13:31:35.165Z</updated>
    
    <content type="html"><![CDATA[<p>今天，我是来填坑的。前段时间挖了这个坑，今天就把它填上。</p><p>这篇Blog是<a href="/2020/11/02/%E6%88%91%E7%9A%84Linux/">我与Linux的爱恨情仇</a>后续之作。</p><a id="more"></a><h2 id="我的Linxu软件"><a href="#我的Linxu软件" class="headerlink" title="我的Linxu软件"></a>我的Linxu软件</h2><h3 id="开发文档查看工具"><a href="#开发文档查看工具" class="headerlink" title="开发文档查看工具"></a>开发文档查看工具</h3><ul><li><p>Zeal</p></li><li><p>安装方式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pacman -S zeal</span><br><span class="line"><span class="comment">#如果打不开，提示是Qt的相关问题</span></span><br><span class="line"><span class="comment">#可以去github下载源代码，然后编译就可以用了</span></span><br></pre></td></tr></table></figure></li><li><p>代码仓库</p><blockquote><p><a href="https://github.com/zealdocs/zeal">https://github.com/zealdocs/zeal</a></p></blockquote></li><li><p>软件界面<br><img src="/img/zeal.png" alt="Zeal"></p></li></ul><h3 id="桌面程序开发"><a href="#桌面程序开发" class="headerlink" title="桌面程序开发"></a>桌面程序开发</h3><ul><li>Qt,KDE就是使用Qt开发的，我越来越喜欢Qt了。</li><li>安装方式<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pacman -S qtcreator</span><br></pre></td></tr></table></figure></li><li>软件界面<br><img src="/img/qt.png" alt="Qt Creator"></li></ul><h3 id="团队沟通工具"><a href="#团队沟通工具" class="headerlink" title="团队沟通工具"></a>团队沟通工具</h3><p>  我用过很多，就目前而言国内的都不好用。</p><ul><li>Microsoft Teams(非常好用，除了网络问题)</li><li>安装方式<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pacman -S teams-insiders</span><br><span class="line"><span class="comment">#软件仓库中，就是有insider版。</span></span><br><span class="line"><span class="comment">#官方网站可以下载正式版的</span></span><br></pre></td></tr></table></figure></li><li>软件界面<br><img src="/img/teams.png" alt="Microsoft Teams"></li></ul><h3 id="录屏推流软件"><a href="#录屏推流软件" class="headerlink" title="录屏推流软件"></a>录屏推流软件</h3><p>我为了用Linux开会，也是愁死我了。<br>最后，只能使用OBS进行推流共享屏幕了。</p><ul><li>OBS Studio</li><li>安装方式<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pacman -S obs-studio</span><br></pre></td></tr></table></figure></li><li>软件界面<br><img src="/img/obs.png" alt="OBS Studio"></li></ul><h3 id="RSS订阅软件"><a href="#RSS订阅软件" class="headerlink" title="RSS订阅软件"></a>RSS订阅软件</h3><p>这软件我是找了好久，以前还打算自己用Qt写一个。<br>这是我每天基本都是打开的软件。</p><ul><li>Akregator</li><li>安装方式<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pacman -S akregator</span><br></pre></td></tr></table></figure></li><li>软件界面<br><img src="/img/akregator.png" alt="Akregator"></li></ul><h3 id="远程控制软件"><a href="#远程控制软件" class="headerlink" title="远程控制软件"></a>远程控制软件</h3><p>我也是听我朋友说，才知道TeamViewer有全平台版本，就是目前功能不全。</p><ul><li>TeamViewer</li><li>安装方式<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pacman -S teamviewer</span><br></pre></td></tr></table></figure></li><li>软件界面<br><img src="/img/tv.png" alt="TeamViewer"></li></ul><h3 id="资源下载"><a href="#资源下载" class="headerlink" title="资源下载"></a>资源下载</h3><p>我以前写过一篇qBittorrent的博客</p><ul><li>qBittorrent enhanced editors (增强版，会自动更新tracker服务器列表)</li><li>Github<blockquote><p><a href="https://github.com/c0re100/qBittorrent-Enhanced-Edition">https://github.com/c0re100/qBittorrent-Enhanced-Edition</a></p></blockquote></li><li>软件界面<br><img src="/img/qbit.png" alt="qBittorrent"></li></ul><h3 id="网络仿真"><a href="#网络仿真" class="headerlink" title="网络仿真"></a>网络仿真</h3><ul><li>我在计算机网络实验课程，用来做实验的。</li><li>Cisco Packet Tracer</li><li>安装命令<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pacman -S packettracer</span><br></pre></td></tr></table></figure></li><li>软件界面<br><img src="/img/packetTracer.png" alt="Cisco Packet Tracer"></li></ul><p>这个故事就到这里吧🎊🎊🎊</p><p>Linux没有你想的那么好，但也没有你想的那么差。<br><img src="/img/desktop.png" alt="我的桌面"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天，我是来填坑的。前段时间挖了这个坑，今天就把它填上。&lt;/p&gt;
&lt;p&gt;这篇Blog是&lt;a href=&quot;/2020/11/02/%E6%88%91%E7%9A%84Linux/&quot;&gt;我与Linux的爱恨情仇&lt;/a&gt;后续之作。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux之路" scheme="http://yoursite.com/categories/Linux%E4%B9%8B%E8%B7%AF/"/>
    
    
    <category term="Arch" scheme="http://yoursite.com/tags/Arch/"/>
    
    <category term="Manjaro" scheme="http://yoursite.com/tags/Manjaro/"/>
    
    <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>EduCoder-Java面向对象之包装类</title>
    <link href="http://yoursite.com/2020/11/27/EduCoder-Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E5%8C%85%E8%A3%85%E7%B1%BB/"/>
    <id>http://yoursite.com/2020/11/27/EduCoder-Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E5%8C%85%E8%A3%85%E7%B1%BB/</id>
    <published>2020-11-27T11:20:48.000Z</published>
    <updated>2020-11-27T12:15:44.838Z</updated>
    
    <content type="html"><![CDATA[<p>我已经忘记了，上次更新博客是什么时候🤣。<br>电脑上也有不少的知识点碎片没有整理，也许是我比较懒。</p><a id="more"></a><p>这几天，学校出了教学事故。上了半个学期的Java Spring boot开发，<br>才知道同学没有学过Java，。🤪<br><del>我也就只能偷偷笑了，反正我也不喜欢Spring boot开发(为啥呢？？ 后期更新说明)</del><br>然后，学校就把Spring boot 的课程改成了Java(网课，Spring boot 也是一直上网课)。<br>第一节课就是配个环境，对于我Linux用户配java环境不存在的(<del>就是这么霸气</del>)。<br>不过，老师提供了在Educoder上的课程安排。</p><p>我就用了几天的课余时间刷了一下Java题目，回顾一下Java语言。</p><h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><ul><li><p>在JAVA中，八大基础数据类型（int,float,double…）是不具备对象的特征的，比如基本数据类型就不能调用方法，功能简单，为了让基本数据类型也具备对象的特征，就有了JAVA<code>包装类(Wrapper Classes)</code>。</p></li><li><p>基础数据类型是没有属性的，也是不能调用方法的。</p></li><li><p>包装类就是：将基本数据类型包装成对象，使其具有了对象的属性和方法。<br>这样就可以使用方法和属性了。</p></li></ul><h3 id="包装类作用"><a href="#包装类作用" class="headerlink" title="包装类作用"></a>包装类作用</h3><ul><li><p>将本类型与其他类型进行转换；</p></li><li><p>将字符串与本类型及包装类型相互转换。</p></li></ul><h3 id="包装类使用方式"><a href="#包装类使用方式" class="headerlink" title="包装类使用方式"></a>包装类使用方式</h3><ul><li><p>很简单把TA当成对象就可以了(<del>sorry,忘了你没有对象</del>)</p></li><li><p>代码如下:🍖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="keyword">new</span> Integer(<span class="number">100</span>);</span><br><span class="line">Integer j = <span class="number">100</span>;</span><br></pre></td></tr></table></figure><p>以上两种方式都可以。</p></li><li><p><code>基本数据类型</code>转换成<code>包装类</code>的过程叫做<code>装箱(boxing)</code>。</p></li><li><p><code>包装类</code>转换成<code>基本数据类型</code>的过程叫做<code>拆箱(unboxing)</code>。</p></li><li><p>代码如下：🍖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">Integer x= <span class="keyword">new</span> Integer(i);  <span class="comment">//手动装箱</span></span><br><span class="line">Integer y = i; <span class="comment">//自动装箱</span></span><br><span class="line"></span><br><span class="line">Integer j = <span class="keyword">new</span> Integer(<span class="number">9</span>);</span><br><span class="line">iint m = j.intValue(); <span class="comment">//手动拆箱</span></span><br><span class="line"><span class="keyword">int</span> n = j;<span class="comment">//自动拆箱</span></span><br></pre></td></tr></table></figure><p>装箱和拆箱可以分为<code>手动--</code>和<code>自动--(autoboxing)</code>。</p></li></ul><p><code>这里的手动(EduCoder上是这么说的)，我并没有找到官方的说法。</code></p><ul><li><p>官方说法🔗</p><blockquote><p><a href="(https://docs.oracle.com/javase/7/docs/technotes/guides/language/autoboxing.html)">Autoboxing<br>As any Java programmer knows, you can’t put an int (or other primitive value) into a collection. Collections can only hold object references, so you have to box primitive values into the appropriate wrapper class (which is Integer in the case of int). When you take the object out of the collection, you get the Integer that you put in; if you need an int, you must unbox the Integer using the intValue method. All of this boxing and unboxing is a pain, and clutters up your code. The autoboxing and unboxing feature automates the process, eliminating the pain and the clutter.</a></p></blockquote></li><li><p>Autoboxing 是为了简化使用Collection时，从基本类型到包转类型，使用结束后，又要从包装类型转化到基本类型的繁琐过程。</p></li></ul><h3 id="基础类型和包装类"><a href="#基础类型和包装类" class="headerlink" title="基础类型和包装类"></a>基础类型和包装类</h3><table><thead><tr><th>基本类型</th><th>对应的包装类型</th></tr></thead><tbody><tr><td>bye</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>char</td><td>Character</td></tr><tr><td>boolean</td><td>Boolean</td></tr></tbody></table><p>上图，就是两者的对应关系了。</p><p>说了一大堆，感觉没啥用呀。<del>其实我就是为了水一期博客😝</del></p><p>好吧，这里是为了后面Java <code>Collection</code>做准备，Collection 相当于C++里面的<code>STL</code>,今天就到这里吧！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我已经忘记了，上次更新博客是什么时候🤣。&lt;br&gt;电脑上也有不少的知识点碎片没有整理，也许是我比较懒。&lt;/p&gt;</summary>
    
    
    
    <category term="回归之路" scheme="http://yoursite.com/categories/%E5%9B%9E%E5%BD%92%E4%B9%8B%E8%B7%AF/"/>
    
    
    <category term="EduCoder" scheme="http://yoursite.com/tags/EduCoder/"/>
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>基本排序算法</title>
    <link href="http://yoursite.com/2020/11/22/%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2020/11/22/%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</id>
    <published>2020-11-22T12:18:22.000Z</published>
    <updated>2020-11-23T07:26:52.644Z</updated>
    
    <content type="html"><![CDATA[<p>半个月没写博客了，两个星期前结束了HMTL课程。然后就考完试了，终于不用上这么无聊的课程了。<br>博客有时间还是要坚持写的，今天就开始吧。</p><a id="more"></a><p>今天就来看看，下面这些基本算法吧！ </p><h2 id="Selection-Sort"><a href="#Selection-Sort" class="headerlink" title="Selection-Sort"></a>Selection-Sort</h2><ul><li>选择排序。</li><li>时间复杂度O(n^2)、空间复杂度O(1)。</li><li>采用双重遍历，内层遍历没次寻找[i,n)区间里的最小值<br>然后，与第i个元素进行交换( [0,i) 区间为有序序列)。</li><li>图解如下：<br><img src="/img/selection-sort.jpg" alt="Selection-Sort"></li><li>代码如下：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++)&#123;</span><br><span class="line">        <span class="comment">// 寻找[i, n)区间里的最小值</span></span><br><span class="line">        <span class="keyword">int</span> minIndex = i;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j = i + <span class="number">1</span> ; j &lt; n ; j ++ )</span><br><span class="line">            <span class="keyword">if</span>( arr[j] &lt; arr[minIndex] )</span><br><span class="line">                minIndex = j;</span><br><span class="line">        swap( arr[i] , arr[minIndex] );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Insertion-Sort"><a href="#Insertion-Sort" class="headerlink" title="Insertion-Sort"></a>Insertion-Sort</h2></li><li>插入排序。</li><li>时间复杂度O(n^2)、空间复杂度O(1);</li><li>采用双重遍历，单独看最左边的原始为有序(任意一个单独的元素都为有序序列)。选择该元素的下一元素，插入到前面的有序序列中，是该序列依旧有序。</li><li>图解如下：<br><img src="/img/insertion-sort.jpg" alt="Insertion-Sort"></li><li>代码如下：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(T arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n ; i ++ ) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 寻找元素arr[i]合适的插入位置</span></span><br><span class="line">        <span class="comment">//[0,i-1)区间为有序序列，[i-1,n) 为待遍历序列。</span></span><br><span class="line">       <span class="keyword">for</span>( <span class="keyword">int</span> j = i ; j &gt; <span class="number">0</span> ; j-- )</span><br><span class="line">           <span class="keyword">if</span>( arr[j] &lt; arr[j<span class="number">-1</span>] )</span><br><span class="line">               swap( arr[j] , arr[j<span class="number">-1</span>] );</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Bubble-Sort"><a href="#Bubble-Sort" class="headerlink" title="Bubble-Sort"></a>Bubble-Sort</h2></li><li>冒泡排序 (这个好熟悉呀)</li><li>时间复杂度O(n^2)、空间复杂度O(1);</li><li>采用双重遍历，每次内层需要寻找最大的元素，使该元素沉到数组尾部(有序序列的最前面)。</li><li>图解如下：<br><img src="/img/bubble-sort.jpg" alt="Bubble-Sort"></li><li>代码如下：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bubble</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span>; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span> ; ++j)</span><br><span class="line">            <span class="keyword">if</span>(nums[j]  &gt;  nums[j + <span class="number">1</span>])</span><br><span class="line">                swap(nums[j],nums[j+<span class="number">1</span>]); </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Shell-Sort"><a href="#Shell-Sort" class="headerlink" title="Shell-Sort"></a>Shell-Sort</h2></li><li>希尔排序 (日常见的比较少)。</li><li>时间复杂度O(n^1.3) 空间复杂度O(1)。</li><li>希尔排序又称缩小增量排序，基于插入排序。基本思想是划分多组分别进行插入排序。</li><li>图解如下：<br><img src="/img/shell-sort.jpg" alt="Shell-Sort"></li><li>代码如下:<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//增量gap，并逐步缩小增量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> gap = arr.<span class="built_in">size</span>() / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//从第gap个元素，逐个对其所在组进行直接插入排序操作</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; arr.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line">            <span class="keyword">while</span> (j - gap &gt;= <span class="number">0</span> &amp;&amp; arr[j] &lt; arr[j - gap])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//插入排序采用交换法</span></span><br><span class="line">                swap(arr, j, j - gap);</span><br><span class="line">                j -= gap;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>基本排序算法时间复杂度基本都是O(n^2)，shell-sort时间复杂度度也达不到O(n)。🙄</p><p>今天就到这里吧～～～ bye.💝</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;半个月没写博客了，两个星期前结束了HMTL课程。然后就考完试了，终于不用上这么无聊的课程了。&lt;br&gt;博客有时间还是要坚持写的，今天就开始吧。&lt;/p&gt;</summary>
    
    
    
    
    <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
    <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>STL容器分类</title>
    <link href="http://yoursite.com/2020/11/09/STL%E5%AE%B9%E5%99%A8%E5%88%86%E7%B1%BB/"/>
    <id>http://yoursite.com/2020/11/09/STL%E5%AE%B9%E5%99%A8%E5%88%86%E7%B1%BB/</id>
    <published>2020-11-09T08:51:16.000Z</published>
    <updated>2021-02-24T07:46:57.439Z</updated>
    
    <content type="html"><![CDATA[<p>C++ STL(Standard Template Library) 标准模板库，<br>是类模板的通用集合。</p><a id="more"></a><h2 id="STL结构"><a href="#STL结构" class="headerlink" title="STL结构"></a>STL结构</h2><p>STL 结构分为三类</p><h2 id="Sequences-顺序"><a href="#Sequences-顺序" class="headerlink" title="Sequences(顺序)"></a>Sequences(顺序)</h2><ul><li><p>Vectors</p></li><li><p>Lists</p></li><li><p>Double-Ended Queues</p></li></ul><h2 id="Container-Adapters-容器适配器"><a href="#Container-Adapters-容器适配器" class="headerlink" title="Container Adapters(容器适配器)"></a>Container Adapters(容器适配器)</h2><ul><li><p>Stacks</p></li><li><p>Queus</p></li><li><p>Priority Queues</p></li></ul><h2 id="Associative-Containser-关联容器"><a href="#Associative-Containser-关联容器" class="headerlink" title="Associative Containser(关联容器)"></a>Associative Containser(关联容器)</h2><ul><li><p>Bitsets</p></li><li><p>Maps</p></li><li><p>Multimaps</p></li><li><p>Sets</p></li><li><p>MultiSets</p></li></ul><h2 id="Iterators-迭代器"><a href="#Iterators-迭代器" class="headerlink" title="Iterators(迭代器)"></a>Iterators(迭代器)</h2><p>在使用STL过程经常需要访问Container中的元素，Iterator是不可少的。</p><ul><li><p>迭代器用于访问容器类的成员，并且可以在类似的情况下使用指针的方式。例如，可能使用迭代器逐步遍历元素。</p></li><li><p>迭代器共分为六种</p></li></ul><h3 id="input-iterator"><a href="#input-iterator" class="headerlink" title="input_iterator"></a>input_iterator</h3><p>只能一次一个向前读取元素，按此顺序一个个传回元素值。</p><h3 id="output-iterator"><a href="#output-iterator" class="headerlink" title="output_iterator"></a>output_iterator</h3><p>Output迭代器和Input迭代器相反，其作用是将元素值一个个写入。</p><h3 id="forward-iterator"><a href="#forward-iterator" class="headerlink" title="forward_iterator"></a>forward_iterator</h3><p>Forward迭代器是Input迭代器与Output迭代器的结合，具有Input迭代器的全部功能和Output迭代器的大部分功能。</p><h3 id="bidirectional-iterator"><a href="#bidirectional-iterator" class="headerlink" title="bidirectional_iterator"></a>bidirectional_iterator</h3><p>Bidirectional（双向）迭代器在Forward迭代器的基础上增加了回头遍历的能力。换言之，它支持递减操作符，用以一步一步的后退操作。</p><h3 id="random-iterator"><a href="#random-iterator" class="headerlink" title="random_iterator"></a>random_iterator</h3><p>Random Access迭代器在Bidirectional迭代器的基础上再增加随机存取能力。因此它必须提供“迭代器算数运算”（和一般指针“指针算术运算”相当）。</p><h3 id="reverse-iterator"><a href="#reverse-iterator" class="headerlink" title="reverse_iterator"></a>reverse_iterator</h3><p>逆向迭代器重新定义递增运算和递减运算，使其行为正好倒置。成员函数rbegin()和rend()各传回一个Reverse迭代器，和begin()和end()类似，共同定义一个半开区间。</p><p>在后续，我会从Sequences的Vectors到MultiSets逐步编写博文。加油!!</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;C++ STL(Standard Template Library) 标准模板库，&lt;br&gt;是类模板的通用集合。&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
    <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="STL" scheme="http://yoursite.com/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>Linux相关网络命令</title>
    <link href="http://yoursite.com/2020/11/08/Linux%E7%9B%B8%E5%85%B3%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2020/11/08/Linux%E7%9B%B8%E5%85%B3%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4/</id>
    <published>2020-11-08T12:36:23.000Z</published>
    <updated>2020-11-08T12:53:06.586Z</updated>
    
    <content type="html"><![CDATA[<p>搞了几天运动会，今天才意识到计算机网络的实验报告还没有写完。不过上实验课程的时候，我都把命令敲过了一篇(ping,ipconfig,arp,netstat)。<del>这些我以前就玩过，有点无聊</del></p><a id="more"></a><p>今天，我在linux下面敲这些命令的时候发现有些命令找不到。😭<br>我就查了一下🤔<del>热爱学习的我</del></p><h2 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h2><p>在Windows默认ping 4次。而在Linux下面需要用-c指定次数。</p><h2 id="ipconfig"><a href="#ipconfig" class="headerlink" title="ipconfig"></a>ipconfig</h2><p>可以使用ifconfig，不过有些版本的linux这个命令被取代了。需要是ip address show，就可以查看相关网络配置。</p><h2 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h2><p>地址解析协议，玩过kali局网攻击的话。就很熟悉啦！<br>这个命令在linux下面一样没有，代替命令是ip neighbor会列出 IP 对应的MAC地址。</p><h2 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h2><p>这个命令听说linux系统自带有，不过我的linux版本没有。只有默认的ss(Socket Statistics)命令。加入-t显示IP/TCP相关的信息</p><p>一个小小的命令记录。bye～～～</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;搞了几天运动会，今天才意识到计算机网络的实验报告还没有写完。不过上实验课程的时候，我都把命令敲过了一篇(ping,ipconfig,arp,netstat)。&lt;del&gt;这些我以前就玩过，有点无聊&lt;/del&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Linux之路" scheme="http://yoursite.com/categories/Linux%E4%B9%8B%E8%B7%AF/"/>
    
    
    <category term="Arch" scheme="http://yoursite.com/tags/Arch/"/>
    
    <category term="Manjaro" scheme="http://yoursite.com/tags/Manjaro/"/>
    
    <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>C++Lambda表达式</title>
    <link href="http://yoursite.com/2020/11/06/C-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/11/06/C-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2020-11-06T12:59:34.000Z</published>
    <updated>2020-11-06T13:19:13.578Z</updated>
    
    <content type="html"><![CDATA[<p>今天的每日一题，也是比较简单的！🎊<br>但我，查看官方题解时，我惊呆了。</p><a id="more"></a><p>我看到了如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sort(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), [&amp;](<span class="keyword">int</span> x, <span class="keyword">int</span> y) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bit</span>[x] &lt; <span class="built_in">bit</span>[y])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bit</span>[x] &gt; <span class="built_in">bit</span>[y])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x &lt; y;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我看了半天，没反应过来🤣，看完评论才知道是C++11 的新特性 Lambda表达式。</p><h2 id="Lambda表达式形式"><a href="#Lambda表达式形式" class="headerlink" title="Lambda表达式形式"></a>Lambda表达式形式</h2><blockquote><p>[外部变量访问说明符](参数列表)-&gt;返回值类型{</p><p>语句块</p><p>}</p></blockquote><ul><li>外部访问方式： =表示允许修改外部变量，&amp;不允许修改外部变量</li><li>参数列表：和普通函数一样</li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><ul><li>代码：<pre><code class="C++"><span class="keyword">int</span> a[<span class="number">4</span>] = {<span class="number">11</span>, <span class="number">2</span>, <span class="number">33</span>, <span class="number">4</span>};sort(a, a+<span class="number">4</span>, [=](<span class="keyword">int</span> x, <span class="keyword">int</span> y) -&gt; <span class="keyword">bool</span> {   <span class="keyword">return</span> x%<span class="number">10</span> &lt; y%<span class="number">10</span>;   } );for_each(a, a+<span class="number">4</span>, [=](<span class="keyword">int</span> x) {   <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">" "</span>;   } );</code></pre></li><li>结果： 11 2 33 4</li></ul><h2 id="外部变量"><a href="#外部变量" class="headerlink" title="外部变量"></a>外部变量</h2><ul><li>“外部变量访问方式说明符”还可以有更加复杂和灵活的用法。</li><li>[=, &amp;x, &amp;y]表示外部变量 x、y 的值可以被修改，其余外部变量不能被修改；</li><li>[&amp;, x, y]表示除 x、y 以外的外部变量，值都可以被修改。</li></ul><h2 id="Lambda表达式作用"><a href="#Lambda表达式作用" class="headerlink" title="Lambda表达式作用"></a>Lambda表达式作用</h2><ul><li><p>使用 STL 时，往往会大量用到函数对象，为此要编写很多函数对象类。有的函数对象类只用来定义了一个对象，而且这个对象也只使用了一次，编写这样的函数对象类就有点浪费。</p></li><li><p>说白了，就使用便捷👋</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天的每日一题，也是比较简单的！🎊&lt;br&gt;但我，查看官方题解时，我惊呆了。&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
    <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
    <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>我与Linux的爱恨情仇</title>
    <link href="http://yoursite.com/2020/11/02/%E6%88%91%E7%9A%84Linux/"/>
    <id>http://yoursite.com/2020/11/02/%E6%88%91%E7%9A%84Linux/</id>
    <published>2020-11-02T07:53:30.000Z</published>
    <updated>2020-11-27T13:28:06.788Z</updated>
    
    <content type="html"><![CDATA[<p>我与你第一次相遇，是在2016年。那个时候作为电脑小白的我，带着好奇心把你安装到了我电脑上，那个时候你叫Ubuntu16.04。💝</p><a id="more"></a><p>安装完成后，我失去是我的磁盘原有的所有数据🤔。我当时以为，你的安装方式和Windows是一样的。谁能想到你独吞我整个硬盘，使用你不到一天的时间，我就把Windows给重新安装上了。🤣</p><h2 id="我与Linux爱恨"><a href="#我与Linux爱恨" class="headerlink" title="我与Linux爱恨"></a>我与Linux爱恨</h2><p>后来，和你的见面方式都是在VMware里面了；你就没有单独存在于我的物理机里面。<br>在VMware里面，我尝试过很多的Linux系统。有CentOS、Redhat、Fedora；真正第一次认真敲入命令是在CentOS里面。那个时候，跟着教程一步一步的敲入命令。刚刚开始的时候，还经常敲错。😭</p><p>2018年，我遇到到一个IDE(Android Studio)，体会到什么叫编码两分钟，编译两小时(<del>其实是自己电脑太卡，联想G400</del>)的感觉。<br>每当我有空闲时间的时候，我都会打开浏览器。看看有没有什么可以优化编译的方法，的确通过修改Android Studio的一些配置可以加快编译。但是作用不是很大。🙄，还看到了很多关于Linux对硬件性能低的博客。</p><h2 id="我的Linux时代"><a href="#我的Linux时代" class="headerlink" title="我的Linux时代"></a>我的Linux时代</h2><p>2018年的冬天，我就在我的物理机里面安装Fedora系统。当时我还在我的VMware里面体验过，感觉不错。<br>可是，在实际中出现了几个问题。</p><ul><li>使用的人比较少，出了问题比较难解决。</li><li>我在安装51编译库的时候，发现编译工具的名称尽然不同。(<del>当时想骂人</del>)</li><li>对于国内用户QQ是非常重要的，Fedora安装QQ是比较困难的。</li></ul><p>用了不到一个星期。我就从Fedora，步入了Arch魔教的阵营(现在我新买的电脑上用Manjaro(基于arch开发的))。</p><p>从2018年到现在，我已经习惯了Linux的简洁和高效。<br>对于Linux，我喜欢一下几点 </p><ul><li>一切皆文件</li><li>拥有Root，拥有一切</li><li>一条命令，安装需要的软件。(next..next..next 不存在的)</li><li>我可以任意修改所有文件，达到我想要的效果。</li><li>我可以任意改动我的桌面布局，不需要安装任何额外的软件。</li><li>我可以切换不同的桌面环境。</li></ul><h2 id="我的Linux软件"><a href="#我的Linux软件" class="headerlink" title="我的Linux软件"></a>我的Linux软件</h2><p>下面说说，我日常使用哪些软件。</p><h3 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h3><ul><li>Google Chrome  (刚刚从chromuim切换过来)</li><li>安装方式<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pacman -S google-chrome</span><br></pre></td></tr></table></figure></li><li>软件界面<br><img src="/img/chrome.png" alt="Google Chrome"></li></ul><h3 id="编程工具"><a href="#编程工具" class="headerlink" title="编程工具"></a>编程工具</h3><h4 id="Android-开发"><a href="#Android-开发" class="headerlink" title="Android 开发"></a>Android 开发</h4><ul><li>Android Studio </li><li>安装方式<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pacman -S android-studio</span><br></pre></td></tr></table></figure></li><li>软件界面<br><img src="/img/android.png" alt="Android Studio"></li></ul><h4 id="Java开发"><a href="#Java开发" class="headerlink" title="Java开发"></a>Java开发</h4><ul><li>IntelliJ idea 社区版</li><li>安装方式<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pacman -S intellij-idea-community-edition</span><br></pre></td></tr></table></figure></li><li>软件界面<br><img src="/img/idea.png" alt="IntelliJ Idea"></li></ul><h4 id="C-开发"><a href="#C-开发" class="headerlink" title="C++开发"></a>C++开发</h4><ul><li>Visual Studio Code</li><li>这个编辑器结合插件非常好用，我写博客也是用这个</li><li>安装方式<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pacman -S visual-stduio-code-bin</span><br></pre></td></tr></table></figure></li><li>软件界面<br><img src="/img/vscode.png" alt="Visual Studio Code"></li></ul><h3 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h3><h4 id="VirtualBox"><a href="#VirtualBox" class="headerlink" title="VirtualBox"></a>VirtualBox</h4><ul><li>安装方式，看我以前写的如何安装Virtualbox的博客<h4 id="VMware（需要激活）"><a href="#VMware（需要激活）" class="headerlink" title="VMware（需要激活）"></a>VMware（需要激活）</h4></li><li>安装方式<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pacman -S vmware-workstation</span><br></pre></td></tr></table></figure>这个两个我都使用过，目前在使用vmware</li><li>软件界面<br><img src="/img/vmware.png" alt="VMware"></li></ul><h3 id="通讯"><a href="#通讯" class="headerlink" title="通讯"></a>通讯</h3><h4 id="QQ"><a href="#QQ" class="headerlink" title="QQ"></a>QQ</h4><ul><li>使用deepin的wine运行的TIM</li><li>安装方式<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pacman -S deepin.com.qq.office</span><br></pre></td></tr></table></figure></li><li>软件界面<br><img src="/img/tim.png" alt="QQ"></li></ul><h4 id="Evolution"><a href="#Evolution" class="headerlink" title="Evolution"></a>Evolution</h4><ul><li>这是一个电子邮箱客户端(主要用来给老师和学委发作业之类的)</li><li>安装方式<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pacman -S evolution</span><br></pre></td></tr></table></figure></li><li>软件界面<br><img src="/img/evolution.png" alt="Evolution"></li></ul><h3 id="AUR-助手工具"><a href="#AUR-助手工具" class="headerlink" title="AUR 助手工具"></a>AUR 助手工具</h3><ul><li>用来安装AUR(Arch User Repository)仓库的软件</li><li>安装方式<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pacman -S yay</span><br></pre></td></tr></table></figure></li><li>软件界面<br><img src="/img/yay.png" alt="YAY"></li></ul><h3 id="音乐"><a href="#音乐" class="headerlink" title="音乐"></a>音乐</h3><ul><li>落雪音乐助手，一款开源软件</li><li>安装方式,需要自己下载.pacman的包，然后安装<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pacman -U *.pacman</span><br></pre></td></tr></table></figure></li><li>直接下载Appimage后缀的，可以自己运行。</li><li>软件界面<br><img src="/img/lx.png" alt="落雪音乐助手"></li></ul><h3 id="office替代品"><a href="#office替代品" class="headerlink" title="office替代品"></a>office替代品</h3><ul><li>Micosoft office 的良好替代品</li><li>安装方式<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pacman -S wps-office</span><br></pre></td></tr></table></figure></li><li>软件界面<br><img src="/img/wps.png" alt="WPS"><br>今天就分享到这里吧，有些软件后续补上。🎊🎊</li></ul><p>希望，你也加入Linux</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我与你第一次相遇，是在2016年。那个时候作为电脑小白的我，带着好奇心把你安装到了我电脑上，那个时候你叫Ubuntu16.04。💝&lt;/p&gt;</summary>
    
    
    
    <category term="Linux之路" scheme="http://yoursite.com/categories/Linux%E4%B9%8B%E8%B7%AF/"/>
    
    
    <category term="Arch" scheme="http://yoursite.com/tags/Arch/"/>
    
    <category term="Manjaro" scheme="http://yoursite.com/tags/Manjaro/"/>
    
    <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>349.两个数组的交集</title>
    <link href="http://yoursite.com/2020/11/02/349-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/"/>
    <id>http://yoursite.com/2020/11/02/349-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/</id>
    <published>2020-11-02T07:07:19.000Z</published>
    <updated>2020-11-02T07:53:10.488Z</updated>
    
    <content type="html"><![CDATA[<p>今天的每日一题就很简单啦。🎊<br>今天就不废话了，直接上题目吧。</p><a id="more"></a><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>给定两个数组，编写一个函数来计算它们的交集。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><blockquote><p>输入：nums1 = [1,2,2,1], nums2 = [2,2]<br>输出：[2]</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul><li>最简单的方法，采用逐个比较。及nums1中的每个元素都与nums2中的每个元素进行比较，如果相等，这加入到容器中，再对容器进行去重就可以了。</li><li>代码如下<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">intersection</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums1.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums2.<span class="built_in">size</span>(); ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums1[i] == nums2[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    res.push_back(nums1[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator ite = unique(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        res.erase(ite, res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="更优解法"><a href="#更优解法" class="headerlink" title="更优解法"></a>更优解法</h2></li><li>官方解法<blockquote><p>如果两个数组是有序的，则可以使用双指针的方法得到两个数组的交集。</p><p>首先对两个数组进行排序，然后使用两个指针遍历两个数组。可以预见的是加入答案的数组的元素一定是递增的，为了保证加入元素的唯一性，我们需要额外记录变量 pre 表示上一次加入答案数组的元素。</p><p>初始时，两个指针分别指向两个数组的头部。每次比较两个指针指向的两个数组中的数字，如果两个数字不相等，则将指向较小数字的指针右移一位，如果两个数字相等，且该数字不等于 pre ，将该数字添加到答案并更新 pre 变量，同时将两个指针都右移一位。当至少有一个指针超出数组范围时，遍历结束。</p></blockquote></li></ul><p>今天题目就到这里吧！！ 这是我遇到比较简单的每日一题。🤪🤪🤪</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天的每日一题就很简单啦。🎊&lt;br&gt;今天就不废话了，直接上题目吧。&lt;/p&gt;</summary>
    
    
    
    <category term="修炼之路" scheme="http://yoursite.com/categories/%E4%BF%AE%E7%82%BC%E4%B9%8B%E8%B7%AF/"/>
    
    
    <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
    <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>381.O(1)插入删除和获取随机元</title>
    <link href="http://yoursite.com/2020/10/31/381-%E6%8F%92%E5%85%A5%E5%88%A0%E9%99%A4%E5%92%8C%E8%8E%B7%E5%8F%96%E9%9A%8F%E6%9C%BA%E5%85%83/"/>
    <id>http://yoursite.com/2020/10/31/381-%E6%8F%92%E5%85%A5%E5%88%A0%E9%99%A4%E5%92%8C%E8%8E%B7%E5%8F%96%E9%9A%8F%E6%9C%BA%E5%85%83/</id>
    <published>2020-10-31T12:20:10.000Z</published>
    <updated>2020-10-31T12:48:59.248Z</updated>
    
    <content type="html"><![CDATA[<p>我用了半天的时间，与上帝交换，只为换回你💝！<br>我午睡醒来，打开我的电脑。发现一块黑屏，只有一个鼠标，和左边的dock栏上的白色。<br>该来的总会来，这件事情还是发生！！</p><a id="more"></a><p>我的系统桌面KDE，终于不能用了。我花时间，把KDE换成了DDE(Deepin Desktop Environment)。<br>我也不知道什么原因，竟然不是很好用。有几个应用打不开，主要还是不适应DDE的风格。<br>我就又换回了KDE，安装过程倒是有些崎岖   。不过路边的风景也很美。</p><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>设计一个支持在平均 时间复杂度 O(1) 下， 执行以下操作的数据结构。</p><p>注意: 允许出现重复元素。</p><p>insert(val)：向集合中插入元素 val。<br>remove(val)：当 val 存在时，从集合中移除一个 val。<br>getRandom：从现有集合中随机获取一个元素。每个元素被返回的概率应该与其在集合中的数量呈线性相关。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><blockquote><p>// 初始化一个空的集合。</p><p>RandomizedCollection collection = new &gt; &gt; &gt; &gt; RandomizedCollection();</p><p>// 向集合中插入 1 。返回 true 表示集合不包含 1 。</p><p>collection.insert(1);</p><p>// 向集合中插入另一个 1 。返回 false 表示集合包含 1 。集合现在包含 [1,1] 。<br>collection.insert(1);</p><p>// 向集合中插入 2 ，返回 true 。集合现在包含 [1,1,2] 。</p><p>collection.insert(2);</p><p>// getRandom 应当有 2/3 的概率返回 1 ，1/3 的概率返回 2 。</p><p>collection.getRandom();</p><p>// 从集合中删除 1 ，返回 true 。集合现在包含 [1,2] 。</p><p>collection.remove(1);</p><p>// getRandom 应有相同概率返回 1 和 2 。</p><p>collection.getRandom();</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul><li>我的第一思路，还是用桶排序的方法，把需要插入的元素，插入到数组中。即array[val]++; （val为插入的元素）。遮掩插入和取出的时间复杂度都是O(1)，但是题目没有给出val的取值范围。如果动态变化数组，当val值大于array.size()时，需要移动数组，时间复杂度为O(n)。这显然有违背题目。😅</li><li>当我查看官方解法时，我发现我在STL上的盲区(<del>昨天说学，可是没学</del>)。</li><li>官方解法的思路是哈希表(C++中没有，需要自己实现。使用Map 和 Set就可以实现)。</li><li>代码如下：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomizedCollection</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;&gt; idx;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    RandomizedCollection() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        nums.push_back(val);</span><br><span class="line">        idx[val].insert(nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> idx[val].<span class="built_in">size</span>() == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes a value from the collection. Returns true if the collection contained the specified element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (idx.<span class="built_in">find</span>(val) == idx.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = *(idx[val].<span class="built_in">begin</span>());</span><br><span class="line">        nums[i] = nums.back();</span><br><span class="line">        idx[val].erase(i);</span><br><span class="line">        idx[nums[i]].erase(nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">            idx[nums[i]].insert(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (idx[val].<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            idx.erase(val);</span><br><span class="line">        &#125;</span><br><span class="line">        nums.pop_back();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get a random element from the collection. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nums[rand() % nums.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="更优解法"><a href="#更优解法" class="headerlink" title="更优解法"></a>更优解法</h2></li><li>这里涉及到我知识盲区😭😭😭，我就不写最优解法了。后期补上！！</li></ul><p>万圣节快乐，这是令人难忘的一天。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我用了半天的时间，与上帝交换，只为换回你💝！&lt;br&gt;我午睡醒来，打开我的电脑。发现一块黑屏，只有一个鼠标，和左边的dock栏上的白色。&lt;br&gt;该来的总会来，这件事情还是发生！！&lt;/p&gt;</summary>
    
    
    
    <category term="修炼之路" scheme="http://yoursite.com/categories/%E4%BF%AE%E7%82%BC%E4%B9%8B%E8%B7%AF/"/>
    
    
    <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
    <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>463.岛屿的周长</title>
    <link href="http://yoursite.com/2020/10/30/463-%E5%B2%9B%E5%B1%BF%E7%9A%84%E5%91%A8%E9%95%BF/"/>
    <id>http://yoursite.com/2020/10/30/463-%E5%B2%9B%E5%B1%BF%E7%9A%84%E5%91%A8%E9%95%BF/</id>
    <published>2020-10-30T09:02:25.000Z</published>
    <updated>2020-10-31T08:18:31.690Z</updated>
    
    <content type="html"><![CDATA[<p>在一个岛屿上生活，是我的梦想！😝</p><p>今天，leetcode给我这个机会。计算我岛屿的长度，但是他并没有给我这个岛。</p><a id="more"></a><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>给定一个包含 0 和 1 的二维网格地图，其中 1 表示陆地 0 表示水域。</p><p>网格中的格子水平和垂直方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。</p><p>岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><blockquote><p>输入:</p><p>[[0,1,0,0],</p><p>[1,1,1,0],</p><p>[0,1,0,0],</p><p> [1,1,0,0]]</p><p>输出: 16</p><p>解释: 它的周长是下面图片中的 16 个黄色的边：</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul><li>看到这题题目，我也没什么解题思路；就知道逐个去遍历，应该是可以解出来的。但是并没有清晰的编码思路。</li><li>对于一个陆地格子的每条边，它被算作岛屿的周长当且仅当这条边为网格的边界或者相邻的另一个格子为水域。 因此，我们可以遍历每个陆地格子，看其四个方向是否为边界或者水域，如果是，将这条边的贡献（即 11）加入答案 \textit{ans}ans 中即可。（官方解题思路）</li><li>官方提供的解题思路，就是遍历每一个正方形；然后看这个正方形的周围(右，下，左，上的遍历顺序，可以改变)时候有陆地或水域，如果有水域或者是网格的边缘，那周长就加1。</li><li>总时间复杂度为：O(4nm)=O(nm);空间复杂度：O(1)。</li><li>代码如下<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">islandPerimeter</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;grid)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].<span class="built_in">size</span>(); ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">int</span> tx = i + dx[k];</span><br><span class="line">                        <span class="keyword">int</span> ty = j + dy[k];</span><br><span class="line">                        <span class="keyword">if</span> (tx &lt; <span class="number">0</span> || tx &gt;= grid.<span class="built_in">size</span>() || ty &lt; <span class="number">0</span> || ty &gt;= grid[<span class="number">0</span>].<span class="built_in">size</span>() || !grid[tx][ty])</span><br><span class="line">                            cnt++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ans += cnt;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="更优解法"><a href="#更优解法" class="headerlink" title="更优解法"></a>更优解法</h2>这个就我点困难了(<del>这个题目，我也是看了官方的解释才懂的🤫</del>)，我后期补。最优解一定是有的！！</li></ul><p>对啦，祝大家万圣夜快乐🤪🤪🤪🤪</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在一个岛屿上生活，是我的梦想！😝&lt;/p&gt;
&lt;p&gt;今天，leetcode给我这个机会。计算我岛屿的长度，但是他并没有给我这个岛。&lt;/p&gt;</summary>
    
    
    
    <category term="修炼之路" scheme="http://yoursite.com/categories/%E4%BF%AE%E7%82%BC%E4%B9%8B%E8%B7%AF/"/>
    
    
    <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
    <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>1207.独一无二的出现次数</title>
    <link href="http://yoursite.com/2020/10/28/1207-%E7%8B%AC%E4%B8%80%E6%97%A0%E4%BA%8C%E7%9A%84%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0/"/>
    <id>http://yoursite.com/2020/10/28/1207-%E7%8B%AC%E4%B8%80%E6%97%A0%E4%BA%8C%E7%9A%84%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0/</id>
    <published>2020-10-28T11:42:05.000Z</published>
    <updated>2020-10-28T12:07:43.810Z</updated>
    
    <content type="html"><![CDATA[<p>今天，把个人博客的主题换了一个。没有以前那么好看了。但是访问速度提升了不少。以后，有时间的话。我还是打算美化一下，但是毕竟我不是搞前端的，个人博客对我而言就是拿来发发个人感想，记录个人生活的。<br>废话到这里🧑‍🔬，看题目吧～～～</p><a id="more"></a><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>给你一个整数数组 arr，请你帮忙统计数组中每个数的出现次数。</p><p>如果每个数的出现次数都是独一无二的，就返回 true；否则返回 false。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><blockquote><p>输入：arr = [1,2,2,1,1,3]</p><p>输出：true</p><p>解释：在该数组中，1 出现了 3 次，2 出现了 2 次，3 只出现了 1 次。没有两个数的出现次数相同。</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul><li><p>我看到这个题目，就想到了前一天，类似于桶排序的思路。<br>后面看到给出的数据范围，-1000&lt;= arr[i] &lt;= 1000，我就意识到了直接使用桶排序的思维是解决不了的(数组下标不能为负数)。😅</p></li><li><p>思考一会后，我想到了STL里面的Map（键值对的方式存储数据）。这里的键是一个泛型(这就可以解决直接使用数组，下标不能为负数的情况)，接着在使用桶排序的思想，对map里面的值进行统计。再判断统计数据的值是否大于1,如果大于一这出现了重复次数的数字。🎊🎊🎊🎊🎊(<del>撒花，掌声</del>)</p></li><li><p>时间复杂度约为O(3n),其实一般成为O(n);空间复杂度约为O(2n),也可以称作O(n)。</p></li><li><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">uniqueOccurrences</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;arr)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : arr)</span><br><span class="line">        &#123;</span><br><span class="line">            m[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">int</span> aux[<span class="number">1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : m)</span><br><span class="line">        &#123;</span><br><span class="line">            aux[i.second]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (aux[i] &gt; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id="更优解法"><a href="#更优解法" class="headerlink" title="更优解法"></a>更优解法</h2><p>无独有偶，在题目的评论区也有一个很有意思的解法。👋👋<br>作者是使用了STL库中的Map 和 Set。(当初我也有这想法，只是我对STL库不是用了解，<del>看来需要好好学习STL库呀</del>)</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">uniqueOccurrences</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.<span class="built_in">size</span>();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            m[arr[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;times;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> p:m)</span><br><span class="line">            times.insert(p.second);</span><br><span class="line">        <span class="keyword">return</span> times.<span class="built_in">size</span>()==m.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这段代码的帅气程度快要赶上我了（<del>不要脸</del>）🤞🤞🤞🎊🎊🎊</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天，把个人博客的主题换了一个。没有以前那么好看了。但是访问速度提升了不少。以后，有时间的话。我还是打算美化一下，但是毕竟我不是搞前端的，个人博客对我而言就是拿来发发个人感想，记录个人生活的。&lt;br&gt;废话到这里🧑‍🔬，看题目吧～～～&lt;/p&gt;</summary>
    
    
    
    <category term="修炼之路" scheme="http://yoursite.com/categories/%E4%BF%AE%E7%82%BC%E4%B9%8B%E8%B7%AF/"/>
    
    
    <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
    <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>1365.有多少小于当前数字的数字</title>
    <link href="http://yoursite.com/2020/10/26/1365-%E6%9C%89%E5%A4%9A%E5%B0%91%E5%B0%8F%E4%BA%8E%E5%BD%93%E5%89%8D%E6%95%B0%E5%AD%97%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>http://yoursite.com/2020/10/26/1365-%E6%9C%89%E5%A4%9A%E5%B0%91%E5%B0%8F%E4%BA%8E%E5%BD%93%E5%89%8D%E6%95%B0%E5%AD%97%E7%9A%84%E6%95%B0%E5%AD%97/</id>
    <published>2020-10-26T13:55:35.000Z</published>
    <updated>2020-10-28T12:09:21.143Z</updated>
    
    <content type="html"><![CDATA[<p>有几个月没有写博客，这段时间都是在刷leetcode去啦。今天刷完，才想起来我还有博客。🙃开启每日一题吧！ 加油🦤🦤🦤</p><a id="more"></a><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>给你一个数组 nums，对于其中每个元素 nums[i]，请你统计数组中比它小的所有数字的数目。<br>换而言之，对于每个 nums[i] 你必须计算出有效的 j 的数量，其中 j 满足 j != i 且 nums[j] &lt; nums[i] 。<br>以数组形式返回答案。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><blockquote><p>输入：nums = [8,1,2,2,3]</p><p>输出：[4,0,1,1,3]</p><p>解释：</p><p>对于 nums[0]=8 存在四个比它小的数字：（1，2，2 和 3）。 </p><p>对于 nums[1]=1 不存在比它小的数字。</p><p>对于 nums[2]=2 存在一个比它小的数字：（1）。 </p><p>对于 nums[3]=2 存在一个比它小的数字：（1）。 </p><p>对于 nums[4]=3 存在三个比它小的数字：（1，2 和 2）。</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul><li>第一想法，是对整个nums数组进行排序.nums[i]的元素就会有i个比它小的元素(包含重复的，不符合题意要求，去要出去重复的)。<br>但是，后来仔细一看题目。发现，这样会打破输入数组的序列。</li><li>第二想法，是通过两个索引遍历整个数组。即每个元素和其他元素做比较，如果nums[i] &gt; nums[j]，则计数加一。比较完成后再存入结果数组中。</li><li>时间复杂度是O(n^2),空间复杂度为O(n);</li><li>代码如下：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">smallerNumbersThanCurrent</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.<span class="built_in">size</span>(); ++j)</span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (nums.at(i) &gt; nums.at(j))</span><br><span class="line">                &#123;</span><br><span class="line">                    num++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id="更优解法"><a href="#更优解法" class="headerlink" title="更优解法"></a>更优解法</h2><p>当我提交完代后，我看了一下评论区。<br>可谓是藏龙卧虎呀！！</p><ul><li>整个代码设计的非常巧妙,采用类似于桶排序的思路</li><li>先生成最大数组的大小的长度(题目给出了测试数据集的范围)</li><li>然后，对整个nums数组进行计数</li><li>在计算第i个元素，前i个的数量(arr 数组元素越靠后，对应nums里的元素越大)</li><li>在通过nums数组，获取与nums对应的元素值，存入vector。</li><li>代码如下：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">smallerNumbersThanCurrent</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> arr[<span class="number">101</span>];</span><br><span class="line">        <span class="built_in">memset</span>(arr, <span class="number">0</span>, <span class="keyword">sizeof</span>(arr));</span><br><span class="line">        <span class="comment">// 初始化计数桶</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : nums) &#123;</span><br><span class="line">            arr[i] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 累加处理计数桶，使得 arr[i] 表示比 i 小的数字的个数</span></span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i ++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">            arr[i] = cnt;</span><br><span class="line">            cnt += temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">        <span class="comment">// 遍历 nums，取出对应桶 arr[i] 里的结果即可</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">            ret.push_back(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>可以基于这个代码进行下一步的优化，但是时间复杂度大致还是O(n)级别。<br>方法是提前结束循环。😝</li></ul><p>今天的每日一题就到这里吧🎊</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;有几个月没有写博客，这段时间都是在刷leetcode去啦。今天刷完，才想起来我还有博客。🙃开启每日一题吧！ 加油🦤🦤🦤&lt;/p&gt;</summary>
    
    
    
    <category term="修炼之路" scheme="http://yoursite.com/categories/%E4%BF%AE%E7%82%BC%E4%B9%8B%E8%B7%AF/"/>
    
    
    <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
    <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Konsole无法启动</title>
    <link href="http://yoursite.com/2020/08/30/Konsole%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8/"/>
    <id>http://yoursite.com/2020/08/30/Konsole%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8/</id>
    <published>2020-08-30T03:11:45.000Z</published>
    <updated>2020-10-26T14:32:37.098Z</updated>
    
    <content type="html"><![CDATA[<p>前几天，想实现打开终端自动显示系统相关信息。<br>于是我就在修改了 Konsole Profile 的 Command 加入了一个命令。<br>结果，konsole都打不开啦。</p><a id="more"></a><p>这就非常尴尬啦，需要改回Profile 需要先打开konsole 才行呀😝。<br>可是，现在就是打不开。</p><p>纵然寻他千百度 打开百度已掉进黑灯瞎火处。<br>这就是我不喜欢用百度的原因，啥都查不到。(啥都没有也敢叫百度呀！！)</p><p>“一切皆文件”,这条Linux哲学。在我脑海中呈现🤔。<br>我顿悟，我找到Konsole的配置文件，不久可以改回来啦吗？<br>根本就不需要图形界面的Profile呀！！</p><h2 id="Konsole-profile-配置文件"><a href="#Konsole-profile-配置文件" class="headerlink" title="Konsole profile 配置文件"></a>Konsole profile 配置文件</h2><ul><li>所在路径 ~/.locla/share/konsole/*.profile</li><li>修改Command 项里面参数(记得保存哦)</li><li>点击Konsole图标，就可以启动成功<br>这就ok啦</li></ul><blockquote><p>Note: 到这里Konsole 不能启动的问题就修复，下面完成我未尽的事业🤪</p></blockquote><h2 id="未尽事业🤣"><a href="#未尽事业🤣" class="headerlink" title="未尽事业🤣"></a>未尽事业🤣</h2><h3 id="新建一个文件"><a href="#新建一个文件" class="headerlink" title="新建一个文件"></a>新建一个文件</h3><ul><li>最后是.开头的隐藏文件</li><li>这个文件用来存放，终端启动需要自动执行的命令<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ touch .neofetchShow</span><br></pre></td></tr></table></figure></li></ul><h3 id="写入命令"><a href="#写入命令" class="headerlink" title="写入命令"></a>写入命令</h3><ul><li>把需要自动执行的命令，写入到文件中<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">'neofetch'</span> &gt;&gt; .neofetchShow</span><br></pre></td></tr></table></figure><blockquote><p>neofetch 命令需要自己安装</p></blockquote></li></ul><h3 id="修改shell配置文件"><a href="#修改shell配置文件" class="headerlink" title="修改shell配置文件"></a>修改shell配置文件</h3><ul><li>默认shell 的配置文件为～/.bashrc</li><li>zsh配置文件为~/.zshrc</li><li>将文件路径写入配置文件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.neofetchShow</span><br></pre></td></tr></table></figure></li><li>保存配置文件</li></ul><blockquote><p>Note: 以上上操作都在home目录下完成，如果配置失败了，请核对路径和需要启动的命令时候可以执行</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;前几天，想实现打开终端自动显示系统相关信息。&lt;br&gt;于是我就在修改了 Konsole Profile 的 Command 加入了一个命令。&lt;br&gt;结果，konsole都打不开啦。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux之路" scheme="http://yoursite.com/categories/Linux%E4%B9%8B%E8%B7%AF/"/>
    
    
    <category term="Arch" scheme="http://yoursite.com/tags/Arch/"/>
    
    <category term="Manjaro" scheme="http://yoursite.com/tags/Manjaro/"/>
    
    <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>永别ActiveWindowControl</title>
    <link href="http://yoursite.com/2020/08/20/%E6%B0%B8%E5%88%ABActiveWindowControl/"/>
    <id>http://yoursite.com/2020/08/20/%E6%B0%B8%E5%88%ABActiveWindowControl/</id>
    <published>2020-08-20T06:22:51.000Z</published>
    <updated>2020-10-26T14:33:18.382Z</updated>
    
    <content type="html"><![CDATA[<p>当初刚刚接触Ubuntu的时候,我就很喜欢Unity桌面的全局菜单整合功能,🎊<br>可以把窗口标题和全局菜单整合为一体.<br>这样就可以节省一行显示标题的空间.</p><a id="more"></a><p>可是后来,Ubuntu放弃啦Unity桌面,搞了Gnome桌面.👎<br>当初,其他衍生版搞Gnome桌面,他特立独行搞Unity现在有放弃.<br>这是我不喜欢Ubuntu的其中原因之一.</p><p>后来,在我的老电脑上,我已经转入了Arch魔教.<br>我是非常喜欢Arch的包管理器.这是非常Amazing.🤪</p><p>不过,现在在我的新电脑(Lenovo 小新13 Pro)已经使用Manjaro一段时间,<br>Manjaro是基于Arch开发的,Arch的一些优势基本上都有.<br>主要还是安装系统过程中,简便啦很多.</p><p>我使用的KDE桌面,是已经预装了全局菜单.不过还是不能实现Unity桌面的风格.<br>后来知道active Window Control 插件,可以实现这个功能,</p><p>我个人觉得这个东西不太友好,我几次配置都出现了桌面黑黑的(我也不知道是啥情况.).<br>而且,对于Window Title显示不太好,因为Title长度不一致,所以显示就有一些问题.<br>有强迫症的我,就能难忍受啦.😅</p><p>直到遇到了你,由<a href="https://github.com/psifidotos">psifidotos</a>开发的applet-window系列插件🤪<br>另外,提一下.这个位开发者处理Github issue 的速度是很快的.<br>由于我的无知(我对系统不熟悉),在Windos title 这个仓库中Open issue .没过多久他就回复我,<br>而且,非常友好的给出了解决我问题的方式.</p><h2 id="如何实现Unity桌面风格"><a href="#如何实现Unity桌面风格" class="headerlink" title="如何实现Unity桌面风格"></a>如何实现Unity桌面风格</h2><p>需要安装如下插件,目前这些都不在AUR仓库中,需要自己下载编译安装.</p><ul><li>applet-window-title</li><li>applet-window-buttons</li><li>applet-window-appmenu</li></ul><blockquote><p>Note: 编译过程,系统需要有cmake 和 extra-cmake-modules 环境 .  这两个可以直接安装.</p></blockquote><h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><h3 id="安装applet-window-title"><a href="#安装applet-window-title" class="headerlink" title="安装applet-window-title"></a>安装applet-window-title</h3><ul><li><p>克隆仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/psifidotos/applet-window-title.git</span><br></pre></td></tr></table></figure><p>该插件使用QML编写,可以直接装入.不需要编译</p></li><li><p>安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> applet-window-title</span><br><span class="line">plasmapkg2 -i .</span><br></pre></td></tr></table></figure></li></ul><p>至此,安装完成🤞</p><h3 id="安装applet-window-buttons"><a href="#安装applet-window-buttons" class="headerlink" title="安装applet-window-buttons"></a>安装applet-window-buttons</h3><ul><li>克隆仓库<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/psifidotos/applet-window-buttons.git</span><br></pre></td></tr></table></figure></li><li>编译安装<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> applet-window-buttons</span><br><span class="line">sh install.sh</span><br></pre></td></tr></table></figure>shell 脚本需要知道完成,编译和安装工作.</li></ul><blockquote><p>Note: 一定要安装cmake和 extra-cmake-modules . 不然会无法编译</p></blockquote><p>至此,安装完成🤞</p><h3 id="安装applet-windows-appmenu"><a href="#安装applet-windows-appmenu" class="headerlink" title="安装applet-windows-appmenu"></a>安装applet-windows-appmenu</h3><p>如果,系统已经预装了,全局菜单. 这个可以不安装.<br>我就是使用系统预装的全局菜单的😝</p><p>如果没有就看下吧!!</p><ul><li>克隆仓库<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/psifidotos/applet-window-appmenu.git</span><br></pre></td></tr></table></figure></li><li>编译安装<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> applet-window-appmenu</span><br><span class="line">sh install.sh</span><br></pre></td></tr></table></figure>同样,shell会搞定一切.开发者还是蛮贴心的哈<del>~</del>👋</li></ul><p>到这就全部安装完成啦.</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>安装完成,就可以愉快到需要的地方.添加插件啦.<br><img src="/img/min.png" alt="效果"><br><img src="/img/max.png" alt="效果"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;当初刚刚接触Ubuntu的时候,我就很喜欢Unity桌面的全局菜单整合功能,🎊&lt;br&gt;可以把窗口标题和全局菜单整合为一体.&lt;br&gt;这样就可以节省一行显示标题的空间.&lt;/p&gt;</summary>
    
    
    
    <category term="Linux之路" scheme="http://yoursite.com/categories/Linux%E4%B9%8B%E8%B7%AF/"/>
    
    
    <category term="Arch" scheme="http://yoursite.com/tags/Arch/"/>
    
    <category term="Manjaro" scheme="http://yoursite.com/tags/Manjaro/"/>
    
    <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux安装VirtualBox</title>
    <link href="http://yoursite.com/2020/08/14/Linux%E5%AE%89%E8%A3%85VirtualBox/"/>
    <id>http://yoursite.com/2020/08/14/Linux%E5%AE%89%E8%A3%85VirtualBox/</id>
    <published>2020-08-14T08:47:55.000Z</published>
    <updated>2020-10-31T12:50:24.248Z</updated>
    
    <content type="html"><![CDATA[<p>昨天，我下载好了kali镜像后.<br>今天,反手就是一个条命令把VirtualBox安装好了,<br>结果可想而知🤣</p><a id="more"></a><p>安装的VirtualBox可以运行,但是就是不能启动里面的虚拟系统.<br>这就很令我发愁,本来因为是BIOS没有开启虚拟化.<br>经过排查并不是这个原因.🤔<br>后来才知道,需要安装对应内核版本的安装包,才行</p><h2 id="确定Linux内核版本"><a href="#确定Linux内核版本" class="headerlink" title="确定Linux内核版本"></a>确定Linux内核版本</h2><ul><li>安装对应内核版本的安装,需要查询但前实习使用的内核.</li><li>使用uname -r 命令即可查询<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo uname -r</span><br><span class="line">5.6.19-2-MANJARO</span><br></pre></td></tr></table></figure>表示需要安装linux内核版本为5.6</li></ul><h2 id="安装VirtualBox"><a href="#安装VirtualBox" class="headerlink" title="安装VirtualBox"></a>安装VirtualBox</h2><p>需要安装VirtualBox和扩展包,以及内核模块</p><ul><li>安装VirtualBox<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pacman -S virtualbox</span><br></pre></td></tr></table></figure></li><li>安装VirtualBox扩展包<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pacman -S virtualbox-ext-oracle</span><br></pre></td></tr></table></figure></li><li>安装内核模块<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pacman -S linux56-virtualbox-host-modules</span><br></pre></td></tr></table></figure><blockquote><p>Note: 安装内核模块,一定要和系统内核是一致的版本.不然可能无法启动.</p></blockquote></li></ul><h2 id="载入vboxdr模块"><a href="#载入vboxdr模块" class="headerlink" title="载入vboxdr模块"></a>载入vboxdr模块</h2><ul><li>重启系统模块会自动载入.</li><li>手动使用命令载入<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo modprobe vboxdrv</span><br></pre></td></tr></table></figure>如果是其他衍生系统,大致安装步骤也和这个差不多.如果是初学者,注意包管理器的不同哦.🤞🤞🤞</li></ul><p>完成这些,就可以在Linux下面愉快的玩耍啦.🎊🎊🎊</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;昨天，我下载好了kali镜像后.&lt;br&gt;今天,反手就是一个条命令把VirtualBox安装好了,&lt;br&gt;结果可想而知🤣&lt;/p&gt;</summary>
    
    
    
    <category term="Linux之路" scheme="http://yoursite.com/categories/Linux%E4%B9%8B%E8%B7%AF/"/>
    
    
    <category term="Arch" scheme="http://yoursite.com/tags/Arch/"/>
    
    <category term="Manjaro" scheme="http://yoursite.com/tags/Manjaro/"/>
    
    <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>qBittorrent下载加速</title>
    <link href="http://yoursite.com/2020/08/13/qBittorrent%E4%B8%8B%E8%BD%BD%E5%8A%A0%E9%80%9F/"/>
    <id>http://yoursite.com/2020/08/13/qBittorrent%E4%B8%8B%E8%BD%BD%E5%8A%A0%E9%80%9F/</id>
    <published>2020-08-13T03:10:05.000Z</published>
    <updated>2020-10-26T14:32:57.732Z</updated>
    
    <content type="html"><![CDATA[<p>Linux 下面如何下载Bittorrent的资源呢🤔🤔？？<br>如果是在Windows下面,迅雷🐦一般是第一选择．</p><a id="more"></a><p>今天，我试图下载Kali Linux 镜像的时候，发现官方提供了，BitTorrent下载方式．<br>我就打算在我的Linux 下面尝试一下．结果下载速度非常快😝</p><h2 id="安装qBittorrent"><a href="#安装qBittorrent" class="headerlink" title="安装qBittorrent"></a>安装qBittorrent</h2><p>qBittorrent是一个跨平台的自由BitTorrent客户端，其图形用户界面是由Qt所写成的．</p><blockquote><p>下载链接：<a href="https://www.qbittorrent.org/download.php">https://www.qbittorrent.org/download.php</a></p></blockquote><p>等待下载完成后，就可以安装啦．</p><h3 id="Arch系列"><a href="#Arch系列" class="headerlink" title="Arch系列"></a>Arch系列</h3><p>如果是Arch Linux ，或者是基于Arch Linux 的系统</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S qbittorrent</span><br></pre></td></tr></table></figure><p>可以使用上述命令直接安装．</p><h2 id="加入Tracker-服务器"><a href="#加入Tracker-服务器" class="headerlink" title="加入Tracker 服务器"></a>加入Tracker 服务器</h2><p>Tracker服务器，主要目的是为了，提升下载速度.</p><p>由于tracker对BT下载起到客户端协调和调控的重要作用，所以一旦被封锁会严重影响BT下载，如2009年12月，中华人民共和国广电总局对BTchina一系列的tracker进行打击，因此也促使新BT客户端支持DHT网络实现无中心tracker，分布式资源分享的影响<br>需要了解更多Tracker服务器，可以自行搜索．</p><h2 id="qBittorrent-添加tracker服务器"><a href="#qBittorrent-添加tracker服务器" class="headerlink" title="qBittorrent 添加tracker服务器"></a>qBittorrent 添加tracker服务器</h2><p><a href="/img/tra.png">添加tracker服务器</a></p><ul><li>点击Preferences</li><li>找到Bittorent选项</li><li>勾选　automatically add thes trackers to new downloads 选项</li><li>粘贴tracker服务器列表，即可点击apply</li></ul><blockquote><p>Note: qBittorrent添加完成tracker服务器后需要，重新启动软件．</p></blockquote><h2 id="tracker服务器列表"><a href="#tracker服务器列表" class="headerlink" title="tracker服务器列表"></a>tracker服务器列表</h2><ul><li>Best Tracker list:<blockquote><p>　<a href="https://trackerslist.com/best.txt">https://trackerslist.com/best.txt</a></p></blockquote></li><li>All Tracker list:<blockquote><p><a href="https://trackerslist.com/all.txt">https://trackerslist.com/all.txt</a></p></blockquote></li><li>Http(s) Tracker list:<blockquote><p><a href="https://trackerslist.com/http.txt">https://trackerslist.com/http.txt</a></p></blockquote></li></ul><p>这些是我日程使用的Tracker服务器列表，这个仓库列表，已有人发布到github仓库中．<br>这里我就不给出仓库连接了，在我的收藏的仓库中可以找到😝</p><p>关于Bittorent 就分享到这里吧，DHT的中文全称是分布式哈希表(distributed has table 的缩写)，这可以避免中心tracker服务器的不能工作而导致这个系统的瘫痪．是一些天才的杰作．</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Linux 下面如何下载Bittorrent的资源呢🤔🤔？？&lt;br&gt;如果是在Windows下面,迅雷🐦一般是第一选择．&lt;/p&gt;</summary>
    
    
    
    <category term="Linux之路" scheme="http://yoursite.com/categories/Linux%E4%B9%8B%E8%B7%AF/"/>
    
    
    <category term="Arch" scheme="http://yoursite.com/tags/Arch/"/>
    
    <category term="Manjaro" scheme="http://yoursite.com/tags/Manjaro/"/>
    
    <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
</feed>
