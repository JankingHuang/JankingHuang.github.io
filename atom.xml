<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Janking&#39;s Blog</title>
  
  
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-03-01T05:05:47.571Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Janking Huang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>计算机存储器</title>
    <link href="http://yoursite.com/2021/03/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%98%E5%82%A8%E5%99%A8/"/>
    <id>http://yoursite.com/2021/03/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%98%E5%82%A8%E5%99%A8/</id>
    <published>2021-03-01T06:18:22.000Z</published>
    <updated>2021-03-01T05:05:47.571Z</updated>
    
    <content type="html"><![CDATA[<p>续<code>输入输出设备之后</code>，内容还是很简单！</p><a id="more"></a><h2 id="存储器分类"><a href="#存储器分类" class="headerlink" title="存储器分类"></a>存储器分类</h2><p><img src="/img/image-20210301121513654.png" alt="image-20210301121513654"></p><p><img src="/img/image-20210301121652632.png" alt="image-20210301121652632"></p><h2 id="存储器的层次结构"><a href="#存储器的层次结构" class="headerlink" title="存储器的层次结构"></a>存储器的层次结构</h2><p><img src="/img/image-20210301122040191.png" alt="image-20210301122040191"></p><p><img src="/img/image-20210301122159399.png" alt="image-20210301122159399"></p><p>缓存-主存层次</p><ul><li>局部性原理(某个事件趋于聚集在一个较小的连续区域中)</li><li>在CPU与主存之间增加一层速度快(容量小)的Cache</li><li>解决主存速度不足问题</li></ul><p>主存-辅存层次</p><ul><li>局部性原理</li><li>在主存之外增加辅助存储器(磁盘、SD卡、U盘)</li><li>解决主存容量不足问题</li></ul><p>主存储器（内存）</p><p><img src="/img/image-20210301124029366.png" alt="image-20210301124029366"></p><ul><li>RAM(随机存取存储器：Random Access Memory)</li><li>RAM通过电容存储数据，必须隔一段时间刷新一次</li><li>如果掉电，那么一段时候后丢失所有数据</li></ul><p>辅助存储器（磁盘）</p><p><img src="/img/image-20210301124304580.png" alt="image-20210301124304580"></p><p>磁头调度算法</p><ul><li>先来先服务算法</li><li>最短寻道时间优先算法</li><li>扫描算法（电梯算法）</li><li>循环扫描算法</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;续&lt;code&gt;输入输出设备之后&lt;/code&gt;，内容还是很简单！&lt;/p&gt;</summary>
    
    
    
    <category term="计算机基本知识" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="日常知识" scheme="http://yoursite.com/tags/%E6%97%A5%E5%B8%B8%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>计算机输入输出设备</title>
    <link href="http://yoursite.com/2021/03/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87/"/>
    <id>http://yoursite.com/2021/03/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87/</id>
    <published>2021-03-01T00:18:22.000Z</published>
    <updated>2021-03-01T05:03:46.290Z</updated>
    
    <content type="html"><![CDATA[<p>我打算水一期，这里做一下简单的记录！</p><a id="more"></a><h2 id="常见的输入输出设备"><a href="#常见的输入输出设备" class="headerlink" title="常见的输入输出设备"></a>常见的输入输出设备</h2><h3 id="字符输入设备"><a href="#字符输入设备" class="headerlink" title="字符输入设备"></a>字符输入设备</h3><ul><li>键盘<ul><li>薄膜键盘</li><li>机械键盘</li><li>电容键盘</li></ul></li></ul><h3 id="图形输入设备"><a href="#图形输入设备" class="headerlink" title="图形输入设备"></a>图形输入设备</h3><ul><li>鼠标</li><li>数位板</li><li>扫描仪</li></ul><h3 id="图像输出设备"><a href="#图像输出设备" class="headerlink" title="图像输出设备"></a>图像输出设备</h3><ul><li>显示器<ul><li>CRT显示器</li><li>液晶显示器</li></ul></li><li>打印机</li><li>投影仪</li></ul><h2 id="输入输出接口的通用设计"><a href="#输入输出接口的通用设计" class="headerlink" title="输入输出接口的通用设计"></a>输入输出接口的通用设计</h2><ul><li>数据线： I/O设备与主机之间进行数据交换的传送线<ul><li>双向传输数据线</li><li>单向传输数据线</li></ul></li><li>状态线： IO设备状态向主机报告的信号线，查询设备的状态(正常连接、就绪、占用)</li><li>命令线： CPU向设备发送命令的型号线（读写信号、启动停止信号）</li><li>设备选择线： 主机选择I/O 设备进行操作的信号线(选择指定设备进行读写)</li></ul><h2 id="CPU与IO设备的通信"><a href="#CPU与IO设备的通信" class="headerlink" title="CPU与IO设备的通信"></a>CPU与IO设备的通信</h2><h3 id="程序中断"><a href="#程序中断" class="headerlink" title="程序中断"></a>程序中断</h3><p><img src="/img/image-20210301120930923.png" alt="image-20210301120930923"></p><ul><li><p>当外围IO设备就绪时，向CPU发出中断信号</p></li><li><p>CPU有专门的电路响应中断信号</p><p><strong>提供低速设备通知CPU的一种异步的方式，CPU可以在高速运转的同时兼顾低速设备</strong></p></li></ul><h3 id="DMA-直接存储器访问"><a href="#DMA-直接存储器访问" class="headerlink" title="DMA(直接存储器访问)"></a>DMA(直接存储器访问)</h3><p><img src="/img/image-20210301121148725.png" alt="image-20210301121148725"></p><ul><li>DMA直接连接主存与IO设备</li><li>DMA工作时不需要CPU的参与</li></ul><p><strong>可以提高CPU效率</strong></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我打算水一期，这里做一下简单的记录！&lt;/p&gt;</summary>
    
    
    
    <category term="计算机基本知识" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="日常知识" scheme="http://yoursite.com/tags/%E6%97%A5%E5%B8%B8%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>计算机总线</title>
    <link href="http://yoursite.com/2021/02/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%80%BB%E7%BA%BF/"/>
    <id>http://yoursite.com/2021/02/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%80%BB%E7%BA%BF/</id>
    <published>2021-02-28T03:18:22.000Z</published>
    <updated>2021-03-01T05:05:08.815Z</updated>
    
    <content type="html"><![CDATA[<p>提供了对外连接的接口</p><p>不同设备可以通过<code>USB(通用串行总线)</code>接口进行连接</p><a id="more"></a><p>连接的标准、促使外围设备接口的统一</p><p><img src="/img/image-20210301112423108.png" alt="image-20210301112423108"></p><p><strong>解决不同设备之间的通信问题</strong></p><p><img src="/img/image-20210301112627399.png" alt="image-20210301112627399"></p><p><img src="/img/image-20210301112714365.png" alt="image-20210301112714365"></p><h3 id="总线的分类"><a href="#总线的分类" class="headerlink" title="总线的分类"></a>总线的分类</h3><p><img src="/img/image-20210301112746459.png" alt="image-20210301112746459"></p><h4 id="片内总线"><a href="#片内总线" class="headerlink" title="片内总线"></a>片内总线</h4><p><img src="/img/image-20210301112951302.png" alt="image-20210301112951302"></p><ul><li>芯片内部的总线</li><li>寄存器与寄存器之间</li><li>寄存器与控制器、运算器之间</li></ul><p>高集成读芯片内部的信息传输</p><p>系统总线</p><p><img src="/img/image-20210301113013402.png" alt="image-20210301113013402"></p><ul><li>数据总线(一般与CPU位数相同)<ul><li>双向传输各个部件的数据信息</li><li>数据总线的位数（总线宽度）是数据总线的重要参数</li></ul></li><li>地址总线(地址总线位数 = n, 寻址范围： 0 ～ 2^n)<ul><li>制定源数据或目的数据在内存中的地址</li><li>地址总线的位数与存储单位元有关</li></ul></li><li>控制总线<ul><li>控制总线是用来发出各种控制信号的传输线</li><li>控制信号经由控制总线从一个组件发给另一个组件</li><li>控制总线可以监视不同组件之间的状态(就绪/未就绪)</li></ul></li></ul><p><strong>CPU、主内存、IO设备、各组件之间的信息传输线</strong></p><h2 id="总线的仲裁"><a href="#总线的仲裁" class="headerlink" title="总线的仲裁"></a>总线的仲裁</h2><p>不同设备之间使用总线的优先级别。</p><p><img src="/img/image-20210301113942111.png" alt="image-20210301113942111"></p><p><strong>为了解决总线使用权的冲突问题</strong></p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="链式查询"><a href="#链式查询" class="headerlink" title="链式查询"></a>链式查询</h3><p><img src="/img/image-20210301114203233.png" alt="image-20210301114203233"></p><ul><li>电路复杂度低、仲裁方式简单</li><li>优先级低的设备难以获得总县使用权</li><li>对电路敏感</li></ul><h2 id="定时查询"><a href="#定时查询" class="headerlink" title="定时查询"></a>定时查询</h2><ul><li>仲裁控制其与设备编号并使用计数器累计基数</li><li>接收到仲裁信号后，往所有设备发出计数值</li><li>计数至与设备编号一致则获得总线使用权</li></ul><p><img src="/img/image-20210301114656230.png" alt="image-20210301114656230"></p><h2 id="独立请求"><a href="#独立请求" class="headerlink" title="独立请求"></a>独立请求</h2><ul><li>每个设备均有总线独立连接仲裁器</li><li>设备可单独向仲裁器发送请求和接受请求</li><li>当同时收到多个信号，仲裁器有权按优先级别分配使用权</li></ul><p><img src="/img/image-20210301114908031.png" alt="image-20210301114908031"></p><ul><li>响应速度快、优先顺序可动态改变</li><li>设备连接，总线控制复杂</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;提供了对外连接的接口&lt;/p&gt;
&lt;p&gt;不同设备可以通过&lt;code&gt;USB(通用串行总线)&lt;/code&gt;接口进行连接&lt;/p&gt;</summary>
    
    
    
    <category term="计算机基本知识" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="日常知识" scheme="http://yoursite.com/tags/%E6%97%A5%E5%B8%B8%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>计算机基本知识</title>
    <link href="http://yoursite.com/2021/02/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2021/02/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/</id>
    <published>2021-02-27T03:18:22.000Z</published>
    <updated>2021-02-27T05:24:52.686Z</updated>
    
    <content type="html"><![CDATA[<p>别问我，为啥要写这么基础的博文。我也不知道！！！</p><a id="more"></a><h2 id="计算机发展的四个阶段"><a href="#计算机发展的四个阶段" class="headerlink" title="计算机发展的四个阶段"></a>计算机发展的四个阶段</h2><ul><li><p>1946 - 1957： 电子管计算机(ENIAC)，第二次世界大战是催化机。</p></li><li><p>1957-1964  ： 晶体管计算机(TX-0 ,PDP-1)，贝尔实验室的三个科学家发明了晶体管。</p><blockquote><p>TX-0: 来自MIT林肯实验室</p></blockquote></li><li><p>1964-1980：集成电路计算机(诞生了操作系统) ， 德州仪器的工程师发明了集成电路(IC)</p><blockquote><p>IBM 7094 1401 操作系统，两个系无法兼容，后来推出System/360(操作系统的雏形)</p></blockquote></li><li><p>1980- ： 超大规模集成电路计算机</p></li></ul><p><strong>1TFlop/s : 每秒一万亿次浮点计算</strong> </p><h2 id="计算机的体系与结"><a href="#计算机的体系与结" class="headerlink" title="计算机的体系与结"></a>计算机的体系与结</h2><h3 id="冯诺依慢体系"><a href="#冯诺依慢体系" class="headerlink" title="冯诺依慢体系"></a>冯诺依慢体系</h3><p>将程序指令和数据一起存储的计算机设计概念结构</p><p><strong>存储程序指令，设计通用电路。</strong></p><p>存储器、控制器、运算器、输入设备、输出设备</p><p><img src="/img/image-20210227120307424.png" alt="image-20210227120307424"></p><p>CPU和存储速率之间的问题无法调和，称为“冯诺依曼瓶颈”</p><p><img src="/img/image-20210227120618198.png" alt="image-20210227120618198"></p><h2 id="计算机的层次"><a href="#计算机的层次" class="headerlink" title="计算机的层次"></a>计算机的层次</h2><p><img src="/img/image-20210227121147245.png" alt="image-20210227121147245"></p><h3 id="硬件逻辑层"><a href="#硬件逻辑层" class="headerlink" title="硬件逻辑层"></a>硬件逻辑层</h3><p>门、触发器等逻辑电路组成，属于EE的领域。</p><h3 id="微程序机器层"><a href="#微程序机器层" class="headerlink" title="微程序机器层"></a>微程序机器层</h3><ul><li>编程语言是微指令集。</li><li>微指令所组成的微程序直接交由硬件执行。</li></ul><h3 id="传统机器层"><a href="#传统机器层" class="headerlink" title="传统机器层"></a>传统机器层</h3><ul><li>编程语言是CPU指令集(机器指令)。</li><li>编程语言和硬件是直接相关。</li><li>不同架构的CPU使用不同的CPU指令集。</li></ul><p><strong>一条机器指令对应一个微程序，一个微程序对应一组微指令</strong></p><h3 id="操作系统层"><a href="#操作系统层" class="headerlink" title="操作系统层"></a>操作系统层</h3><ul><li>向上提供了简易的操作界面。</li><li>向下对接了指令系统，管理硬件资源。 </li><li>操作系统层是在软件和硬件之间的适配层。</li></ul><h3 id="汇编语言层"><a href="#汇编语言层" class="headerlink" title="汇编语言层"></a>汇编语言层</h3><ul><li>编程语言是汇编语言。</li><li>汇编语言可以翻译成可以直接执行的机器语言。</li><li>完成翻译的过程的程序就是汇编器。</li></ul><h3 id="高级语言层"><a href="#高级语言层" class="headerlink" title="高级语言层"></a>高级语言层</h3><p>日常的编程语言，C/C++、Java、Golang等</p><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>满足计算机针对某种用途而专门设计，office、ps</p><p><strong>分层的目的是便于理解</strong></p><h2 id="计算机的计算单位"><a href="#计算机的计算单位" class="headerlink" title="计算机的计算单位"></a>计算机的计算单位</h2><p><img src="/img/image-20210227122700698.png" alt="image-20210227122700698"></p><p>在物理成面，高低电平记录信息</p><p>理论上只认识0/1两种状态</p><p><img src="/img/image-20210227123633472.png" alt="image-20210227123633472"></p><p><img src="/img/image-20210227124043214.png" alt="image-20210227124043214"></p><h3 id="速度单位"><a href="#速度单位" class="headerlink" title="速度单位"></a>速度单位</h3><h4 id="网络速度"><a href="#网络速度" class="headerlink" title="网络速度"></a>网络速度</h4><ul><li>网络常用单位为(Mbps)</li><li>100 M/s = 100 Mbps = 100 Mbit/s = (100/8)MB/s = 12.5 MB/s</li></ul><h4 id="CPU速度"><a href="#CPU速度" class="headerlink" title="CPU速度"></a>CPU速度</h4><ul><li>CPU的速度一般体现为CPU的时钟频率</li><li>CPU的时钟频率的单位一般是赫兹(Hz)</li><li>主流CPU的时钟频率都是在2 GHz以上</li></ul><blockquote><p>Hz 每秒中的周期性变动重复次数的计量</p></blockquote><p><img src="/img/image-20210227125240303.png" alt="image-20210227125240303"></p><h2 id="字符与编码集"><a href="#字符与编码集" class="headerlink" title="字符与编码集"></a>字符与编码集</h2><h3 id="ASCII码"><a href="#ASCII码" class="headerlink" title="ASCII码"></a>ASCII码</h3><ul><li>使用7个bits 就可以表示</li><li>包含95个可打印字符</li><li>33个不可打印字符</li></ul><p><strong>很多应用或者国际中的符号都无法表示</strong></p><p>第一次对ASCII码进行扩充，7 bits-&gt;8 bits</p><h3 id="Extended-ASCII码"><a href="#Extended-ASCII码" class="headerlink" title="Extended ASCII码"></a>Extended ASCII码</h3><ul><li>有常见的数学运算符</li><li>带音标的欧洲字符</li><li>其它常用、表个符等</li></ul><p><img src="/img/image-20210227130007966.png" alt="image-20210227130007966"></p><h3 id="中文编码集"><a href="#中文编码集" class="headerlink" title="中文编码集"></a>中文编码集</h3><ul><li>GB2312(不符合国际编码)</li><li>GBK(兼容<code>GB2312</code> 、<code>ISO标准</code>，支持中日韩所有文字)</li></ul><h3 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h3><ul><li>统一码、万国码、单一码。</li><li>定义了世界通用的符号集，UTF-*实现了编码</li><li>UTF-8 以字节为单位对Unicode进行编码</li></ul><p><strong>兼容全球的字符集</strong></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;别问我，为啥要写这么基础的博文。我也不知道！！！&lt;/p&gt;</summary>
    
    
    
    <category term="计算机基本知识" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="日常知识" scheme="http://yoursite.com/tags/%E6%97%A5%E5%B8%B8%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>编译原理之一</title>
    <link href="http://yoursite.com/2021/02/26/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%861/"/>
    <id>http://yoursite.com/2021/02/26/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%861/</id>
    <published>2021-02-26T09:46:46.000Z</published>
    <updated>2021-02-26T10:41:33.803Z</updated>
    
    <content type="html"><![CDATA[<p>今天写题目的时候遇到了<code>有限状态机</code>这个概念。<br>我也不懂，查完资料后，就写个博客记录一下吧！</p><a id="more"></a><p><code>编译</code>过程的前三个阶段会进行<code>词法分析</code>、<code>语法分析</code>、<code>语义分析</code>。</p><h2 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h2><p>编译器的第一项工作就是<code>词法分析</code>，就像阅读文章一样,文章是由一个个的文字</p><p>组成的。程序处理也一样,只是叫做<code>词法记号</code>,英文叫<code>Token</code>。</p><h3 id="生成过程"><a href="#生成过程" class="headerlink" title="生成过程"></a>生成过程</h3><p>利用<code>词法分析器</code>可以生成<code>分词规则</code>,比如 <code>Lex</code>。</p><p>这些生成工具是基于一些规则来工作的,这些规则用<code>正则文法</code>表达。</p><p>生成工具可以读入<code>正则表达式</code>,生成一种叫<code>有限自动机</code>的算法,来完成具体的<code>词法分析</code>工作。</p><blockquote><p> 符合正则文法的表达式称为<code>正则表达式</code>。</p></blockquote><blockquote><p><code>有限自动机</code>是有限个状态的自动机器。</p><p>拿抽水马桶举例,它分为<strong>两个状态</strong>:“注水”和“水满”。</p><p>摁下冲马桶的按钮,它转到“<strong>注水”状态</strong>,而浮球上升到一定高度,就会把注水阀门关闭,它转到<strong>“水满”状态</strong>。</p></blockquote><h2 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h2><p>这是编译器的第二项工作，<code>词法分析</code>是识别一个个的<code>单词</code>,</p><p>而<code>语法分析</code>就是在<code>词法分析</code>的基础上识别出<code>程序的语法结构</code>。</p><p>这个结构是一个<code>树状结构</code>,是计算机容易理解和执行的。</p><h3 id="抽象语法树-AST"><a href="#抽象语法树-AST" class="headerlink" title="抽象语法树(AST)"></a>抽象语法树(AST)</h3><p>语法分析过程,就是构造这么一棵树。</p><p>一个程序就是一棵树,这棵树叫<code>做抽象语法树</code>(Abstract Syntax Tree,AST)。</p><p>树的每个节点是一个<code>语法单元</code>,<strong>这个单元的构成规则就叫“语法”</strong>。</p><blockquote><p> 这里可以生成直观的JS语法树：<a href="https://resources.jointjs.com/demos/javascript-ast">https://resources.jointjs.com/demos/javascript-ast</a> </p></blockquote><p><img src="/img/tree.svg" alt="AST"></p><blockquote><p>了解更多的AST相关的内容: <a href="http://icps.u-strasbg.fr/~pop/gcc-ast.html">http://icps.u-strasbg.fr/~pop/gcc-ast.html</a></p></blockquote><h2 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h2><p>语义分析是消除语义模糊,生成一些属性信息,让计算机能够依据这些信息生成目标代<br>码。</p><ul><li>某个表达式的计算结果是什么数据类型？</li><li>如果有数据类型不匹配的情况。</li><li>如果在一个代码块的内部和外部有相同名称的变量。</li></ul><p><strong>语义分析工作的某些成果,会作为属性标注在抽象语法树上。</strong></p><p>以上就是编译器的前三个阶段的过程!!!</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天写题目的时候遇到了&lt;code&gt;有限状态机&lt;/code&gt;这个概念。&lt;br&gt;我也不懂，查完资料后，就写个博客记录一下吧！&lt;/p&gt;</summary>
    
    
    
    <category term="编译原理" scheme="http://yoursite.com/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="计算机基础知识" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    <category term="编译原理" scheme="http://yoursite.com/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>STL之Vectors</title>
    <link href="http://yoursite.com/2021/02/24/STL%E4%B9%8BVectors/"/>
    <id>http://yoursite.com/2021/02/24/STL%E4%B9%8BVectors/</id>
    <published>2021-02-24T07:42:15.000Z</published>
    <updated>2021-02-24T10:14:51.664Z</updated>
    
    <content type="html"><![CDATA[<p>Vector包含存储为数组的连续元素。访问向量的成员、添加元素可以在常数时间内完成，<br>而查找特定值或将元素插入向量需要线性时间。</p><a id="more"></a><h2 id="Vector-构造函数"><a href="#Vector-构造函数" class="headerlink" title="Vector 构造函数"></a>Vector 构造函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>();</span><br><span class="line"><span class="built_in">vector</span>( <span class="keyword">const</span> <span class="built_in">vector</span>&amp; c );</span><br><span class="line"><span class="built_in">vector</span>( size_type num, <span class="keyword">const</span> TYPE&amp; val = TYPE() );</span><br><span class="line"><span class="built_in">vector</span>( input_iterator start, input_iterator <span class="built_in">end</span> );</span><br></pre></td></tr></table></figure><ul><li>默认构造函数没有参数，创建一个新的实例对象vector。</li><li>第二个构造函数，是默认复制构造函数，创建<code>c</code>的副本。</li><li>第三个构造函数，创建一个具有<code>num</code>大小的空间，如果指定<code>val</code>的值。则<code>num</code>空间中默认初始值为<code>val。</code></li><li>最后一个构造函数，创建一个vector，并初始化值为<code>start</code>到<code>end</code>的元素值。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">       v.push_back(i);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// v 包含 0,1,2,3,4,5,6,7,8,9,10;</span></span><br><span class="line">   <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter1 = v.<span class="built_in">begin</span>();</span><br><span class="line">   iter1 += <span class="number">2</span>;  <span class="comment">//iter1 指向v中值为3的元素</span></span><br><span class="line">   <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter2 = v.<span class="built_in">end</span>();</span><br><span class="line">   iter2 -= <span class="number">3</span>; <span class="comment">//iter2 指向v中值为7的元素</span></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(iter1,iter2)</span></span>;<span class="comment">//[iter1,iter2) 赋值给a</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">auto</span> i: a)&#123;</span><br><span class="line">       <span class="built_in">cout</span> &lt;&lt; <span class="string">"res out:"</span>&lt;&lt;i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// res out : 2 3 4 5 6</span></span><br></pre></td></tr></table></figure><p><strong>所有这些构造函数都以线性时间运行，除了第一个以常数时间运行。</strong></p><h2 id="Vector-运算符重载"><a href="#Vector-运算符重载" class="headerlink" title="Vector 运算符重载"></a>Vector 运算符重载</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">TYPE&amp; <span class="keyword">operator</span>[]( size_type index );</span><br><span class="line"><span class="keyword">const</span> TYPE&amp; <span class="keyword">operator</span>[]( size_type index ) <span class="keyword">const</span>;</span><br><span class="line"><span class="built_in">vector</span> <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="built_in">vector</span>&amp; c2);</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> <span class="built_in">vector</span>&amp; c1, <span class="keyword">const</span> <span class="built_in">vector</span>&amp; c2);</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> <span class="built_in">vector</span>&amp; c1, <span class="keyword">const</span> <span class="built_in">vector</span>&amp; c2);</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> <span class="built_in">vector</span>&amp; c1, <span class="keyword">const</span> <span class="built_in">vector</span>&amp; c2);</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&gt;(<span class="keyword">const</span> <span class="built_in">vector</span>&amp; c1, <span class="keyword">const</span> <span class="built_in">vector</span>&amp; c2);</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;=(<span class="keyword">const</span> <span class="built_in">vector</span>&amp; c1, <span class="keyword">const</span> <span class="built_in">vector</span>&amp; c2);</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&gt;=(<span class="keyword">const</span> <span class="built_in">vector</span>&amp; c1, <span class="keyword">const</span> <span class="built_in">vector</span>&amp; c2)</span><br></pre></td></tr></table></figure><p><strong><code>const TYPE&amp; operator[]</code> 操作是以常数时间，其他都是线性时间</strong></p><h2 id="Vector-函数"><a href="#Vector-函数" class="headerlink" title="Vector 函数"></a>Vector 函数</h2><h3 id="assign"><a href="#assign" class="headerlink" title="assign"></a>assign</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">assign</span><span class="params">( size_type num, <span class="keyword">const</span> TYPE&amp; val )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">assign</span><span class="params">( input_iterator start, input_iterator <span class="built_in">end</span> )</span></span>;</span><br></pre></td></tr></table></figure><p>将<code>vector</code> 赋值为<code>num</code>个<code>val</code>; 或者<code>vector</code>赋值为从<code>start</code>到<code>end</code>的元素</p><p><strong>此函数将破坏向量的先前内容。</strong></p><h3 id="at"><a href="#at" class="headerlink" title="at"></a>at</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TYPE&amp; <span class="title">at</span><span class="params">( size_type loc )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> TYPE&amp; <span class="title">at</span><span class="params">( size_type loc )</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure><p>返回索引为<code>loc</code>的向量中元素的引用。 <code>at()</code>函数比<code>[]</code>运算符更安全，因为它不会让您引用向量的边界。</p><h3 id="back"><a href="#back" class="headerlink" title="back"></a>back</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TYPE&amp; <span class="title">back</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> TYPE&amp; <span class="title">back</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure><p>返回<code>vector</code>中最后一个元素的引用</p><h3 id="begin"><a href="#begin" class="headerlink" title="begin"></a>begin</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure><p>返回一个迭代器指向<code>vector</code>的首个元素，常数时间。</p><h3 id="capacity"><a href="#capacity" class="headerlink" title="capacity"></a>capacity</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">size_type <span class="title">capacity</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure><p>返回<code>vector</code>的容量，然后可以通过reserve() 重新定制大小。</p><blockquote><p>C ++容器旨在动态增加大小。这使程序员摆脱了不必担心在容器中存储任意数量的元素。然而，有时程序员可以通过提示来提高程序性能向编译器询问程序将使用的容器的大小。</p></blockquote><h3 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>删除<code>vector</code>所有元素，常数时间。</p><h3 id="empty"><a href="#empty" class="headerlink" title="empty"></a>empty</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure><p>判断<code>vector</code>是否为空。</p><h3 id="end"><a href="#end" class="headerlink" title="end"></a>end</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure><p>返回一个迭代器指向<code>vector</code>的追后一个元素的下一个位置。</p><h3 id="eras"><a href="#eras" class="headerlink" title="eras"></a>eras</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">( iterator loc )</span></span>;</span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">( iterator start, iterator <span class="built_in">end</span> )</span></span>;</span><br></pre></td></tr></table></figure><p>擦除一个元素或[start,end)个元素。返回擦除的最后一个元素。</p><h3 id="front"><a href="#front" class="headerlink" title="front"></a>front</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TYPE&amp; <span class="title">front</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> TYPE&amp; <span class="title">front</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure><p>返回第一元素。</p><h3 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">( iterator loc, <span class="keyword">const</span> TYPE&amp; val )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">( iterator loc, size_type num, <span class="keyword">const</span> TYPE&amp; val )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">( iterator loc, input_iterator start, input_iterator <span class="built_in">end</span> )</span></span>;</span><br></pre></td></tr></table></figure><ul><li>插入<code>val</code>在<code>loc</code>之后，放回插入元素位置的迭代器。</li><li>插入<code>num</code>个<code>val</code> 在<code>loc</code>之后。</li><li>插入<code>[start,end)</code> 区间内的元素，在<code>loc</code>之后。</li></ul><h3 id="max-size"><a href="#max-size" class="headerlink" title="max_size"></a>max_size</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure><p>返回<code>vector</code>在更多内存的情况下，允许分配的最大值。</p><p><strong>需要与<code>size()</code>和<code>capacity()</code>区分</strong></p><h3 id="pop-back"><a href="#pop-back" class="headerlink" title="pop_back"></a>pop_back</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>删除最后一个元素。</p><h3 id="push-back"><a href="#push-back" class="headerlink" title="push_back"></a>push_back</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">( <span class="keyword">const</span> TYPE&amp; val )</span></span>;</span><br></pre></td></tr></table></figure><p>添加一个元素到<code>vector</code>尾部。</p><h3 id="rbegin"><a href="#rbegin" class="headerlink" title="rbegin"></a>rbegin</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">reverse_iterator <span class="title">rbegin</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">const_reverse_iterator <span class="title">rbegin</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure><p>返回一个迭代器指向<code>vector</code>末尾的下一个元素。</p><h3 id="rend"><a href="#rend" class="headerlink" title="rend"></a>rend</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">reverse_iterator <span class="title">rend</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">const_reverse_iterator <span class="title">rend</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure><p>返回一个迭代器指向<code>vector</code>第一个元素。</p><h3 id="reserve"><a href="#reserve" class="headerlink" title="reserve"></a>reserve</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reserve</span><span class="params">( size_type <span class="built_in">size</span> )</span></span></span><br></pre></td></tr></table></figure><p>设置<code>vector</code>的容量最小大为<code>size</code>。</p><h3 id="resize"><a href="#resize" class="headerlink" title="resize"></a>resize</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">( size_type num, <span class="keyword">const</span> TYPE&amp; val = TYPE() )</span></span>;</span><br></pre></td></tr></table></figure><p>改变<code>vector</code>的大小，如果指定<code>val</code> 则新增的空间初始化为<code>val</code>。</p><h3 id="size"><a href="#size" class="headerlink" title="size"></a>size</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure><p>返回<code>vector</code>中元素的个数。</p><h3 id="swap"><a href="#swap" class="headerlink" title="swap"></a>swap</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">( container&amp; from )</span></span>;</span><br></pre></td></tr></table></figure><p>将<code>vector</code>的内容与<code>from</code>的内容进行交换，常数时间。</p><p>Vector 的介绍就先到这里吧，加油！！！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Vector包含存储为数组的连续元素。访问向量的成员、添加元素可以在常数时间内完成，&lt;br&gt;而查找特定值或将元素插入向量需要线性时间。&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
    <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="STL" scheme="http://yoursite.com/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>C++资源管理(堆、栈、RAII)</title>
    <link href="http://yoursite.com/2021/02/03/C-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86-%E5%A0%86%E3%80%81%E6%A0%88%E3%80%81RAII/"/>
    <id>http://yoursite.com/2021/02/03/C-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86-%E5%A0%86%E3%80%81%E6%A0%88%E3%80%81RAII/</id>
    <published>2021-02-03T04:27:54.000Z</published>
    <updated>2021-02-03T04:27:54.662Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux编写C51程序</title>
    <link href="http://yoursite.com/2021/01/19/Linux%E7%BC%96%E5%86%99C51%E7%A8%8B%E5%BA%8F/"/>
    <id>http://yoursite.com/2021/01/19/Linux%E7%BC%96%E5%86%99C51%E7%A8%8B%E5%BA%8F/</id>
    <published>2021-01-19T04:46:27.000Z</published>
    <updated>2021-01-20T04:45:42.606Z</updated>
    
    <content type="html"><![CDATA[<p>近期，在读<code>计算机程序设计艺术</code>这个书。之前尝试和很多次，在前面章节就没有咋看懂。很多人都说这是计算机界中的<code>圣经</code>。有时间闲下来读一些书，对于我来说是一件比较休闲的事情。平时基本上面对电子屏幕，我不想我的世界里离不开它。所以在很多娱乐的时候，我都选择一些跟电子设备不太相关的活动。ok,近期Blog更新也会比较慢。Let’s go 🎊</p><a id="more"></a><p>今天的正题是，如何在Linux搭建开发C51的开发环境。因为我手上一直有一块C51的开发板。<br><img src="/img/C51.jpg" alt="C51开发板"></p><h2 id="安装SDCC-Small-Device-C-Compiler"><a href="#安装SDCC-Small-Device-C-Compiler" class="headerlink" title="安装SDCC(Small Device C Compiler)"></a>安装SDCC(Small Device C Compiler)</h2><ul><li><a href="http://sdcc.sourceforge.net/">官方介绍</a></li></ul><blockquote><p>SDCC is a retargettable, optimizing Standard C (ANSI C89, ISO C99, ISO C11) compiler suite that targets the Intel MCS51 based microprocessors (8031, 8032, 8051, 8052, etc.), Maxim (formerly Dallas) DS80C390 variants, Freescale (formerly Motorola) HC08 based (hc08, s08), Zilog Z80 based MCUs (z80, z180, gbz80, Rabbit 2000/3000, Rabbit 3000A, TLCS-90), Padauk (pdk14, pdk15) and STMicroelectronics STM8. Work is in progress on supporting the Padauk (pdk13), Microchip PIC16 and PIC18 targets. It can be retargeted for other microprocessors.</p></blockquote><ul><li><p>sdcc 使用编译C51代码的。</p></li><li><p>Arch系列安装命令</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pacman -S sdcc  <span class="comment"># 安装sdcc</span></span><br></pre></td></tr></table></figure><ul><li><p>其他衍生版可以查看自己的软件仓库，或者自行下载</p></li><li><p><a href="http://sdcc.sourceforge.net/snap.php#Linux">下载地址</a></p></li></ul><h2 id="安装stcflash"><a href="#安装stcflash" class="headerlink" title="安装stcflash"></a>安装stcflash</h2><ul><li><p>使用Python编写，用于烧入sdcc生成的二进制文件</p></li><li><p>源码开源在Github</p></li><li><p>Arch系列安装命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yay -S stcflash-git <span class="comment"># 安装stcflash 在用户仓库中。</span></span><br></pre></td></tr></table></figure></li><li><p>其他衍生版可以查看自己的软件仓库，或者自行下载。解压皆可使用。</p></li></ul><p><code>注意：</code> 如果需要在终端如何地方打开，需要把<code>stcflash.py</code> 复制到<code>usr/bin/</code>目录下面。</p><ul><li><a href="https://github.com/laborer/stcflash">stcflash 更多使用说明</a></li></ul><h2 id="编写C51代码"><a href="#编写C51代码" class="headerlink" title="编写C51代码"></a>编写C51代码</h2><ul><li>需要包含<code>&lt;mcs51/&gt;8051.h&gt;头文件</code>。</li><li>引脚的定义为<code>P1_0</code>表示为<code>P1 io 口的第一个引脚</code> 。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;mcs51/8051.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> a,b;</span><br><span class="line">    <span class="keyword">for</span>(a=t; a &gt;<span class="number">0</span>;a--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(b=<span class="number">100</span>;b&gt;<span class="number">0</span>;b--);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P1_0 = <span class="number">0</span>;<span class="comment">//相当于keil c51 定义 P1^0</span></span><br><span class="line">        <span class="built_in">delay</span>(<span class="number">1000</span>);</span><br><span class="line">        P1_0 = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">delay</span>(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><ul><li>使用sdcc进行编译,生成.ihx 文件。</li><li>编译命令。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sdcc main.c -o main.ihx  <span class="comment"># -o 指定文件名</span></span><br></pre></td></tr></table></figure>如果语法正确，就能编译成功。否则请检查语法。🤞</li></ul><h2 id="转化"><a href="#转化" class="headerlink" title="转化"></a>转化</h2><ul><li>stcflash 烧入的文件是<code>.hex</code>。 我们需要转化<code>.hpx 为 .hex</code>。</li><li>转化命令<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ packihx main.ihx &gt; main.hex</span><br></pre></td></tr></table></figure></li></ul><h2 id="写入程序"><a href="#写入程序" class="headerlink" title="写入程序"></a>写入程序</h2><ul><li>利用stcflash 向开发版烧入<code>.hex</code>程序。</li><li>写入命令<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ stcflash main.hex</span><br></pre></td></tr></table></figure><h3 id="扩展命令"><a href="#扩展命令" class="headerlink" title="扩展命令"></a>扩展命令</h3><table><thead><tr><th>命令</th><th>作用</th><th>示例</th></tr></thead><tbody><tr><td>–port</td><td>指定写串口</td><td><code>$ stcflash --port  /dev/ttyUSB1</code></td></tr><tr><td>-lowbaud 1200</td><td>指定波特率</td><td><code>stacflash -lowbaud 1200</code></td></tr></tbody></table></li></ul><p>更多配置信息 阅读<a href="https://github.com/laborer/stcflash">Github</a></p><h2 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h2><ul><li>该动画<code>不</code>包含<code>sdcc</code>和<code>stcflash</code>的配置过程。</li><li>仅包含代码<code>编写</code>、<code>编译</code>、<code>转化</code>、<code>写入</code>等过程。<br><img src="/img/c51.gif" alt="代码编写及烧入演示"></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;近期，在读&lt;code&gt;计算机程序设计艺术&lt;/code&gt;这个书。之前尝试和很多次，在前面章节就没有咋看懂。很多人都说这是计算机界中的&lt;code&gt;圣经&lt;/code&gt;。有时间闲下来读一些书，对于我来说是一件比较休闲的事情。平时基本上面对电子屏幕，我不想我的世界里离不开它。所以在很多娱乐的时候，我都选择一些跟电子设备不太相关的活动。ok,近期Blog更新也会比较慢。Let’s go 🎊&lt;/p&gt;</summary>
    
    
    
    <category term="嵌入式开发" scheme="http://yoursite.com/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
    <category term="Development Environment" scheme="http://yoursite.com/tags/Development-Environment/"/>
    
    <category term="C51" scheme="http://yoursite.com/tags/C51/"/>
    
  </entry>
  
  <entry>
    <title>Emulator与主机软件socket通信</title>
    <link href="http://yoursite.com/2021/01/06/Emulator%E4%B8%8E%E4%B8%BB%E6%9C%BA%E8%BD%AF%E4%BB%B6socket%E9%80%9A%E4%BF%A1/"/>
    <id>http://yoursite.com/2021/01/06/Emulator%E4%B8%8E%E4%B8%BB%E6%9C%BA%E8%BD%AF%E4%BB%B6socket%E9%80%9A%E4%BF%A1/</id>
    <published>2021-01-06T02:20:02.000Z</published>
    <updated>2021-01-20T04:46:40.293Z</updated>
    
    <content type="html"><![CDATA[<p>我已经记不清楚，有多久没有更新博客。🙈<br>今天，我就研究了一下。<code>Android Emulator</code> 与 <code>主机</code>之间的网络通信。<br>以前使用的方法都是然emulator 和 主机连接同一个网络。要是没有外部网络的时候呢？</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在Android Developer 网站看了半天，只看到了下面这个<code>表</code>和<code>两个模拟器</code>如何通信</p><table><thead><tr><th>网络地址</th><th>说明</th></tr></thead><tbody><tr><td>10.0.2.1</td><td>路由器/网关地址</td></tr><tr><td>10.0.2.2</td><td>主机回环接口的特殊别名（即，开发计算机上的 127.0.0.1）</td></tr><tr><td>10.0.2.3</td><td>第一个 DNS 服务器</td></tr><tr><td>10.0.2.4 / 10.0.2.5 / 10.0.2.6</td><td>可选的第二个、第三个和第四个 DNS 服务器（如果有）</td></tr><tr><td>10.0.2.15</td><td>模拟设备网络/以太网接口</td></tr><tr><td>127.0.0.1</td><td>模拟设备回环接口</td></tr></tbody></table><p><a href="https://developer.android.com/studio/run/emulator-networking">表来源：emulator-networking</a></p><p>在看了老半天文档后，我就得出一个结果。我是不是语文不好！！<br>后来，我只能改用英文关键字进行搜索了。看到了一篇名为<code>ADB port forwarding and reversing</code> 。看完我就知道了，我的语文没问题。</p><p><a href="https://blog.usejournal.com/adb-port-forwarding-and-reversing-d2bc71835d43">文章来源：ADB port forwarding and reversing</a></p><h2 id="Android-Debug-Bridge-ADB"><a href="#Android-Debug-Bridge-ADB" class="headerlink" title="Android Debug Bridge(ADB)"></a>Android Debug Bridge(ADB)</h2><blockquote><p>Android调试桥（adb）是一种多功能的命令行工具，可让您与设备进行通信。adb命令可促进各种设备操作，例如安装和调试应用程序，并且提供对Unix shell的访问，您可以使用Unix shell在设备上运行各种命令。它是一个客户端服务器程序，包含三个组件：</p><p>客户端，发送命令。客户端在您的开发计算机上运行。您可以通过发出adb命令从命令行终端调用客户端。</p><p>守护程序（adbd），它在设备上运行命令。守护程序在每个设备上作为后台进程运行。</p><p>服务器，用于管理客户端和守护程序之间的通信。服务器在开发计算机上作为后台进程运行。</p></blockquote><p>整个过程，只会用到端口转发</p><blockquote><p>端口转发（即隧道传输）是一种幕后过程，该过程是拦截前往计算机IP /端口组合的数据流量并将其重定向到其他IP和/或端口的。在目标计算机（主机）上运行的程序通常会导致重定向，但有时也可以是中间硬件组件，例如路由器，代理服务器或防火墙。</p></blockquote><h2 id="端口转发"><a href="#端口转发" class="headerlink" title="端口转发"></a>端口转发</h2><ul><li>使用<code>forward</code>命令设置任意端口转发，该转发将特定主机端口上的请求转发到设备上的其他端口。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb forward tcp:6100 tcp:7100</span><br><span class="line"><span class="comment">#设置将主机端口6100转发到模拟器端口7100</span></span><br></pre></td></tr></table></figure><ul><li>使用<code>reverse</code>命令进行反向转发</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb reverse tcp:3000 tcp:3001</span><br><span class="line"><span class="comment"># 模拟器的端口3000重定向到计算机的端口30001</span></span><br></pre></td></tr></table></figure><h2 id="相关参数"><a href="#相关参数" class="headerlink" title="相关参数"></a>相关参数</h2><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>forward/reverser –list</td><td>list all forward socket connections</td></tr><tr><td>forward/reverser –remove LOCAL</td><td>remove specific forward socket connection</td></tr><tr><td>forward/reverser –remove-all</td><td>remove all forward socket connections</td></tr></tbody></table><p>今天，就到这里。终于把这个坑给填上了🎊🎊🎊</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我已经记不清楚，有多久没有更新博客。🙈&lt;br&gt;今天，我就研究了一下。&lt;code&gt;Android Emulator&lt;/code&gt; 与 &lt;code&gt;主机&lt;/code&gt;之间的网络通信。&lt;br&gt;以前使用的方法都是然emulator 和 主机连接同一个网络。要是没有外部网络的时候呢？&lt;/p&gt;</summary>
    
    
    
    <category term="嵌入式开发" scheme="http://yoursite.com/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
    <category term="Socket" scheme="http://yoursite.com/tags/Socket/"/>
    
    <category term="TCP" scheme="http://yoursite.com/tags/TCP/"/>
    
    <category term="UDP" scheme="http://yoursite.com/tags/UDP/"/>
    
    <category term="Development Environment" scheme="http://yoursite.com/tags/Development-Environment/"/>
    
  </entry>
  
  <entry>
    <title>我的Linux桌面环境</title>
    <link href="http://yoursite.com/2020/11/27/%E6%88%91%E7%9A%84Linux%E6%A1%8C%E9%9D%A2%E7%8E%AF%E5%A2%83/"/>
    <id>http://yoursite.com/2020/11/27/%E6%88%91%E7%9A%84Linux%E6%A1%8C%E9%9D%A2%E7%8E%AF%E5%A2%83/</id>
    <published>2020-11-27T12:17:43.000Z</published>
    <updated>2020-11-27T13:31:35.165Z</updated>
    
    <content type="html"><![CDATA[<p>今天，我是来填坑的。前段时间挖了这个坑，今天就把它填上。</p><p>这篇Blog是<a href="/2020/11/02/%E6%88%91%E7%9A%84Linux/">我与Linux的爱恨情仇</a>后续之作。</p><a id="more"></a><h2 id="我的Linxu软件"><a href="#我的Linxu软件" class="headerlink" title="我的Linxu软件"></a>我的Linxu软件</h2><h3 id="开发文档查看工具"><a href="#开发文档查看工具" class="headerlink" title="开发文档查看工具"></a>开发文档查看工具</h3><ul><li><p>Zeal</p></li><li><p>安装方式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pacman -S zeal</span><br><span class="line"><span class="comment">#如果打不开，提示是Qt的相关问题</span></span><br><span class="line"><span class="comment">#可以去github下载源代码，然后编译就可以用了</span></span><br></pre></td></tr></table></figure></li><li><p>代码仓库</p><blockquote><p><a href="https://github.com/zealdocs/zeal">https://github.com/zealdocs/zeal</a></p></blockquote></li><li><p>软件界面<br><img src="/img/zeal.png" alt="Zeal"></p></li></ul><h3 id="桌面程序开发"><a href="#桌面程序开发" class="headerlink" title="桌面程序开发"></a>桌面程序开发</h3><ul><li>Qt,KDE就是使用Qt开发的，我越来越喜欢Qt了。</li><li>安装方式<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pacman -S qtcreator</span><br></pre></td></tr></table></figure></li><li>软件界面<br><img src="/img/qt.png" alt="Qt Creator"></li></ul><h3 id="团队沟通工具"><a href="#团队沟通工具" class="headerlink" title="团队沟通工具"></a>团队沟通工具</h3><p>  我用过很多，就目前而言国内的都不好用。</p><ul><li>Microsoft Teams(非常好用，除了网络问题)</li><li>安装方式<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pacman -S teams-insiders</span><br><span class="line"><span class="comment">#软件仓库中，就是有insider版。</span></span><br><span class="line"><span class="comment">#官方网站可以下载正式版的</span></span><br></pre></td></tr></table></figure></li><li>软件界面<br><img src="/img/teams.png" alt="Microsoft Teams"></li></ul><h3 id="录屏推流软件"><a href="#录屏推流软件" class="headerlink" title="录屏推流软件"></a>录屏推流软件</h3><p>我为了用Linux开会，也是愁死我了。<br>最后，只能使用OBS进行推流共享屏幕了。</p><ul><li>OBS Studio</li><li>安装方式<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pacman -S obs-studio</span><br></pre></td></tr></table></figure></li><li>软件界面<br><img src="/img/obs.png" alt="OBS Studio"></li></ul><h3 id="RSS订阅软件"><a href="#RSS订阅软件" class="headerlink" title="RSS订阅软件"></a>RSS订阅软件</h3><p>这软件我是找了好久，以前还打算自己用Qt写一个。<br>这是我每天基本都是打开的软件。</p><ul><li>Akregator</li><li>安装方式<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pacman -S akregator</span><br></pre></td></tr></table></figure></li><li>软件界面<br><img src="/img/akregator.png" alt="Akregator"></li></ul><h3 id="远程控制软件"><a href="#远程控制软件" class="headerlink" title="远程控制软件"></a>远程控制软件</h3><p>我也是听我朋友说，才知道TeamViewer有全平台版本，就是目前功能不全。</p><ul><li>TeamViewer</li><li>安装方式<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pacman -S teamviewer</span><br></pre></td></tr></table></figure></li><li>软件界面<br><img src="/img/tv.png" alt="TeamViewer"></li></ul><h3 id="资源下载"><a href="#资源下载" class="headerlink" title="资源下载"></a>资源下载</h3><p>我以前写过一篇qBittorrent的博客</p><ul><li>qBittorrent enhanced editors (增强版，会自动更新tracker服务器列表)</li><li>Github<blockquote><p><a href="https://github.com/c0re100/qBittorrent-Enhanced-Edition">https://github.com/c0re100/qBittorrent-Enhanced-Edition</a></p></blockquote></li><li>软件界面<br><img src="/img/qbit.png" alt="qBittorrent"></li></ul><h3 id="网络仿真"><a href="#网络仿真" class="headerlink" title="网络仿真"></a>网络仿真</h3><ul><li>我在计算机网络实验课程，用来做实验的。</li><li>Cisco Packet Tracer</li><li>安装命令<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pacman -S packettracer</span><br></pre></td></tr></table></figure></li><li>软件界面<br><img src="/img/packetTracer.png" alt="Cisco Packet Tracer"></li></ul><p>这个故事就到这里吧🎊🎊🎊</p><p>Linux没有你想的那么好，但也没有你想的那么差。<br><img src="/img/desktop.png" alt="我的桌面"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天，我是来填坑的。前段时间挖了这个坑，今天就把它填上。&lt;/p&gt;
&lt;p&gt;这篇Blog是&lt;a href=&quot;/2020/11/02/%E6%88%91%E7%9A%84Linux/&quot;&gt;我与Linux的爱恨情仇&lt;/a&gt;后续之作。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux之路" scheme="http://yoursite.com/categories/Linux%E4%B9%8B%E8%B7%AF/"/>
    
    
    <category term="Arch" scheme="http://yoursite.com/tags/Arch/"/>
    
    <category term="Manjaro" scheme="http://yoursite.com/tags/Manjaro/"/>
    
    <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>EduCoder-Java面向对象之包装类</title>
    <link href="http://yoursite.com/2020/11/27/EduCoder-Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E5%8C%85%E8%A3%85%E7%B1%BB/"/>
    <id>http://yoursite.com/2020/11/27/EduCoder-Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E5%8C%85%E8%A3%85%E7%B1%BB/</id>
    <published>2020-11-27T11:20:48.000Z</published>
    <updated>2020-11-27T12:15:44.838Z</updated>
    
    <content type="html"><![CDATA[<p>我已经忘记了，上次更新博客是什么时候🤣。<br>电脑上也有不少的知识点碎片没有整理，也许是我比较懒。</p><a id="more"></a><p>这几天，学校出了教学事故。上了半个学期的Java Spring boot开发，<br>才知道同学没有学过Java，。🤪<br><del>我也就只能偷偷笑了，反正我也不喜欢Spring boot开发(为啥呢？？ 后期更新说明)</del><br>然后，学校就把Spring boot 的课程改成了Java(网课，Spring boot 也是一直上网课)。<br>第一节课就是配个环境，对于我Linux用户配java环境不存在的(<del>就是这么霸气</del>)。<br>不过，老师提供了在Educoder上的课程安排。</p><p>我就用了几天的课余时间刷了一下Java题目，回顾一下Java语言。</p><h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><ul><li><p>在JAVA中，八大基础数据类型（int,float,double…）是不具备对象的特征的，比如基本数据类型就不能调用方法，功能简单，为了让基本数据类型也具备对象的特征，就有了JAVA<code>包装类(Wrapper Classes)</code>。</p></li><li><p>基础数据类型是没有属性的，也是不能调用方法的。</p></li><li><p>包装类就是：将基本数据类型包装成对象，使其具有了对象的属性和方法。<br>这样就可以使用方法和属性了。</p></li></ul><h3 id="包装类作用"><a href="#包装类作用" class="headerlink" title="包装类作用"></a>包装类作用</h3><ul><li><p>将本类型与其他类型进行转换；</p></li><li><p>将字符串与本类型及包装类型相互转换。</p></li></ul><h3 id="包装类使用方式"><a href="#包装类使用方式" class="headerlink" title="包装类使用方式"></a>包装类使用方式</h3><ul><li><p>很简单把TA当成对象就可以了(<del>sorry,忘了你没有对象</del>)</p></li><li><p>代码如下:🍖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="keyword">new</span> Integer(<span class="number">100</span>);</span><br><span class="line">Integer j = <span class="number">100</span>;</span><br></pre></td></tr></table></figure><p>以上两种方式都可以。</p></li><li><p><code>基本数据类型</code>转换成<code>包装类</code>的过程叫做<code>装箱(boxing)</code>。</p></li><li><p><code>包装类</code>转换成<code>基本数据类型</code>的过程叫做<code>拆箱(unboxing)</code>。</p></li><li><p>代码如下：🍖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">Integer x= <span class="keyword">new</span> Integer(i);  <span class="comment">//手动装箱</span></span><br><span class="line">Integer y = i; <span class="comment">//自动装箱</span></span><br><span class="line"></span><br><span class="line">Integer j = <span class="keyword">new</span> Integer(<span class="number">9</span>);</span><br><span class="line">iint m = j.intValue(); <span class="comment">//手动拆箱</span></span><br><span class="line"><span class="keyword">int</span> n = j;<span class="comment">//自动拆箱</span></span><br></pre></td></tr></table></figure><p>装箱和拆箱可以分为<code>手动--</code>和<code>自动--(autoboxing)</code>。</p></li></ul><p><code>这里的手动(EduCoder上是这么说的)，我并没有找到官方的说法。</code></p><ul><li><p>官方说法🔗</p><blockquote><p><a href="(https://docs.oracle.com/javase/7/docs/technotes/guides/language/autoboxing.html)">Autoboxing<br>As any Java programmer knows, you can’t put an int (or other primitive value) into a collection. Collections can only hold object references, so you have to box primitive values into the appropriate wrapper class (which is Integer in the case of int). When you take the object out of the collection, you get the Integer that you put in; if you need an int, you must unbox the Integer using the intValue method. All of this boxing and unboxing is a pain, and clutters up your code. The autoboxing and unboxing feature automates the process, eliminating the pain and the clutter.</a></p></blockquote></li><li><p>Autoboxing 是为了简化使用Collection时，从基本类型到包转类型，使用结束后，又要从包装类型转化到基本类型的繁琐过程。</p></li></ul><h3 id="基础类型和包装类"><a href="#基础类型和包装类" class="headerlink" title="基础类型和包装类"></a>基础类型和包装类</h3><table><thead><tr><th>基本类型</th><th>对应的包装类型</th></tr></thead><tbody><tr><td>bye</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>char</td><td>Character</td></tr><tr><td>boolean</td><td>Boolean</td></tr></tbody></table><p>上图，就是两者的对应关系了。</p><p>说了一大堆，感觉没啥用呀。<del>其实我就是为了水一期博客😝</del></p><p>好吧，这里是为了后面Java <code>Collection</code>做准备，Collection 相当于C++里面的<code>STL</code>,今天就到这里吧！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我已经忘记了，上次更新博客是什么时候🤣。&lt;br&gt;电脑上也有不少的知识点碎片没有整理，也许是我比较懒。&lt;/p&gt;</summary>
    
    
    
    <category term="回归之路" scheme="http://yoursite.com/categories/%E5%9B%9E%E5%BD%92%E4%B9%8B%E8%B7%AF/"/>
    
    
    <category term="EduCoder" scheme="http://yoursite.com/tags/EduCoder/"/>
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>基本排序算法</title>
    <link href="http://yoursite.com/2020/11/22/%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2020/11/22/%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</id>
    <published>2020-11-22T12:18:22.000Z</published>
    <updated>2020-11-23T07:26:52.644Z</updated>
    
    <content type="html"><![CDATA[<p>半个月没写博客了，两个星期前结束了HMTL课程。然后就考完试了，终于不用上这么无聊的课程了。<br>博客有时间还是要坚持写的，今天就开始吧。</p><a id="more"></a><p>今天就来看看，下面这些基本算法吧！ </p><h2 id="Selection-Sort"><a href="#Selection-Sort" class="headerlink" title="Selection-Sort"></a>Selection-Sort</h2><ul><li>选择排序。</li><li>时间复杂度O(n^2)、空间复杂度O(1)。</li><li>采用双重遍历，内层遍历没次寻找[i,n)区间里的最小值<br>然后，与第i个元素进行交换( [0,i) 区间为有序序列)。</li><li>图解如下：<br><img src="/img/selection-sort.jpg" alt="Selection-Sort"></li><li>代码如下：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++)&#123;</span><br><span class="line">        <span class="comment">// 寻找[i, n)区间里的最小值</span></span><br><span class="line">        <span class="keyword">int</span> minIndex = i;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j = i + <span class="number">1</span> ; j &lt; n ; j ++ )</span><br><span class="line">            <span class="keyword">if</span>( arr[j] &lt; arr[minIndex] )</span><br><span class="line">                minIndex = j;</span><br><span class="line">        swap( arr[i] , arr[minIndex] );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Insertion-Sort"><a href="#Insertion-Sort" class="headerlink" title="Insertion-Sort"></a>Insertion-Sort</h2></li><li>插入排序。</li><li>时间复杂度O(n^2)、空间复杂度O(1);</li><li>采用双重遍历，单独看最左边的原始为有序(任意一个单独的元素都为有序序列)。选择该元素的下一元素，插入到前面的有序序列中，是该序列依旧有序。</li><li>图解如下：<br><img src="/img/insertion-sort.jpg" alt="Insertion-Sort"></li><li>代码如下：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(T arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n ; i ++ ) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 寻找元素arr[i]合适的插入位置</span></span><br><span class="line">        <span class="comment">//[0,i-1)区间为有序序列，[i-1,n) 为待遍历序列。</span></span><br><span class="line">       <span class="keyword">for</span>( <span class="keyword">int</span> j = i ; j &gt; <span class="number">0</span> ; j-- )</span><br><span class="line">           <span class="keyword">if</span>( arr[j] &lt; arr[j<span class="number">-1</span>] )</span><br><span class="line">               swap( arr[j] , arr[j<span class="number">-1</span>] );</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Bubble-Sort"><a href="#Bubble-Sort" class="headerlink" title="Bubble-Sort"></a>Bubble-Sort</h2></li><li>冒泡排序 (这个好熟悉呀)</li><li>时间复杂度O(n^2)、空间复杂度O(1);</li><li>采用双重遍历，每次内层需要寻找最大的元素，使该元素沉到数组尾部(有序序列的最前面)。</li><li>图解如下：<br><img src="/img/bubble-sort.jpg" alt="Bubble-Sort"></li><li>代码如下：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bubble</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span>; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span> ; ++j)</span><br><span class="line">            <span class="keyword">if</span>(nums[j]  &gt;  nums[j + <span class="number">1</span>])</span><br><span class="line">                swap(nums[j],nums[j+<span class="number">1</span>]); </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Shell-Sort"><a href="#Shell-Sort" class="headerlink" title="Shell-Sort"></a>Shell-Sort</h2></li><li>希尔排序 (日常见的比较少)。</li><li>时间复杂度O(n^1.3) 空间复杂度O(1)。</li><li>希尔排序又称缩小增量排序，基于插入排序。基本思想是划分多组分别进行插入排序。</li><li>图解如下：<br><img src="/img/shell-sort.jpg" alt="Shell-Sort"></li><li>代码如下:<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//增量gap，并逐步缩小增量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> gap = arr.<span class="built_in">size</span>() / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//从第gap个元素，逐个对其所在组进行直接插入排序操作</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; arr.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line">            <span class="keyword">while</span> (j - gap &gt;= <span class="number">0</span> &amp;&amp; arr[j] &lt; arr[j - gap])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//插入排序采用交换法</span></span><br><span class="line">                swap(arr, j, j - gap);</span><br><span class="line">                j -= gap;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>基本排序算法时间复杂度基本都是O(n^2)，shell-sort时间复杂度度也达不到O(n)。🙄</p><p>今天就到这里吧～～～ bye.💝</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;半个月没写博客了，两个星期前结束了HMTL课程。然后就考完试了，终于不用上这么无聊的课程了。&lt;br&gt;博客有时间还是要坚持写的，今天就开始吧。&lt;/p&gt;</summary>
    
    
    
    
    <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
    <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>STL容器分类</title>
    <link href="http://yoursite.com/2020/11/09/STL%E5%AE%B9%E5%99%A8%E5%88%86%E7%B1%BB/"/>
    <id>http://yoursite.com/2020/11/09/STL%E5%AE%B9%E5%99%A8%E5%88%86%E7%B1%BB/</id>
    <published>2020-11-09T08:51:16.000Z</published>
    <updated>2021-02-24T07:46:57.439Z</updated>
    
    <content type="html"><![CDATA[<p>C++ STL(Standard Template Library) 标准模板库，<br>是类模板的通用集合。</p><a id="more"></a><h2 id="STL结构"><a href="#STL结构" class="headerlink" title="STL结构"></a>STL结构</h2><p>STL 结构分为三类</p><h2 id="Sequences-顺序"><a href="#Sequences-顺序" class="headerlink" title="Sequences(顺序)"></a>Sequences(顺序)</h2><ul><li><p>Vectors</p></li><li><p>Lists</p></li><li><p>Double-Ended Queues</p></li></ul><h2 id="Container-Adapters-容器适配器"><a href="#Container-Adapters-容器适配器" class="headerlink" title="Container Adapters(容器适配器)"></a>Container Adapters(容器适配器)</h2><ul><li><p>Stacks</p></li><li><p>Queus</p></li><li><p>Priority Queues</p></li></ul><h2 id="Associative-Containser-关联容器"><a href="#Associative-Containser-关联容器" class="headerlink" title="Associative Containser(关联容器)"></a>Associative Containser(关联容器)</h2><ul><li><p>Bitsets</p></li><li><p>Maps</p></li><li><p>Multimaps</p></li><li><p>Sets</p></li><li><p>MultiSets</p></li></ul><h2 id="Iterators-迭代器"><a href="#Iterators-迭代器" class="headerlink" title="Iterators(迭代器)"></a>Iterators(迭代器)</h2><p>在使用STL过程经常需要访问Container中的元素，Iterator是不可少的。</p><ul><li><p>迭代器用于访问容器类的成员，并且可以在类似的情况下使用指针的方式。例如，可能使用迭代器逐步遍历元素。</p></li><li><p>迭代器共分为六种</p></li></ul><h3 id="input-iterator"><a href="#input-iterator" class="headerlink" title="input_iterator"></a>input_iterator</h3><p>只能一次一个向前读取元素，按此顺序一个个传回元素值。</p><h3 id="output-iterator"><a href="#output-iterator" class="headerlink" title="output_iterator"></a>output_iterator</h3><p>Output迭代器和Input迭代器相反，其作用是将元素值一个个写入。</p><h3 id="forward-iterator"><a href="#forward-iterator" class="headerlink" title="forward_iterator"></a>forward_iterator</h3><p>Forward迭代器是Input迭代器与Output迭代器的结合，具有Input迭代器的全部功能和Output迭代器的大部分功能。</p><h3 id="bidirectional-iterator"><a href="#bidirectional-iterator" class="headerlink" title="bidirectional_iterator"></a>bidirectional_iterator</h3><p>Bidirectional（双向）迭代器在Forward迭代器的基础上增加了回头遍历的能力。换言之，它支持递减操作符，用以一步一步的后退操作。</p><h3 id="random-iterator"><a href="#random-iterator" class="headerlink" title="random_iterator"></a>random_iterator</h3><p>Random Access迭代器在Bidirectional迭代器的基础上再增加随机存取能力。因此它必须提供“迭代器算数运算”（和一般指针“指针算术运算”相当）。</p><h3 id="reverse-iterator"><a href="#reverse-iterator" class="headerlink" title="reverse_iterator"></a>reverse_iterator</h3><p>逆向迭代器重新定义递增运算和递减运算，使其行为正好倒置。成员函数rbegin()和rend()各传回一个Reverse迭代器，和begin()和end()类似，共同定义一个半开区间。</p><p>在后续，我会从Sequences的Vectors到MultiSets逐步编写博文。加油!!</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;C++ STL(Standard Template Library) 标准模板库，&lt;br&gt;是类模板的通用集合。&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
    <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="STL" scheme="http://yoursite.com/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>Linux相关网络命令</title>
    <link href="http://yoursite.com/2020/11/08/Linux%E7%9B%B8%E5%85%B3%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2020/11/08/Linux%E7%9B%B8%E5%85%B3%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4/</id>
    <published>2020-11-08T12:36:23.000Z</published>
    <updated>2020-11-08T12:53:06.586Z</updated>
    
    <content type="html"><![CDATA[<p>搞了几天运动会，今天才意识到计算机网络的实验报告还没有写完。不过上实验课程的时候，我都把命令敲过了一篇(ping,ipconfig,arp,netstat)。<del>这些我以前就玩过，有点无聊</del></p><a id="more"></a><p>今天，我在linux下面敲这些命令的时候发现有些命令找不到。😭<br>我就查了一下🤔<del>热爱学习的我</del></p><h2 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h2><p>在Windows默认ping 4次。而在Linux下面需要用-c指定次数。</p><h2 id="ipconfig"><a href="#ipconfig" class="headerlink" title="ipconfig"></a>ipconfig</h2><p>可以使用ifconfig，不过有些版本的linux这个命令被取代了。需要是ip address show，就可以查看相关网络配置。</p><h2 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h2><p>地址解析协议，玩过kali局网攻击的话。就很熟悉啦！<br>这个命令在linux下面一样没有，代替命令是ip neighbor会列出 IP 对应的MAC地址。</p><h2 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h2><p>这个命令听说linux系统自带有，不过我的linux版本没有。只有默认的ss(Socket Statistics)命令。加入-t显示IP/TCP相关的信息</p><p>一个小小的命令记录。bye～～～</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;搞了几天运动会，今天才意识到计算机网络的实验报告还没有写完。不过上实验课程的时候，我都把命令敲过了一篇(ping,ipconfig,arp,netstat)。&lt;del&gt;这些我以前就玩过，有点无聊&lt;/del&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Linux之路" scheme="http://yoursite.com/categories/Linux%E4%B9%8B%E8%B7%AF/"/>
    
    
    <category term="Arch" scheme="http://yoursite.com/tags/Arch/"/>
    
    <category term="Manjaro" scheme="http://yoursite.com/tags/Manjaro/"/>
    
    <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>C++Lambda表达式</title>
    <link href="http://yoursite.com/2020/11/06/C-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/11/06/C-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2020-11-06T12:59:34.000Z</published>
    <updated>2020-11-06T13:19:13.578Z</updated>
    
    <content type="html"><![CDATA[<p>今天的每日一题，也是比较简单的！🎊<br>但我，查看官方题解时，我惊呆了。</p><a id="more"></a><p>我看到了如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sort(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), [&amp;](<span class="keyword">int</span> x, <span class="keyword">int</span> y) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bit</span>[x] &lt; <span class="built_in">bit</span>[y])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bit</span>[x] &gt; <span class="built_in">bit</span>[y])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x &lt; y;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我看了半天，没反应过来🤣，看完评论才知道是C++11 的新特性 Lambda表达式。</p><h2 id="Lambda表达式形式"><a href="#Lambda表达式形式" class="headerlink" title="Lambda表达式形式"></a>Lambda表达式形式</h2><blockquote><p>[外部变量访问说明符](参数列表)-&gt;返回值类型{</p><p>语句块</p><p>}</p></blockquote><ul><li>外部访问方式： =表示允许修改外部变量，&amp;不允许修改外部变量</li><li>参数列表：和普通函数一样</li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><ul><li>代码：<pre><code class="C++"><span class="keyword">int</span> a[<span class="number">4</span>] = {<span class="number">11</span>, <span class="number">2</span>, <span class="number">33</span>, <span class="number">4</span>};sort(a, a+<span class="number">4</span>, [=](<span class="keyword">int</span> x, <span class="keyword">int</span> y) -&gt; <span class="keyword">bool</span> {   <span class="keyword">return</span> x%<span class="number">10</span> &lt; y%<span class="number">10</span>;   } );for_each(a, a+<span class="number">4</span>, [=](<span class="keyword">int</span> x) {   <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">" "</span>;   } );</code></pre></li><li>结果： 11 2 33 4</li></ul><h2 id="外部变量"><a href="#外部变量" class="headerlink" title="外部变量"></a>外部变量</h2><ul><li>“外部变量访问方式说明符”还可以有更加复杂和灵活的用法。</li><li>[=, &amp;x, &amp;y]表示外部变量 x、y 的值可以被修改，其余外部变量不能被修改；</li><li>[&amp;, x, y]表示除 x、y 以外的外部变量，值都可以被修改。</li></ul><h2 id="Lambda表达式作用"><a href="#Lambda表达式作用" class="headerlink" title="Lambda表达式作用"></a>Lambda表达式作用</h2><ul><li><p>使用 STL 时，往往会大量用到函数对象，为此要编写很多函数对象类。有的函数对象类只用来定义了一个对象，而且这个对象也只使用了一次，编写这样的函数对象类就有点浪费。</p></li><li><p>说白了，就使用便捷👋</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天的每日一题，也是比较简单的！🎊&lt;br&gt;但我，查看官方题解时，我惊呆了。&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
    <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
    <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>我与Linux的爱恨情仇</title>
    <link href="http://yoursite.com/2020/11/02/%E6%88%91%E7%9A%84Linux/"/>
    <id>http://yoursite.com/2020/11/02/%E6%88%91%E7%9A%84Linux/</id>
    <published>2020-11-02T07:53:30.000Z</published>
    <updated>2020-11-27T13:28:06.788Z</updated>
    
    <content type="html"><![CDATA[<p>我与你第一次相遇，是在2016年。那个时候作为电脑小白的我，带着好奇心把你安装到了我电脑上，那个时候你叫Ubuntu16.04。💝</p><a id="more"></a><p>安装完成后，我失去是我的磁盘原有的所有数据🤔。我当时以为，你的安装方式和Windows是一样的。谁能想到你独吞我整个硬盘，使用你不到一天的时间，我就把Windows给重新安装上了。🤣</p><h2 id="我与Linux爱恨"><a href="#我与Linux爱恨" class="headerlink" title="我与Linux爱恨"></a>我与Linux爱恨</h2><p>后来，和你的见面方式都是在VMware里面了；你就没有单独存在于我的物理机里面。<br>在VMware里面，我尝试过很多的Linux系统。有CentOS、Redhat、Fedora；真正第一次认真敲入命令是在CentOS里面。那个时候，跟着教程一步一步的敲入命令。刚刚开始的时候，还经常敲错。😭</p><p>2018年，我遇到到一个IDE(Android Studio)，体会到什么叫编码两分钟，编译两小时(<del>其实是自己电脑太卡，联想G400</del>)的感觉。<br>每当我有空闲时间的时候，我都会打开浏览器。看看有没有什么可以优化编译的方法，的确通过修改Android Studio的一些配置可以加快编译。但是作用不是很大。🙄，还看到了很多关于Linux对硬件性能低的博客。</p><h2 id="我的Linux时代"><a href="#我的Linux时代" class="headerlink" title="我的Linux时代"></a>我的Linux时代</h2><p>2018年的冬天，我就在我的物理机里面安装Fedora系统。当时我还在我的VMware里面体验过，感觉不错。<br>可是，在实际中出现了几个问题。</p><ul><li>使用的人比较少，出了问题比较难解决。</li><li>我在安装51编译库的时候，发现编译工具的名称尽然不同。(<del>当时想骂人</del>)</li><li>对于国内用户QQ是非常重要的，Fedora安装QQ是比较困难的。</li></ul><p>用了不到一个星期。我就从Fedora，步入了Arch魔教的阵营(现在我新买的电脑上用Manjaro(基于arch开发的))。</p><p>从2018年到现在，我已经习惯了Linux的简洁和高效。<br>对于Linux，我喜欢一下几点 </p><ul><li>一切皆文件</li><li>拥有Root，拥有一切</li><li>一条命令，安装需要的软件。(next..next..next 不存在的)</li><li>我可以任意修改所有文件，达到我想要的效果。</li><li>我可以任意改动我的桌面布局，不需要安装任何额外的软件。</li><li>我可以切换不同的桌面环境。</li></ul><h2 id="我的Linux软件"><a href="#我的Linux软件" class="headerlink" title="我的Linux软件"></a>我的Linux软件</h2><p>下面说说，我日常使用哪些软件。</p><h3 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h3><ul><li>Google Chrome  (刚刚从chromuim切换过来)</li><li>安装方式<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pacman -S google-chrome</span><br></pre></td></tr></table></figure></li><li>软件界面<br><img src="/img/chrome.png" alt="Google Chrome"></li></ul><h3 id="编程工具"><a href="#编程工具" class="headerlink" title="编程工具"></a>编程工具</h3><h4 id="Android-开发"><a href="#Android-开发" class="headerlink" title="Android 开发"></a>Android 开发</h4><ul><li>Android Studio </li><li>安装方式<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pacman -S android-studio</span><br></pre></td></tr></table></figure></li><li>软件界面<br><img src="/img/android.png" alt="Android Studio"></li></ul><h4 id="Java开发"><a href="#Java开发" class="headerlink" title="Java开发"></a>Java开发</h4><ul><li>IntelliJ idea 社区版</li><li>安装方式<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pacman -S intellij-idea-community-edition</span><br></pre></td></tr></table></figure></li><li>软件界面<br><img src="/img/idea.png" alt="IntelliJ Idea"></li></ul><h4 id="C-开发"><a href="#C-开发" class="headerlink" title="C++开发"></a>C++开发</h4><ul><li>Visual Studio Code</li><li>这个编辑器结合插件非常好用，我写博客也是用这个</li><li>安装方式<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pacman -S visual-stduio-code-bin</span><br></pre></td></tr></table></figure></li><li>软件界面<br><img src="/img/vscode.png" alt="Visual Studio Code"></li></ul><h3 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h3><h4 id="VirtualBox"><a href="#VirtualBox" class="headerlink" title="VirtualBox"></a>VirtualBox</h4><ul><li>安装方式，看我以前写的如何安装Virtualbox的博客<h4 id="VMware（需要激活）"><a href="#VMware（需要激活）" class="headerlink" title="VMware（需要激活）"></a>VMware（需要激活）</h4></li><li>安装方式<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pacman -S vmware-workstation</span><br></pre></td></tr></table></figure>这个两个我都使用过，目前在使用vmware</li><li>软件界面<br><img src="/img/vmware.png" alt="VMware"></li></ul><h3 id="通讯"><a href="#通讯" class="headerlink" title="通讯"></a>通讯</h3><h4 id="QQ"><a href="#QQ" class="headerlink" title="QQ"></a>QQ</h4><ul><li>使用deepin的wine运行的TIM</li><li>安装方式<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pacman -S deepin.com.qq.office</span><br></pre></td></tr></table></figure></li><li>软件界面<br><img src="/img/tim.png" alt="QQ"></li></ul><h4 id="Evolution"><a href="#Evolution" class="headerlink" title="Evolution"></a>Evolution</h4><ul><li>这是一个电子邮箱客户端(主要用来给老师和学委发作业之类的)</li><li>安装方式<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pacman -S evolution</span><br></pre></td></tr></table></figure></li><li>软件界面<br><img src="/img/evolution.png" alt="Evolution"></li></ul><h3 id="AUR-助手工具"><a href="#AUR-助手工具" class="headerlink" title="AUR 助手工具"></a>AUR 助手工具</h3><ul><li>用来安装AUR(Arch User Repository)仓库的软件</li><li>安装方式<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pacman -S yay</span><br></pre></td></tr></table></figure></li><li>软件界面<br><img src="/img/yay.png" alt="YAY"></li></ul><h3 id="音乐"><a href="#音乐" class="headerlink" title="音乐"></a>音乐</h3><ul><li>落雪音乐助手，一款开源软件</li><li>安装方式,需要自己下载.pacman的包，然后安装<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pacman -U *.pacman</span><br></pre></td></tr></table></figure></li><li>直接下载Appimage后缀的，可以自己运行。</li><li>软件界面<br><img src="/img/lx.png" alt="落雪音乐助手"></li></ul><h3 id="office替代品"><a href="#office替代品" class="headerlink" title="office替代品"></a>office替代品</h3><ul><li>Micosoft office 的良好替代品</li><li>安装方式<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pacman -S wps-office</span><br></pre></td></tr></table></figure></li><li>软件界面<br><img src="/img/wps.png" alt="WPS"><br>今天就分享到这里吧，有些软件后续补上。🎊🎊</li></ul><p>希望，你也加入Linux</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我与你第一次相遇，是在2016年。那个时候作为电脑小白的我，带着好奇心把你安装到了我电脑上，那个时候你叫Ubuntu16.04。💝&lt;/p&gt;</summary>
    
    
    
    <category term="Linux之路" scheme="http://yoursite.com/categories/Linux%E4%B9%8B%E8%B7%AF/"/>
    
    
    <category term="Arch" scheme="http://yoursite.com/tags/Arch/"/>
    
    <category term="Manjaro" scheme="http://yoursite.com/tags/Manjaro/"/>
    
    <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>349.两个数组的交集</title>
    <link href="http://yoursite.com/2020/11/02/349-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/"/>
    <id>http://yoursite.com/2020/11/02/349-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/</id>
    <published>2020-11-02T07:07:19.000Z</published>
    <updated>2020-11-02T07:53:10.488Z</updated>
    
    <content type="html"><![CDATA[<p>今天的每日一题就很简单啦。🎊<br>今天就不废话了，直接上题目吧。</p><a id="more"></a><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>给定两个数组，编写一个函数来计算它们的交集。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><blockquote><p>输入：nums1 = [1,2,2,1], nums2 = [2,2]<br>输出：[2]</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul><li>最简单的方法，采用逐个比较。及nums1中的每个元素都与nums2中的每个元素进行比较，如果相等，这加入到容器中，再对容器进行去重就可以了。</li><li>代码如下<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">intersection</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums1.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums2.<span class="built_in">size</span>(); ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums1[i] == nums2[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    res.push_back(nums1[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator ite = unique(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        res.erase(ite, res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="更优解法"><a href="#更优解法" class="headerlink" title="更优解法"></a>更优解法</h2></li><li>官方解法<blockquote><p>如果两个数组是有序的，则可以使用双指针的方法得到两个数组的交集。</p><p>首先对两个数组进行排序，然后使用两个指针遍历两个数组。可以预见的是加入答案的数组的元素一定是递增的，为了保证加入元素的唯一性，我们需要额外记录变量 pre 表示上一次加入答案数组的元素。</p><p>初始时，两个指针分别指向两个数组的头部。每次比较两个指针指向的两个数组中的数字，如果两个数字不相等，则将指向较小数字的指针右移一位，如果两个数字相等，且该数字不等于 pre ，将该数字添加到答案并更新 pre 变量，同时将两个指针都右移一位。当至少有一个指针超出数组范围时，遍历结束。</p></blockquote></li></ul><p>今天题目就到这里吧！！ 这是我遇到比较简单的每日一题。🤪🤪🤪</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天的每日一题就很简单啦。🎊&lt;br&gt;今天就不废话了，直接上题目吧。&lt;/p&gt;</summary>
    
    
    
    <category term="修炼之路" scheme="http://yoursite.com/categories/%E4%BF%AE%E7%82%BC%E4%B9%8B%E8%B7%AF/"/>
    
    
    <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
    <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>381.O(1)插入删除和获取随机元</title>
    <link href="http://yoursite.com/2020/10/31/381-%E6%8F%92%E5%85%A5%E5%88%A0%E9%99%A4%E5%92%8C%E8%8E%B7%E5%8F%96%E9%9A%8F%E6%9C%BA%E5%85%83/"/>
    <id>http://yoursite.com/2020/10/31/381-%E6%8F%92%E5%85%A5%E5%88%A0%E9%99%A4%E5%92%8C%E8%8E%B7%E5%8F%96%E9%9A%8F%E6%9C%BA%E5%85%83/</id>
    <published>2020-10-31T12:20:10.000Z</published>
    <updated>2020-10-31T12:48:59.248Z</updated>
    
    <content type="html"><![CDATA[<p>我用了半天的时间，与上帝交换，只为换回你💝！<br>我午睡醒来，打开我的电脑。发现一块黑屏，只有一个鼠标，和左边的dock栏上的白色。<br>该来的总会来，这件事情还是发生！！</p><a id="more"></a><p>我的系统桌面KDE，终于不能用了。我花时间，把KDE换成了DDE(Deepin Desktop Environment)。<br>我也不知道什么原因，竟然不是很好用。有几个应用打不开，主要还是不适应DDE的风格。<br>我就又换回了KDE，安装过程倒是有些崎岖   。不过路边的风景也很美。</p><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>设计一个支持在平均 时间复杂度 O(1) 下， 执行以下操作的数据结构。</p><p>注意: 允许出现重复元素。</p><p>insert(val)：向集合中插入元素 val。<br>remove(val)：当 val 存在时，从集合中移除一个 val。<br>getRandom：从现有集合中随机获取一个元素。每个元素被返回的概率应该与其在集合中的数量呈线性相关。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><blockquote><p>// 初始化一个空的集合。</p><p>RandomizedCollection collection = new &gt; &gt; &gt; &gt; RandomizedCollection();</p><p>// 向集合中插入 1 。返回 true 表示集合不包含 1 。</p><p>collection.insert(1);</p><p>// 向集合中插入另一个 1 。返回 false 表示集合包含 1 。集合现在包含 [1,1] 。<br>collection.insert(1);</p><p>// 向集合中插入 2 ，返回 true 。集合现在包含 [1,1,2] 。</p><p>collection.insert(2);</p><p>// getRandom 应当有 2/3 的概率返回 1 ，1/3 的概率返回 2 。</p><p>collection.getRandom();</p><p>// 从集合中删除 1 ，返回 true 。集合现在包含 [1,2] 。</p><p>collection.remove(1);</p><p>// getRandom 应有相同概率返回 1 和 2 。</p><p>collection.getRandom();</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul><li>我的第一思路，还是用桶排序的方法，把需要插入的元素，插入到数组中。即array[val]++; （val为插入的元素）。遮掩插入和取出的时间复杂度都是O(1)，但是题目没有给出val的取值范围。如果动态变化数组，当val值大于array.size()时，需要移动数组，时间复杂度为O(n)。这显然有违背题目。😅</li><li>当我查看官方解法时，我发现我在STL上的盲区(<del>昨天说学，可是没学</del>)。</li><li>官方解法的思路是哈希表(C++中没有，需要自己实现。使用Map 和 Set就可以实现)。</li><li>代码如下：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomizedCollection</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;&gt; idx;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    RandomizedCollection() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        nums.push_back(val);</span><br><span class="line">        idx[val].insert(nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> idx[val].<span class="built_in">size</span>() == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes a value from the collection. Returns true if the collection contained the specified element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (idx.<span class="built_in">find</span>(val) == idx.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = *(idx[val].<span class="built_in">begin</span>());</span><br><span class="line">        nums[i] = nums.back();</span><br><span class="line">        idx[val].erase(i);</span><br><span class="line">        idx[nums[i]].erase(nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">            idx[nums[i]].insert(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (idx[val].<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            idx.erase(val);</span><br><span class="line">        &#125;</span><br><span class="line">        nums.pop_back();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get a random element from the collection. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nums[rand() % nums.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="更优解法"><a href="#更优解法" class="headerlink" title="更优解法"></a>更优解法</h2></li><li>这里涉及到我知识盲区😭😭😭，我就不写最优解法了。后期补上！！</li></ul><p>万圣节快乐，这是令人难忘的一天。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我用了半天的时间，与上帝交换，只为换回你💝！&lt;br&gt;我午睡醒来，打开我的电脑。发现一块黑屏，只有一个鼠标，和左边的dock栏上的白色。&lt;br&gt;该来的总会来，这件事情还是发生！！&lt;/p&gt;</summary>
    
    
    
    <category term="修炼之路" scheme="http://yoursite.com/categories/%E4%BF%AE%E7%82%BC%E4%B9%8B%E8%B7%AF/"/>
    
    
    <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
    <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>463.岛屿的周长</title>
    <link href="http://yoursite.com/2020/10/30/463-%E5%B2%9B%E5%B1%BF%E7%9A%84%E5%91%A8%E9%95%BF/"/>
    <id>http://yoursite.com/2020/10/30/463-%E5%B2%9B%E5%B1%BF%E7%9A%84%E5%91%A8%E9%95%BF/</id>
    <published>2020-10-30T09:02:25.000Z</published>
    <updated>2020-10-31T08:18:31.690Z</updated>
    
    <content type="html"><![CDATA[<p>在一个岛屿上生活，是我的梦想！😝</p><p>今天，leetcode给我这个机会。计算我岛屿的长度，但是他并没有给我这个岛。</p><a id="more"></a><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>给定一个包含 0 和 1 的二维网格地图，其中 1 表示陆地 0 表示水域。</p><p>网格中的格子水平和垂直方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。</p><p>岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><blockquote><p>输入:</p><p>[[0,1,0,0],</p><p>[1,1,1,0],</p><p>[0,1,0,0],</p><p> [1,1,0,0]]</p><p>输出: 16</p><p>解释: 它的周长是下面图片中的 16 个黄色的边：</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul><li>看到这题题目，我也没什么解题思路；就知道逐个去遍历，应该是可以解出来的。但是并没有清晰的编码思路。</li><li>对于一个陆地格子的每条边，它被算作岛屿的周长当且仅当这条边为网格的边界或者相邻的另一个格子为水域。 因此，我们可以遍历每个陆地格子，看其四个方向是否为边界或者水域，如果是，将这条边的贡献（即 11）加入答案 \textit{ans}ans 中即可。（官方解题思路）</li><li>官方提供的解题思路，就是遍历每一个正方形；然后看这个正方形的周围(右，下，左，上的遍历顺序，可以改变)时候有陆地或水域，如果有水域或者是网格的边缘，那周长就加1。</li><li>总时间复杂度为：O(4nm)=O(nm);空间复杂度：O(1)。</li><li>代码如下<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">islandPerimeter</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;grid)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].<span class="built_in">size</span>(); ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">int</span> tx = i + dx[k];</span><br><span class="line">                        <span class="keyword">int</span> ty = j + dy[k];</span><br><span class="line">                        <span class="keyword">if</span> (tx &lt; <span class="number">0</span> || tx &gt;= grid.<span class="built_in">size</span>() || ty &lt; <span class="number">0</span> || ty &gt;= grid[<span class="number">0</span>].<span class="built_in">size</span>() || !grid[tx][ty])</span><br><span class="line">                            cnt++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ans += cnt;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="更优解法"><a href="#更优解法" class="headerlink" title="更优解法"></a>更优解法</h2>这个就我点困难了(<del>这个题目，我也是看了官方的解释才懂的🤫</del>)，我后期补。最优解一定是有的！！</li></ul><p>对啦，祝大家万圣夜快乐🤪🤪🤪🤪</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在一个岛屿上生活，是我的梦想！😝&lt;/p&gt;
&lt;p&gt;今天，leetcode给我这个机会。计算我岛屿的长度，但是他并没有给我这个岛。&lt;/p&gt;</summary>
    
    
    
    <category term="修炼之路" scheme="http://yoursite.com/categories/%E4%BF%AE%E7%82%BC%E4%B9%8B%E8%B7%AF/"/>
    
    
    <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
    <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>1207.独一无二的出现次数</title>
    <link href="http://yoursite.com/2020/10/28/1207-%E7%8B%AC%E4%B8%80%E6%97%A0%E4%BA%8C%E7%9A%84%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0/"/>
    <id>http://yoursite.com/2020/10/28/1207-%E7%8B%AC%E4%B8%80%E6%97%A0%E4%BA%8C%E7%9A%84%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0/</id>
    <published>2020-10-28T11:42:05.000Z</published>
    <updated>2020-10-28T12:07:43.810Z</updated>
    
    <content type="html"><![CDATA[<p>今天，把个人博客的主题换了一个。没有以前那么好看了。但是访问速度提升了不少。以后，有时间的话。我还是打算美化一下，但是毕竟我不是搞前端的，个人博客对我而言就是拿来发发个人感想，记录个人生活的。<br>废话到这里🧑‍🔬，看题目吧～～～</p><a id="more"></a><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>给你一个整数数组 arr，请你帮忙统计数组中每个数的出现次数。</p><p>如果每个数的出现次数都是独一无二的，就返回 true；否则返回 false。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><blockquote><p>输入：arr = [1,2,2,1,1,3]</p><p>输出：true</p><p>解释：在该数组中，1 出现了 3 次，2 出现了 2 次，3 只出现了 1 次。没有两个数的出现次数相同。</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul><li><p>我看到这个题目，就想到了前一天，类似于桶排序的思路。<br>后面看到给出的数据范围，-1000&lt;= arr[i] &lt;= 1000，我就意识到了直接使用桶排序的思维是解决不了的(数组下标不能为负数)。😅</p></li><li><p>思考一会后，我想到了STL里面的Map（键值对的方式存储数据）。这里的键是一个泛型(这就可以解决直接使用数组，下标不能为负数的情况)，接着在使用桶排序的思想，对map里面的值进行统计。再判断统计数据的值是否大于1,如果大于一这出现了重复次数的数字。🎊🎊🎊🎊🎊(<del>撒花，掌声</del>)</p></li><li><p>时间复杂度约为O(3n),其实一般成为O(n);空间复杂度约为O(2n),也可以称作O(n)。</p></li><li><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">uniqueOccurrences</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;arr)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : arr)</span><br><span class="line">        &#123;</span><br><span class="line">            m[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">int</span> aux[<span class="number">1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : m)</span><br><span class="line">        &#123;</span><br><span class="line">            aux[i.second]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (aux[i] &gt; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id="更优解法"><a href="#更优解法" class="headerlink" title="更优解法"></a>更优解法</h2><p>无独有偶，在题目的评论区也有一个很有意思的解法。👋👋<br>作者是使用了STL库中的Map 和 Set。(当初我也有这想法，只是我对STL库不是用了解，<del>看来需要好好学习STL库呀</del>)</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">uniqueOccurrences</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.<span class="built_in">size</span>();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            m[arr[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;times;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> p:m)</span><br><span class="line">            times.insert(p.second);</span><br><span class="line">        <span class="keyword">return</span> times.<span class="built_in">size</span>()==m.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这段代码的帅气程度快要赶上我了（<del>不要脸</del>）🤞🤞🤞🎊🎊🎊</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天，把个人博客的主题换了一个。没有以前那么好看了。但是访问速度提升了不少。以后，有时间的话。我还是打算美化一下，但是毕竟我不是搞前端的，个人博客对我而言就是拿来发发个人感想，记录个人生活的。&lt;br&gt;废话到这里🧑‍🔬，看题目吧～～～&lt;/p&gt;</summary>
    
    
    
    <category term="修炼之路" scheme="http://yoursite.com/categories/%E4%BF%AE%E7%82%BC%E4%B9%8B%E8%B7%AF/"/>
    
    
    <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
    <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
